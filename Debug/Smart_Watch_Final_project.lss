
Smart_Watch_Final_project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005e08  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000052  00800060  00005e08  00005e9c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000723  008000b2  008000b2  00005eee  2**0
                  ALLOC
  3 .stab         00007b6c  00000000  00000000  00005ef0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003b42  00000000  00000000  0000da5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0001159e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  000116de  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0001184e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00013497  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  00014382  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00015130  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  00015290  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  0001551d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00015ceb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 9f 1c 	jmp	0x393e	; 0x393e <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 7a 06 	jmp	0xcf4	; 0xcf4 <__vector_13>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 5c 0b 	jmp	0x16b8	; 0x16b8 <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e0       	ldi	r30, 0x08	; 8
      68:	fe e5       	ldi	r31, 0x5E	; 94
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a2 3b       	cpi	r26, 0xB2	; 178
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a2 eb       	ldi	r26, 0xB2	; 178
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 3d       	cpi	r26, 0xD5	; 213
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 2d 28 	call	0x505a	; 0x505a <main>
      8a:	0c 94 02 2f 	jmp	0x5e04	; 0x5e04 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 ac 2e 	jmp	0x5d58	; 0x5d58 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	af e8       	ldi	r26, 0x8F	; 143
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 c8 2e 	jmp	0x5d90	; 0x5d90 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 b8 2e 	jmp	0x5d70	; 0x5d70 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 d4 2e 	jmp	0x5da8	; 0x5da8 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 b8 2e 	jmp	0x5d70	; 0x5d70 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 d4 2e 	jmp	0x5da8	; 0x5da8 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 ac 2e 	jmp	0x5d58	; 0x5d58 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8f e8       	ldi	r24, 0x8F	; 143
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 c8 2e 	jmp	0x5d90	; 0x5d90 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 b8 2e 	jmp	0x5d70	; 0x5d70 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 d4 2e 	jmp	0x5da8	; 0x5da8 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 b8 2e 	jmp	0x5d70	; 0x5d70 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 d4 2e 	jmp	0x5da8	; 0x5da8 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 b8 2e 	jmp	0x5d70	; 0x5d70 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 d4 2e 	jmp	0x5da8	; 0x5da8 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 bc 2e 	jmp	0x5d78	; 0x5d78 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 d8 2e 	jmp	0x5db0	; 0x5db0 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <MUSART_VidInit>:

void (*MUSART_CallBack)(void);

/*USART Initialization*/
void MUSART_VidInit(void)
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	0f 92       	push	r0
     b4c:	cd b7       	in	r28, 0x3d	; 61
     b4e:	de b7       	in	r29, 0x3e	; 62
	u8 LOC_u8Copy_UCSRC=0;
     b50:	19 82       	std	Y+1, r1	; 0x01
	/*Select USART Mode*/
#if USART_SET_MODE==USART_ASYNCHRONOUS_MODE
	CLR_BIT(LOC_u8Copy_UCSRC,6);
     b52:	89 81       	ldd	r24, Y+1	; 0x01
     b54:	8f 7b       	andi	r24, 0xBF	; 191
     b56:	89 83       	std	Y+1, r24	; 0x01
#else
#error"USART Mode Is not valid..."
#endif
	/*Parity Mode*/
#if USART_SET_PARITY_MODE==USART_DISABLED_PARITY
	CLR_BIT(LOC_u8Copy_UCSRC,5);
     b58:	89 81       	ldd	r24, Y+1	; 0x01
     b5a:	8f 7d       	andi	r24, 0xDF	; 223
     b5c:	89 83       	std	Y+1, r24	; 0x01
	CLR_BIT(LOC_u8Copy_UCSRC,4);
     b5e:	89 81       	ldd	r24, Y+1	; 0x01
     b60:	8f 7e       	andi	r24, 0xEF	; 239
     b62:	89 83       	std	Y+1, r24	; 0x01
#else
#error"USART Parity Mode Is not valid..."
#endif
	/*Select Stop Bit*/
#if USART_SET_STOP_BIT==USART_STOP_ONE_BIT
	CLR_BIT(LOC_u8Copy_UCSRC,3);
     b64:	89 81       	ldd	r24, Y+1	; 0x01
     b66:	87 7f       	andi	r24, 0xF7	; 247
     b68:	89 83       	std	Y+1, r24	; 0x01
#elif USART_SET_CHR_SIZE==USART_CHR_SIZE_7
	SET_BIT(LOC_u8Copy_UCSRC,2);
	CLR_BIT(LOC_u8Copy_UCSRC,1);
	CLR_BIT(UCSRB,2);
#elif USART_SET_CHR_SIZE==USART_CHR_SIZE_8
	SET_BIT(LOC_u8Copy_UCSRC,2);
     b6a:	89 81       	ldd	r24, Y+1	; 0x01
     b6c:	84 60       	ori	r24, 0x04	; 4
     b6e:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(LOC_u8Copy_UCSRC,1);
     b70:	89 81       	ldd	r24, Y+1	; 0x01
     b72:	82 60       	ori	r24, 0x02	; 2
     b74:	89 83       	std	Y+1, r24	; 0x01
	CLR_BIT(UCSRB,2);
     b76:	aa e2       	ldi	r26, 0x2A	; 42
     b78:	b0 e0       	ldi	r27, 0x00	; 0
     b7a:	ea e2       	ldi	r30, 0x2A	; 42
     b7c:	f0 e0       	ldi	r31, 0x00	; 0
     b7e:	80 81       	ld	r24, Z
     b80:	8b 7f       	andi	r24, 0xFB	; 251
     b82:	8c 93       	st	X, r24
	SET_BIT(UCSRB,2);
#else
#error"USART CHR SIZE Is not valid..."
#endif
	/*Set LOC_u8Copy_UCSRC Value in UCSRC Register and select UCSRC Register*/
	SET_BIT(LOC_u8Copy_UCSRC,7);
     b84:	89 81       	ldd	r24, Y+1	; 0x01
     b86:	80 68       	ori	r24, 0x80	; 128
     b88:	89 83       	std	Y+1, r24	; 0x01
	UCSRC=LOC_u8Copy_UCSRC;
     b8a:	e0 e4       	ldi	r30, 0x40	; 64
     b8c:	f0 e0       	ldi	r31, 0x00	; 0
     b8e:	89 81       	ldd	r24, Y+1	; 0x01
     b90:	80 83       	st	Z, r24
	/*Set BuadRate -->9600*/
	UBRRL=51;
     b92:	e9 e2       	ldi	r30, 0x29	; 41
     b94:	f0 e0       	ldi	r31, 0x00	; 0
     b96:	83 e3       	ldi	r24, 0x33	; 51
     b98:	80 83       	st	Z, r24
	/*Enable To TX and RX*/
	SET_BIT(UCSRB,4);
     b9a:	aa e2       	ldi	r26, 0x2A	; 42
     b9c:	b0 e0       	ldi	r27, 0x00	; 0
     b9e:	ea e2       	ldi	r30, 0x2A	; 42
     ba0:	f0 e0       	ldi	r31, 0x00	; 0
     ba2:	80 81       	ld	r24, Z
     ba4:	80 61       	ori	r24, 0x10	; 16
     ba6:	8c 93       	st	X, r24
	SET_BIT(UCSRB,3);
     ba8:	aa e2       	ldi	r26, 0x2A	; 42
     baa:	b0 e0       	ldi	r27, 0x00	; 0
     bac:	ea e2       	ldi	r30, 0x2A	; 42
     bae:	f0 e0       	ldi	r31, 0x00	; 0
     bb0:	80 81       	ld	r24, Z
     bb2:	88 60       	ori	r24, 0x08	; 8
     bb4:	8c 93       	st	X, r24
}
     bb6:	0f 90       	pop	r0
     bb8:	cf 91       	pop	r28
     bba:	df 91       	pop	r29
     bbc:	08 95       	ret

00000bbe <MUSART_VidSendChar>:
/*USART Send Data*/
void MUSART_VidSendChar(u8 Copy_u8Data)
{
     bbe:	df 93       	push	r29
     bc0:	cf 93       	push	r28
     bc2:	0f 92       	push	r0
     bc4:	cd b7       	in	r28, 0x3d	; 61
     bc6:	de b7       	in	r29, 0x3e	; 62
     bc8:	89 83       	std	Y+1, r24	; 0x01
	/*Wait until Register Empty Flag is set*/
	while(GET_BIT(UCSRA,5)==0);
     bca:	eb e2       	ldi	r30, 0x2B	; 43
     bcc:	f0 e0       	ldi	r31, 0x00	; 0
     bce:	80 81       	ld	r24, Z
     bd0:	82 95       	swap	r24
     bd2:	86 95       	lsr	r24
     bd4:	87 70       	andi	r24, 0x07	; 7
     bd6:	88 2f       	mov	r24, r24
     bd8:	90 e0       	ldi	r25, 0x00	; 0
     bda:	81 70       	andi	r24, 0x01	; 1
     bdc:	90 70       	andi	r25, 0x00	; 0
     bde:	00 97       	sbiw	r24, 0x00	; 0
     be0:	a1 f3       	breq	.-24     	; 0xbca <MUSART_VidSendChar+0xc>
	UDR=Copy_u8Data;
     be2:	ec e2       	ldi	r30, 0x2C	; 44
     be4:	f0 e0       	ldi	r31, 0x00	; 0
     be6:	89 81       	ldd	r24, Y+1	; 0x01
     be8:	80 83       	st	Z, r24
}
     bea:	0f 90       	pop	r0
     bec:	cf 91       	pop	r28
     bee:	df 91       	pop	r29
     bf0:	08 95       	ret

00000bf2 <MUSART_u8ReceiveData>:
/*USART Receive Data*/
u8 MUSART_u8ReceiveData(void)
{
     bf2:	df 93       	push	r29
     bf4:	cf 93       	push	r28
     bf6:	cd b7       	in	r28, 0x3d	; 61
     bf8:	de b7       	in	r29, 0x3e	; 62
	/*Wait until Receive Complete Flag is set*/
	//while(GET_BIT(UCSRA,7)==0);
	return UDR;
     bfa:	ec e2       	ldi	r30, 0x2C	; 44
     bfc:	f0 e0       	ldi	r31, 0x00	; 0
     bfe:	80 81       	ld	r24, Z
}
     c00:	cf 91       	pop	r28
     c02:	df 91       	pop	r29
     c04:	08 95       	ret

00000c06 <MUSART_VidSendString>:
void MUSART_VidSendString(u8 *Copy_u8Data)
{
     c06:	df 93       	push	r29
     c08:	cf 93       	push	r28
     c0a:	00 d0       	rcall	.+0      	; 0xc0c <MUSART_VidSendString+0x6>
     c0c:	0f 92       	push	r0
     c0e:	cd b7       	in	r28, 0x3d	; 61
     c10:	de b7       	in	r29, 0x3e	; 62
     c12:	9b 83       	std	Y+3, r25	; 0x03
     c14:	8a 83       	std	Y+2, r24	; 0x02
	u8 LOC_CharCount=0;
     c16:	19 82       	std	Y+1, r1	; 0x01
     c18:	0e c0       	rjmp	.+28     	; 0xc36 <MUSART_VidSendString+0x30>
	while(Copy_u8Data[LOC_CharCount]!=NULL)
	{
		MUSART_VidSendChar(Copy_u8Data[LOC_CharCount]);
     c1a:	89 81       	ldd	r24, Y+1	; 0x01
     c1c:	28 2f       	mov	r18, r24
     c1e:	30 e0       	ldi	r19, 0x00	; 0
     c20:	8a 81       	ldd	r24, Y+2	; 0x02
     c22:	9b 81       	ldd	r25, Y+3	; 0x03
     c24:	fc 01       	movw	r30, r24
     c26:	e2 0f       	add	r30, r18
     c28:	f3 1f       	adc	r31, r19
     c2a:	80 81       	ld	r24, Z
     c2c:	0e 94 df 05 	call	0xbbe	; 0xbbe <MUSART_VidSendChar>
		LOC_CharCount++;
     c30:	89 81       	ldd	r24, Y+1	; 0x01
     c32:	8f 5f       	subi	r24, 0xFF	; 255
     c34:	89 83       	std	Y+1, r24	; 0x01
	return UDR;
}
void MUSART_VidSendString(u8 *Copy_u8Data)
{
	u8 LOC_CharCount=0;
	while(Copy_u8Data[LOC_CharCount]!=NULL)
     c36:	89 81       	ldd	r24, Y+1	; 0x01
     c38:	28 2f       	mov	r18, r24
     c3a:	30 e0       	ldi	r19, 0x00	; 0
     c3c:	8a 81       	ldd	r24, Y+2	; 0x02
     c3e:	9b 81       	ldd	r25, Y+3	; 0x03
     c40:	fc 01       	movw	r30, r24
     c42:	e2 0f       	add	r30, r18
     c44:	f3 1f       	adc	r31, r19
     c46:	80 81       	ld	r24, Z
     c48:	88 23       	and	r24, r24
     c4a:	39 f7       	brne	.-50     	; 0xc1a <MUSART_VidSendString+0x14>
	{
		MUSART_VidSendChar(Copy_u8Data[LOC_CharCount]);
		LOC_CharCount++;
	}
}
     c4c:	0f 90       	pop	r0
     c4e:	0f 90       	pop	r0
     c50:	0f 90       	pop	r0
     c52:	cf 91       	pop	r28
     c54:	df 91       	pop	r29
     c56:	08 95       	ret

00000c58 <MUSART_VidReceiveString>:
void MUSART_VidReceiveString(u8 *Copy_u8Data)
{
     c58:	0f 93       	push	r16
     c5a:	1f 93       	push	r17
     c5c:	df 93       	push	r29
     c5e:	cf 93       	push	r28
     c60:	00 d0       	rcall	.+0      	; 0xc62 <MUSART_VidReceiveString+0xa>
     c62:	0f 92       	push	r0
     c64:	cd b7       	in	r28, 0x3d	; 61
     c66:	de b7       	in	r29, 0x3e	; 62
     c68:	9b 83       	std	Y+3, r25	; 0x03
     c6a:	8a 83       	std	Y+2, r24	; 0x02
	u8 LOC_CharCount=0;
     c6c:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		Copy_u8Data[LOC_CharCount]=MUSART_u8ReceiveData();
     c6e:	89 81       	ldd	r24, Y+1	; 0x01
     c70:	28 2f       	mov	r18, r24
     c72:	30 e0       	ldi	r19, 0x00	; 0
     c74:	8a 81       	ldd	r24, Y+2	; 0x02
     c76:	9b 81       	ldd	r25, Y+3	; 0x03
     c78:	8c 01       	movw	r16, r24
     c7a:	02 0f       	add	r16, r18
     c7c:	13 1f       	adc	r17, r19
     c7e:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <MUSART_u8ReceiveData>
     c82:	f8 01       	movw	r30, r16
     c84:	80 83       	st	Z, r24
		if(Copy_u8Data[LOC_CharCount]=='\t')
     c86:	89 81       	ldd	r24, Y+1	; 0x01
     c88:	28 2f       	mov	r18, r24
     c8a:	30 e0       	ldi	r19, 0x00	; 0
     c8c:	8a 81       	ldd	r24, Y+2	; 0x02
     c8e:	9b 81       	ldd	r25, Y+3	; 0x03
     c90:	fc 01       	movw	r30, r24
     c92:	e2 0f       	add	r30, r18
     c94:	f3 1f       	adc	r31, r19
     c96:	80 81       	ld	r24, Z
     c98:	89 30       	cpi	r24, 0x09	; 9
     c9a:	21 f0       	breq	.+8      	; 0xca4 <MUSART_VidReceiveString+0x4c>
		{
			break;
		}
		LOC_CharCount++;
     c9c:	89 81       	ldd	r24, Y+1	; 0x01
     c9e:	8f 5f       	subi	r24, 0xFF	; 255
     ca0:	89 83       	std	Y+1, r24	; 0x01
     ca2:	e5 cf       	rjmp	.-54     	; 0xc6e <MUSART_VidReceiveString+0x16>
	}

}
     ca4:	0f 90       	pop	r0
     ca6:	0f 90       	pop	r0
     ca8:	0f 90       	pop	r0
     caa:	cf 91       	pop	r28
     cac:	df 91       	pop	r29
     cae:	1f 91       	pop	r17
     cb0:	0f 91       	pop	r16
     cb2:	08 95       	ret

00000cb4 <MUSART_VidUSART_Receive_Interrupt_Enable>:
void MUSART_VidUSART_Receive_Interrupt_Enable(void)
{
     cb4:	df 93       	push	r29
     cb6:	cf 93       	push	r28
     cb8:	cd b7       	in	r28, 0x3d	; 61
     cba:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(UCSRB,7);
     cbc:	aa e2       	ldi	r26, 0x2A	; 42
     cbe:	b0 e0       	ldi	r27, 0x00	; 0
     cc0:	ea e2       	ldi	r30, 0x2A	; 42
     cc2:	f0 e0       	ldi	r31, 0x00	; 0
     cc4:	80 81       	ld	r24, Z
     cc6:	80 68       	ori	r24, 0x80	; 128
     cc8:	8c 93       	st	X, r24
}
     cca:	cf 91       	pop	r28
     ccc:	df 91       	pop	r29
     cce:	08 95       	ret

00000cd0 <MUSART_VidSetCallBack>:
void MUSART_VidSetCallBack(void (*Copy_pFun)(void))
{
     cd0:	df 93       	push	r29
     cd2:	cf 93       	push	r28
     cd4:	00 d0       	rcall	.+0      	; 0xcd6 <MUSART_VidSetCallBack+0x6>
     cd6:	cd b7       	in	r28, 0x3d	; 61
     cd8:	de b7       	in	r29, 0x3e	; 62
     cda:	9a 83       	std	Y+2, r25	; 0x02
     cdc:	89 83       	std	Y+1, r24	; 0x01
	MUSART_CallBack=Copy_pFun;
     cde:	89 81       	ldd	r24, Y+1	; 0x01
     ce0:	9a 81       	ldd	r25, Y+2	; 0x02
     ce2:	90 93 c2 07 	sts	0x07C2, r25
     ce6:	80 93 c1 07 	sts	0x07C1, r24
}
     cea:	0f 90       	pop	r0
     cec:	0f 90       	pop	r0
     cee:	cf 91       	pop	r28
     cf0:	df 91       	pop	r29
     cf2:	08 95       	ret

00000cf4 <__vector_13>:
void __vector_13(void)
{
     cf4:	1f 92       	push	r1
     cf6:	0f 92       	push	r0
     cf8:	0f b6       	in	r0, 0x3f	; 63
     cfa:	0f 92       	push	r0
     cfc:	11 24       	eor	r1, r1
     cfe:	2f 93       	push	r18
     d00:	3f 93       	push	r19
     d02:	4f 93       	push	r20
     d04:	5f 93       	push	r21
     d06:	6f 93       	push	r22
     d08:	7f 93       	push	r23
     d0a:	8f 93       	push	r24
     d0c:	9f 93       	push	r25
     d0e:	af 93       	push	r26
     d10:	bf 93       	push	r27
     d12:	ef 93       	push	r30
     d14:	ff 93       	push	r31
     d16:	df 93       	push	r29
     d18:	cf 93       	push	r28
     d1a:	cd b7       	in	r28, 0x3d	; 61
     d1c:	de b7       	in	r29, 0x3e	; 62
	MUSART_CallBack();
     d1e:	e0 91 c1 07 	lds	r30, 0x07C1
     d22:	f0 91 c2 07 	lds	r31, 0x07C2
     d26:	09 95       	icall
}
     d28:	cf 91       	pop	r28
     d2a:	df 91       	pop	r29
     d2c:	ff 91       	pop	r31
     d2e:	ef 91       	pop	r30
     d30:	bf 91       	pop	r27
     d32:	af 91       	pop	r26
     d34:	9f 91       	pop	r25
     d36:	8f 91       	pop	r24
     d38:	7f 91       	pop	r23
     d3a:	6f 91       	pop	r22
     d3c:	5f 91       	pop	r21
     d3e:	4f 91       	pop	r20
     d40:	3f 91       	pop	r19
     d42:	2f 91       	pop	r18
     d44:	0f 90       	pop	r0
     d46:	0f be       	out	0x3f, r0	; 63
     d48:	0f 90       	pop	r0
     d4a:	1f 90       	pop	r1
     d4c:	18 95       	reti

00000d4e <MGIE_VidEnable>:

#include"MGIE_Private.h"

/*GIE Enable Function*/
void MGIE_VidEnable(void)
{
     d4e:	df 93       	push	r29
     d50:	cf 93       	push	r28
     d52:	cd b7       	in	r28, 0x3d	; 61
     d54:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG,7);
     d56:	af e5       	ldi	r26, 0x5F	; 95
     d58:	b0 e0       	ldi	r27, 0x00	; 0
     d5a:	ef e5       	ldi	r30, 0x5F	; 95
     d5c:	f0 e0       	ldi	r31, 0x00	; 0
     d5e:	80 81       	ld	r24, Z
     d60:	80 68       	ori	r24, 0x80	; 128
     d62:	8c 93       	st	X, r24
}
     d64:	cf 91       	pop	r28
     d66:	df 91       	pop	r29
     d68:	08 95       	ret

00000d6a <MGIE_VidDisable>:
/*GIE Disable Function*/
void MGIE_VidDisable(void)
{
     d6a:	df 93       	push	r29
     d6c:	cf 93       	push	r28
     d6e:	cd b7       	in	r28, 0x3d	; 61
     d70:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG,7);
     d72:	af e5       	ldi	r26, 0x5F	; 95
     d74:	b0 e0       	ldi	r27, 0x00	; 0
     d76:	ef e5       	ldi	r30, 0x5F	; 95
     d78:	f0 e0       	ldi	r31, 0x00	; 0
     d7a:	80 81       	ld	r24, Z
     d7c:	8f 77       	andi	r24, 0x7F	; 127
     d7e:	8c 93       	st	X, r24
}
     d80:	cf 91       	pop	r28
     d82:	df 91       	pop	r29
     d84:	08 95       	ret

00000d86 <MDIO_Error_State_SetPinDirection>:
#include"MDIO_Private.h"
#include"MDIO_Interface.h"

/*Set Pin Direction Function */
Error_State MDIO_Error_State_SetPinDirection(u8 Copy_u8PinNumber,u8  Copy_u8PortNumber,u8 Copy_u8PinDirection)
{
     d86:	df 93       	push	r29
     d88:	cf 93       	push	r28
     d8a:	00 d0       	rcall	.+0      	; 0xd8c <MDIO_Error_State_SetPinDirection+0x6>
     d8c:	00 d0       	rcall	.+0      	; 0xd8e <MDIO_Error_State_SetPinDirection+0x8>
     d8e:	00 d0       	rcall	.+0      	; 0xd90 <MDIO_Error_State_SetPinDirection+0xa>
     d90:	cd b7       	in	r28, 0x3d	; 61
     d92:	de b7       	in	r29, 0x3e	; 62
     d94:	8a 83       	std	Y+2, r24	; 0x02
     d96:	6b 83       	std	Y+3, r22	; 0x03
     d98:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
     d9a:	81 e0       	ldi	r24, 0x01	; 1
     d9c:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))
     d9e:	8a 81       	ldd	r24, Y+2	; 0x02
     da0:	88 30       	cpi	r24, 0x08	; 8
     da2:	08 f0       	brcs	.+2      	; 0xda6 <MDIO_Error_State_SetPinDirection+0x20>
     da4:	e8 c0       	rjmp	.+464    	; 0xf76 <MDIO_Error_State_SetPinDirection+0x1f0>
	{
		switch(Copy_u8PortNumber)
     da6:	8b 81       	ldd	r24, Y+3	; 0x03
     da8:	28 2f       	mov	r18, r24
     daa:	30 e0       	ldi	r19, 0x00	; 0
     dac:	3e 83       	std	Y+6, r19	; 0x06
     dae:	2d 83       	std	Y+5, r18	; 0x05
     db0:	8d 81       	ldd	r24, Y+5	; 0x05
     db2:	9e 81       	ldd	r25, Y+6	; 0x06
     db4:	81 30       	cpi	r24, 0x01	; 1
     db6:	91 05       	cpc	r25, r1
     db8:	09 f4       	brne	.+2      	; 0xdbc <MDIO_Error_State_SetPinDirection+0x36>
     dba:	48 c0       	rjmp	.+144    	; 0xe4c <MDIO_Error_State_SetPinDirection+0xc6>
     dbc:	2d 81       	ldd	r18, Y+5	; 0x05
     dbe:	3e 81       	ldd	r19, Y+6	; 0x06
     dc0:	22 30       	cpi	r18, 0x02	; 2
     dc2:	31 05       	cpc	r19, r1
     dc4:	2c f4       	brge	.+10     	; 0xdd0 <MDIO_Error_State_SetPinDirection+0x4a>
     dc6:	8d 81       	ldd	r24, Y+5	; 0x05
     dc8:	9e 81       	ldd	r25, Y+6	; 0x06
     dca:	00 97       	sbiw	r24, 0x00	; 0
     dcc:	71 f0       	breq	.+28     	; 0xdea <MDIO_Error_State_SetPinDirection+0x64>
     dce:	d1 c0       	rjmp	.+418    	; 0xf72 <MDIO_Error_State_SetPinDirection+0x1ec>
     dd0:	2d 81       	ldd	r18, Y+5	; 0x05
     dd2:	3e 81       	ldd	r19, Y+6	; 0x06
     dd4:	22 30       	cpi	r18, 0x02	; 2
     dd6:	31 05       	cpc	r19, r1
     dd8:	09 f4       	brne	.+2      	; 0xddc <MDIO_Error_State_SetPinDirection+0x56>
     dda:	69 c0       	rjmp	.+210    	; 0xeae <MDIO_Error_State_SetPinDirection+0x128>
     ddc:	8d 81       	ldd	r24, Y+5	; 0x05
     dde:	9e 81       	ldd	r25, Y+6	; 0x06
     de0:	83 30       	cpi	r24, 0x03	; 3
     de2:	91 05       	cpc	r25, r1
     de4:	09 f4       	brne	.+2      	; 0xde8 <MDIO_Error_State_SetPinDirection+0x62>
     de6:	94 c0       	rjmp	.+296    	; 0xf10 <MDIO_Error_State_SetPinDirection+0x18a>
     de8:	c4 c0       	rjmp	.+392    	; 0xf72 <MDIO_Error_State_SetPinDirection+0x1ec>
		{
		case MDIO_PORTA:
			if(Copy_u8PinDirection==PIN_OUTPUT)
     dea:	8c 81       	ldd	r24, Y+4	; 0x04
     dec:	81 30       	cpi	r24, 0x01	; 1
     dee:	a1 f4       	brne	.+40     	; 0xe18 <MDIO_Error_State_SetPinDirection+0x92>
			{
				SET_BIT(DDRA,Copy_u8PinNumber);
     df0:	aa e3       	ldi	r26, 0x3A	; 58
     df2:	b0 e0       	ldi	r27, 0x00	; 0
     df4:	ea e3       	ldi	r30, 0x3A	; 58
     df6:	f0 e0       	ldi	r31, 0x00	; 0
     df8:	80 81       	ld	r24, Z
     dfa:	48 2f       	mov	r20, r24
     dfc:	8a 81       	ldd	r24, Y+2	; 0x02
     dfe:	28 2f       	mov	r18, r24
     e00:	30 e0       	ldi	r19, 0x00	; 0
     e02:	81 e0       	ldi	r24, 0x01	; 1
     e04:	90 e0       	ldi	r25, 0x00	; 0
     e06:	02 2e       	mov	r0, r18
     e08:	02 c0       	rjmp	.+4      	; 0xe0e <MDIO_Error_State_SetPinDirection+0x88>
     e0a:	88 0f       	add	r24, r24
     e0c:	99 1f       	adc	r25, r25
     e0e:	0a 94       	dec	r0
     e10:	e2 f7       	brpl	.-8      	; 0xe0a <MDIO_Error_State_SetPinDirection+0x84>
     e12:	84 2b       	or	r24, r20
     e14:	8c 93       	st	X, r24
     e16:	b0 c0       	rjmp	.+352    	; 0xf78 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
     e18:	8c 81       	ldd	r24, Y+4	; 0x04
     e1a:	88 23       	and	r24, r24
     e1c:	a9 f4       	brne	.+42     	; 0xe48 <MDIO_Error_State_SetPinDirection+0xc2>
			{
				CLR_BIT(DDRA,Copy_u8PinNumber);
     e1e:	aa e3       	ldi	r26, 0x3A	; 58
     e20:	b0 e0       	ldi	r27, 0x00	; 0
     e22:	ea e3       	ldi	r30, 0x3A	; 58
     e24:	f0 e0       	ldi	r31, 0x00	; 0
     e26:	80 81       	ld	r24, Z
     e28:	48 2f       	mov	r20, r24
     e2a:	8a 81       	ldd	r24, Y+2	; 0x02
     e2c:	28 2f       	mov	r18, r24
     e2e:	30 e0       	ldi	r19, 0x00	; 0
     e30:	81 e0       	ldi	r24, 0x01	; 1
     e32:	90 e0       	ldi	r25, 0x00	; 0
     e34:	02 2e       	mov	r0, r18
     e36:	02 c0       	rjmp	.+4      	; 0xe3c <MDIO_Error_State_SetPinDirection+0xb6>
     e38:	88 0f       	add	r24, r24
     e3a:	99 1f       	adc	r25, r25
     e3c:	0a 94       	dec	r0
     e3e:	e2 f7       	brpl	.-8      	; 0xe38 <MDIO_Error_State_SetPinDirection+0xb2>
     e40:	80 95       	com	r24
     e42:	84 23       	and	r24, r20
     e44:	8c 93       	st	X, r24
     e46:	98 c0       	rjmp	.+304    	; 0xf78 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
     e48:	19 82       	std	Y+1, r1	; 0x01
     e4a:	96 c0       	rjmp	.+300    	; 0xf78 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		case MDIO_PORTB:
			if(Copy_u8PinDirection==PIN_OUTPUT)
     e4c:	8c 81       	ldd	r24, Y+4	; 0x04
     e4e:	81 30       	cpi	r24, 0x01	; 1
     e50:	a1 f4       	brne	.+40     	; 0xe7a <MDIO_Error_State_SetPinDirection+0xf4>
			{
				SET_BIT(DDRB,Copy_u8PinNumber);
     e52:	a7 e3       	ldi	r26, 0x37	; 55
     e54:	b0 e0       	ldi	r27, 0x00	; 0
     e56:	e7 e3       	ldi	r30, 0x37	; 55
     e58:	f0 e0       	ldi	r31, 0x00	; 0
     e5a:	80 81       	ld	r24, Z
     e5c:	48 2f       	mov	r20, r24
     e5e:	8a 81       	ldd	r24, Y+2	; 0x02
     e60:	28 2f       	mov	r18, r24
     e62:	30 e0       	ldi	r19, 0x00	; 0
     e64:	81 e0       	ldi	r24, 0x01	; 1
     e66:	90 e0       	ldi	r25, 0x00	; 0
     e68:	02 2e       	mov	r0, r18
     e6a:	02 c0       	rjmp	.+4      	; 0xe70 <MDIO_Error_State_SetPinDirection+0xea>
     e6c:	88 0f       	add	r24, r24
     e6e:	99 1f       	adc	r25, r25
     e70:	0a 94       	dec	r0
     e72:	e2 f7       	brpl	.-8      	; 0xe6c <MDIO_Error_State_SetPinDirection+0xe6>
     e74:	84 2b       	or	r24, r20
     e76:	8c 93       	st	X, r24
     e78:	7f c0       	rjmp	.+254    	; 0xf78 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
     e7a:	8c 81       	ldd	r24, Y+4	; 0x04
     e7c:	88 23       	and	r24, r24
     e7e:	a9 f4       	brne	.+42     	; 0xeaa <MDIO_Error_State_SetPinDirection+0x124>
			{
				CLR_BIT(DDRB,Copy_u8PinNumber);
     e80:	a7 e3       	ldi	r26, 0x37	; 55
     e82:	b0 e0       	ldi	r27, 0x00	; 0
     e84:	e7 e3       	ldi	r30, 0x37	; 55
     e86:	f0 e0       	ldi	r31, 0x00	; 0
     e88:	80 81       	ld	r24, Z
     e8a:	48 2f       	mov	r20, r24
     e8c:	8a 81       	ldd	r24, Y+2	; 0x02
     e8e:	28 2f       	mov	r18, r24
     e90:	30 e0       	ldi	r19, 0x00	; 0
     e92:	81 e0       	ldi	r24, 0x01	; 1
     e94:	90 e0       	ldi	r25, 0x00	; 0
     e96:	02 2e       	mov	r0, r18
     e98:	02 c0       	rjmp	.+4      	; 0xe9e <MDIO_Error_State_SetPinDirection+0x118>
     e9a:	88 0f       	add	r24, r24
     e9c:	99 1f       	adc	r25, r25
     e9e:	0a 94       	dec	r0
     ea0:	e2 f7       	brpl	.-8      	; 0xe9a <MDIO_Error_State_SetPinDirection+0x114>
     ea2:	80 95       	com	r24
     ea4:	84 23       	and	r24, r20
     ea6:	8c 93       	st	X, r24
     ea8:	67 c0       	rjmp	.+206    	; 0xf78 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
     eaa:	19 82       	std	Y+1, r1	; 0x01
     eac:	65 c0       	rjmp	.+202    	; 0xf78 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		case MDIO_PORTC:
			if(Copy_u8PinDirection==PIN_OUTPUT)
     eae:	8c 81       	ldd	r24, Y+4	; 0x04
     eb0:	81 30       	cpi	r24, 0x01	; 1
     eb2:	a1 f4       	brne	.+40     	; 0xedc <MDIO_Error_State_SetPinDirection+0x156>
			{
				SET_BIT(DDRC,Copy_u8PinNumber);
     eb4:	a4 e3       	ldi	r26, 0x34	; 52
     eb6:	b0 e0       	ldi	r27, 0x00	; 0
     eb8:	e4 e3       	ldi	r30, 0x34	; 52
     eba:	f0 e0       	ldi	r31, 0x00	; 0
     ebc:	80 81       	ld	r24, Z
     ebe:	48 2f       	mov	r20, r24
     ec0:	8a 81       	ldd	r24, Y+2	; 0x02
     ec2:	28 2f       	mov	r18, r24
     ec4:	30 e0       	ldi	r19, 0x00	; 0
     ec6:	81 e0       	ldi	r24, 0x01	; 1
     ec8:	90 e0       	ldi	r25, 0x00	; 0
     eca:	02 2e       	mov	r0, r18
     ecc:	02 c0       	rjmp	.+4      	; 0xed2 <MDIO_Error_State_SetPinDirection+0x14c>
     ece:	88 0f       	add	r24, r24
     ed0:	99 1f       	adc	r25, r25
     ed2:	0a 94       	dec	r0
     ed4:	e2 f7       	brpl	.-8      	; 0xece <MDIO_Error_State_SetPinDirection+0x148>
     ed6:	84 2b       	or	r24, r20
     ed8:	8c 93       	st	X, r24
     eda:	4e c0       	rjmp	.+156    	; 0xf78 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
     edc:	8c 81       	ldd	r24, Y+4	; 0x04
     ede:	88 23       	and	r24, r24
     ee0:	a9 f4       	brne	.+42     	; 0xf0c <MDIO_Error_State_SetPinDirection+0x186>
			{
				CLR_BIT(DDRC,Copy_u8PinNumber);
     ee2:	a4 e3       	ldi	r26, 0x34	; 52
     ee4:	b0 e0       	ldi	r27, 0x00	; 0
     ee6:	e4 e3       	ldi	r30, 0x34	; 52
     ee8:	f0 e0       	ldi	r31, 0x00	; 0
     eea:	80 81       	ld	r24, Z
     eec:	48 2f       	mov	r20, r24
     eee:	8a 81       	ldd	r24, Y+2	; 0x02
     ef0:	28 2f       	mov	r18, r24
     ef2:	30 e0       	ldi	r19, 0x00	; 0
     ef4:	81 e0       	ldi	r24, 0x01	; 1
     ef6:	90 e0       	ldi	r25, 0x00	; 0
     ef8:	02 2e       	mov	r0, r18
     efa:	02 c0       	rjmp	.+4      	; 0xf00 <MDIO_Error_State_SetPinDirection+0x17a>
     efc:	88 0f       	add	r24, r24
     efe:	99 1f       	adc	r25, r25
     f00:	0a 94       	dec	r0
     f02:	e2 f7       	brpl	.-8      	; 0xefc <MDIO_Error_State_SetPinDirection+0x176>
     f04:	80 95       	com	r24
     f06:	84 23       	and	r24, r20
     f08:	8c 93       	st	X, r24
     f0a:	36 c0       	rjmp	.+108    	; 0xf78 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
     f0c:	19 82       	std	Y+1, r1	; 0x01
     f0e:	34 c0       	rjmp	.+104    	; 0xf78 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;	
		case MDIO_PORTD:
			if(Copy_u8PinDirection==PIN_OUTPUT)
     f10:	8c 81       	ldd	r24, Y+4	; 0x04
     f12:	81 30       	cpi	r24, 0x01	; 1
     f14:	a1 f4       	brne	.+40     	; 0xf3e <MDIO_Error_State_SetPinDirection+0x1b8>
			{
				SET_BIT(DDRD,Copy_u8PinNumber);
     f16:	a1 e3       	ldi	r26, 0x31	; 49
     f18:	b0 e0       	ldi	r27, 0x00	; 0
     f1a:	e1 e3       	ldi	r30, 0x31	; 49
     f1c:	f0 e0       	ldi	r31, 0x00	; 0
     f1e:	80 81       	ld	r24, Z
     f20:	48 2f       	mov	r20, r24
     f22:	8a 81       	ldd	r24, Y+2	; 0x02
     f24:	28 2f       	mov	r18, r24
     f26:	30 e0       	ldi	r19, 0x00	; 0
     f28:	81 e0       	ldi	r24, 0x01	; 1
     f2a:	90 e0       	ldi	r25, 0x00	; 0
     f2c:	02 2e       	mov	r0, r18
     f2e:	02 c0       	rjmp	.+4      	; 0xf34 <MDIO_Error_State_SetPinDirection+0x1ae>
     f30:	88 0f       	add	r24, r24
     f32:	99 1f       	adc	r25, r25
     f34:	0a 94       	dec	r0
     f36:	e2 f7       	brpl	.-8      	; 0xf30 <MDIO_Error_State_SetPinDirection+0x1aa>
     f38:	84 2b       	or	r24, r20
     f3a:	8c 93       	st	X, r24
     f3c:	1d c0       	rjmp	.+58     	; 0xf78 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
     f3e:	8c 81       	ldd	r24, Y+4	; 0x04
     f40:	88 23       	and	r24, r24
     f42:	a9 f4       	brne	.+42     	; 0xf6e <MDIO_Error_State_SetPinDirection+0x1e8>
			{
				CLR_BIT(DDRD,Copy_u8PinNumber);
     f44:	a1 e3       	ldi	r26, 0x31	; 49
     f46:	b0 e0       	ldi	r27, 0x00	; 0
     f48:	e1 e3       	ldi	r30, 0x31	; 49
     f4a:	f0 e0       	ldi	r31, 0x00	; 0
     f4c:	80 81       	ld	r24, Z
     f4e:	48 2f       	mov	r20, r24
     f50:	8a 81       	ldd	r24, Y+2	; 0x02
     f52:	28 2f       	mov	r18, r24
     f54:	30 e0       	ldi	r19, 0x00	; 0
     f56:	81 e0       	ldi	r24, 0x01	; 1
     f58:	90 e0       	ldi	r25, 0x00	; 0
     f5a:	02 2e       	mov	r0, r18
     f5c:	02 c0       	rjmp	.+4      	; 0xf62 <MDIO_Error_State_SetPinDirection+0x1dc>
     f5e:	88 0f       	add	r24, r24
     f60:	99 1f       	adc	r25, r25
     f62:	0a 94       	dec	r0
     f64:	e2 f7       	brpl	.-8      	; 0xf5e <MDIO_Error_State_SetPinDirection+0x1d8>
     f66:	80 95       	com	r24
     f68:	84 23       	and	r24, r20
     f6a:	8c 93       	st	X, r24
     f6c:	05 c0       	rjmp	.+10     	; 0xf78 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
     f6e:	19 82       	std	Y+1, r1	; 0x01
     f70:	03 c0       	rjmp	.+6      	; 0xf78 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
     f72:	19 82       	std	Y+1, r1	; 0x01
     f74:	01 c0       	rjmp	.+2      	; 0xf78 <MDIO_Error_State_SetPinDirection+0x1f2>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
     f76:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
     f78:	89 81       	ldd	r24, Y+1	; 0x01
}
     f7a:	26 96       	adiw	r28, 0x06	; 6
     f7c:	0f b6       	in	r0, 0x3f	; 63
     f7e:	f8 94       	cli
     f80:	de bf       	out	0x3e, r29	; 62
     f82:	0f be       	out	0x3f, r0	; 63
     f84:	cd bf       	out	0x3d, r28	; 61
     f86:	cf 91       	pop	r28
     f88:	df 91       	pop	r29
     f8a:	08 95       	ret

00000f8c <MDIO_Error_State_SetPortDirection>:
/*Set Port Direction Function */
Error_State MDIO_Error_State_SetPortDirection(u8 Copy_u8PortNumber,u8 Copy_u8PortDirection)
{
     f8c:	df 93       	push	r29
     f8e:	cf 93       	push	r28
     f90:	00 d0       	rcall	.+0      	; 0xf92 <MDIO_Error_State_SetPortDirection+0x6>
     f92:	00 d0       	rcall	.+0      	; 0xf94 <MDIO_Error_State_SetPortDirection+0x8>
     f94:	0f 92       	push	r0
     f96:	cd b7       	in	r28, 0x3d	; 61
     f98:	de b7       	in	r29, 0x3e	; 62
     f9a:	8a 83       	std	Y+2, r24	; 0x02
     f9c:	6b 83       	std	Y+3, r22	; 0x03
	Error_State LOC_Error_State_ReturnState=OK;
     f9e:	81 e0       	ldi	r24, 0x01	; 1
     fa0:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortDirection==PORT_OUTPUT)||(Copy_u8PortDirection==PORT_INPUT))
     fa2:	8b 81       	ldd	r24, Y+3	; 0x03
     fa4:	8f 3f       	cpi	r24, 0xFF	; 255
     fa6:	19 f0       	breq	.+6      	; 0xfae <MDIO_Error_State_SetPortDirection+0x22>
     fa8:	8b 81       	ldd	r24, Y+3	; 0x03
     faa:	88 23       	and	r24, r24
     fac:	a9 f5       	brne	.+106    	; 0x1018 <MDIO_Error_State_SetPortDirection+0x8c>
	{
		switch(Copy_u8PortNumber)
     fae:	8a 81       	ldd	r24, Y+2	; 0x02
     fb0:	28 2f       	mov	r18, r24
     fb2:	30 e0       	ldi	r19, 0x00	; 0
     fb4:	3d 83       	std	Y+5, r19	; 0x05
     fb6:	2c 83       	std	Y+4, r18	; 0x04
     fb8:	8c 81       	ldd	r24, Y+4	; 0x04
     fba:	9d 81       	ldd	r25, Y+5	; 0x05
     fbc:	81 30       	cpi	r24, 0x01	; 1
     fbe:	91 05       	cpc	r25, r1
     fc0:	d1 f0       	breq	.+52     	; 0xff6 <MDIO_Error_State_SetPortDirection+0x6a>
     fc2:	2c 81       	ldd	r18, Y+4	; 0x04
     fc4:	3d 81       	ldd	r19, Y+5	; 0x05
     fc6:	22 30       	cpi	r18, 0x02	; 2
     fc8:	31 05       	cpc	r19, r1
     fca:	2c f4       	brge	.+10     	; 0xfd6 <MDIO_Error_State_SetPortDirection+0x4a>
     fcc:	8c 81       	ldd	r24, Y+4	; 0x04
     fce:	9d 81       	ldd	r25, Y+5	; 0x05
     fd0:	00 97       	sbiw	r24, 0x00	; 0
     fd2:	61 f0       	breq	.+24     	; 0xfec <MDIO_Error_State_SetPortDirection+0x60>
     fd4:	1f c0       	rjmp	.+62     	; 0x1014 <MDIO_Error_State_SetPortDirection+0x88>
     fd6:	2c 81       	ldd	r18, Y+4	; 0x04
     fd8:	3d 81       	ldd	r19, Y+5	; 0x05
     fda:	22 30       	cpi	r18, 0x02	; 2
     fdc:	31 05       	cpc	r19, r1
     fde:	81 f0       	breq	.+32     	; 0x1000 <MDIO_Error_State_SetPortDirection+0x74>
     fe0:	8c 81       	ldd	r24, Y+4	; 0x04
     fe2:	9d 81       	ldd	r25, Y+5	; 0x05
     fe4:	83 30       	cpi	r24, 0x03	; 3
     fe6:	91 05       	cpc	r25, r1
     fe8:	81 f0       	breq	.+32     	; 0x100a <MDIO_Error_State_SetPortDirection+0x7e>
     fea:	14 c0       	rjmp	.+40     	; 0x1014 <MDIO_Error_State_SetPortDirection+0x88>
		{
		case MDIO_PORTA:
			DDRA=Copy_u8PortDirection;
     fec:	ea e3       	ldi	r30, 0x3A	; 58
     fee:	f0 e0       	ldi	r31, 0x00	; 0
     ff0:	8b 81       	ldd	r24, Y+3	; 0x03
     ff2:	80 83       	st	Z, r24
     ff4:	12 c0       	rjmp	.+36     	; 0x101a <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTB:
			DDRB=Copy_u8PortDirection;
     ff6:	e7 e3       	ldi	r30, 0x37	; 55
     ff8:	f0 e0       	ldi	r31, 0x00	; 0
     ffa:	8b 81       	ldd	r24, Y+3	; 0x03
     ffc:	80 83       	st	Z, r24
     ffe:	0d c0       	rjmp	.+26     	; 0x101a <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTC:
			DDRC=Copy_u8PortDirection;
    1000:	e4 e3       	ldi	r30, 0x34	; 52
    1002:	f0 e0       	ldi	r31, 0x00	; 0
    1004:	8b 81       	ldd	r24, Y+3	; 0x03
    1006:	80 83       	st	Z, r24
    1008:	08 c0       	rjmp	.+16     	; 0x101a <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTD:
			DDRD=Copy_u8PortDirection;
    100a:	e1 e3       	ldi	r30, 0x31	; 49
    100c:	f0 e0       	ldi	r31, 0x00	; 0
    100e:	8b 81       	ldd	r24, Y+3	; 0x03
    1010:	80 83       	st	Z, r24
    1012:	03 c0       	rjmp	.+6      	; 0x101a <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    1014:	19 82       	std	Y+1, r1	; 0x01
    1016:	01 c0       	rjmp	.+2      	; 0x101a <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    1018:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_Error_State_ReturnState;
    101a:	89 81       	ldd	r24, Y+1	; 0x01
}
    101c:	0f 90       	pop	r0
    101e:	0f 90       	pop	r0
    1020:	0f 90       	pop	r0
    1022:	0f 90       	pop	r0
    1024:	0f 90       	pop	r0
    1026:	cf 91       	pop	r28
    1028:	df 91       	pop	r29
    102a:	08 95       	ret

0000102c <MDIO_Error_State_SetPinValue>:

/*Set Pin Value Function */
Error_State MDIO_Error_State_SetPinValue(u8 Copy_u8PinNumber,u8 Copy_u8PortNumber,u8 Copy_u8PinValue)
{
    102c:	df 93       	push	r29
    102e:	cf 93       	push	r28
    1030:	00 d0       	rcall	.+0      	; 0x1032 <MDIO_Error_State_SetPinValue+0x6>
    1032:	00 d0       	rcall	.+0      	; 0x1034 <MDIO_Error_State_SetPinValue+0x8>
    1034:	00 d0       	rcall	.+0      	; 0x1036 <MDIO_Error_State_SetPinValue+0xa>
    1036:	cd b7       	in	r28, 0x3d	; 61
    1038:	de b7       	in	r29, 0x3e	; 62
    103a:	8a 83       	std	Y+2, r24	; 0x02
    103c:	6b 83       	std	Y+3, r22	; 0x03
    103e:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    1040:	81 e0       	ldi	r24, 0x01	; 1
    1042:	89 83       	std	Y+1, r24	; 0x01

	if((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))
    1044:	8a 81       	ldd	r24, Y+2	; 0x02
    1046:	88 30       	cpi	r24, 0x08	; 8
    1048:	08 f0       	brcs	.+2      	; 0x104c <MDIO_Error_State_SetPinValue+0x20>
    104a:	e8 c0       	rjmp	.+464    	; 0x121c <MDIO_Error_State_SetPinValue+0x1f0>
	{
		switch(Copy_u8PortNumber)
    104c:	8b 81       	ldd	r24, Y+3	; 0x03
    104e:	28 2f       	mov	r18, r24
    1050:	30 e0       	ldi	r19, 0x00	; 0
    1052:	3e 83       	std	Y+6, r19	; 0x06
    1054:	2d 83       	std	Y+5, r18	; 0x05
    1056:	8d 81       	ldd	r24, Y+5	; 0x05
    1058:	9e 81       	ldd	r25, Y+6	; 0x06
    105a:	81 30       	cpi	r24, 0x01	; 1
    105c:	91 05       	cpc	r25, r1
    105e:	09 f4       	brne	.+2      	; 0x1062 <MDIO_Error_State_SetPinValue+0x36>
    1060:	48 c0       	rjmp	.+144    	; 0x10f2 <MDIO_Error_State_SetPinValue+0xc6>
    1062:	2d 81       	ldd	r18, Y+5	; 0x05
    1064:	3e 81       	ldd	r19, Y+6	; 0x06
    1066:	22 30       	cpi	r18, 0x02	; 2
    1068:	31 05       	cpc	r19, r1
    106a:	2c f4       	brge	.+10     	; 0x1076 <MDIO_Error_State_SetPinValue+0x4a>
    106c:	8d 81       	ldd	r24, Y+5	; 0x05
    106e:	9e 81       	ldd	r25, Y+6	; 0x06
    1070:	00 97       	sbiw	r24, 0x00	; 0
    1072:	71 f0       	breq	.+28     	; 0x1090 <MDIO_Error_State_SetPinValue+0x64>
    1074:	d1 c0       	rjmp	.+418    	; 0x1218 <MDIO_Error_State_SetPinValue+0x1ec>
    1076:	2d 81       	ldd	r18, Y+5	; 0x05
    1078:	3e 81       	ldd	r19, Y+6	; 0x06
    107a:	22 30       	cpi	r18, 0x02	; 2
    107c:	31 05       	cpc	r19, r1
    107e:	09 f4       	brne	.+2      	; 0x1082 <MDIO_Error_State_SetPinValue+0x56>
    1080:	69 c0       	rjmp	.+210    	; 0x1154 <MDIO_Error_State_SetPinValue+0x128>
    1082:	8d 81       	ldd	r24, Y+5	; 0x05
    1084:	9e 81       	ldd	r25, Y+6	; 0x06
    1086:	83 30       	cpi	r24, 0x03	; 3
    1088:	91 05       	cpc	r25, r1
    108a:	09 f4       	brne	.+2      	; 0x108e <MDIO_Error_State_SetPinValue+0x62>
    108c:	94 c0       	rjmp	.+296    	; 0x11b6 <MDIO_Error_State_SetPinValue+0x18a>
    108e:	c4 c0       	rjmp	.+392    	; 0x1218 <MDIO_Error_State_SetPinValue+0x1ec>
		{
		case MDIO_PORTA:
			if(Copy_u8PinValue==PIN_HIGH)
    1090:	8c 81       	ldd	r24, Y+4	; 0x04
    1092:	81 30       	cpi	r24, 0x01	; 1
    1094:	a1 f4       	brne	.+40     	; 0x10be <MDIO_Error_State_SetPinValue+0x92>
			{
				SET_BIT(PORTA,Copy_u8PinNumber);
    1096:	ab e3       	ldi	r26, 0x3B	; 59
    1098:	b0 e0       	ldi	r27, 0x00	; 0
    109a:	eb e3       	ldi	r30, 0x3B	; 59
    109c:	f0 e0       	ldi	r31, 0x00	; 0
    109e:	80 81       	ld	r24, Z
    10a0:	48 2f       	mov	r20, r24
    10a2:	8a 81       	ldd	r24, Y+2	; 0x02
    10a4:	28 2f       	mov	r18, r24
    10a6:	30 e0       	ldi	r19, 0x00	; 0
    10a8:	81 e0       	ldi	r24, 0x01	; 1
    10aa:	90 e0       	ldi	r25, 0x00	; 0
    10ac:	02 2e       	mov	r0, r18
    10ae:	02 c0       	rjmp	.+4      	; 0x10b4 <MDIO_Error_State_SetPinValue+0x88>
    10b0:	88 0f       	add	r24, r24
    10b2:	99 1f       	adc	r25, r25
    10b4:	0a 94       	dec	r0
    10b6:	e2 f7       	brpl	.-8      	; 0x10b0 <MDIO_Error_State_SetPinValue+0x84>
    10b8:	84 2b       	or	r24, r20
    10ba:	8c 93       	st	X, r24
    10bc:	b0 c0       	rjmp	.+352    	; 0x121e <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    10be:	8c 81       	ldd	r24, Y+4	; 0x04
    10c0:	88 23       	and	r24, r24
    10c2:	a9 f4       	brne	.+42     	; 0x10ee <MDIO_Error_State_SetPinValue+0xc2>
			{
				CLR_BIT(PORTA,Copy_u8PinNumber);
    10c4:	ab e3       	ldi	r26, 0x3B	; 59
    10c6:	b0 e0       	ldi	r27, 0x00	; 0
    10c8:	eb e3       	ldi	r30, 0x3B	; 59
    10ca:	f0 e0       	ldi	r31, 0x00	; 0
    10cc:	80 81       	ld	r24, Z
    10ce:	48 2f       	mov	r20, r24
    10d0:	8a 81       	ldd	r24, Y+2	; 0x02
    10d2:	28 2f       	mov	r18, r24
    10d4:	30 e0       	ldi	r19, 0x00	; 0
    10d6:	81 e0       	ldi	r24, 0x01	; 1
    10d8:	90 e0       	ldi	r25, 0x00	; 0
    10da:	02 2e       	mov	r0, r18
    10dc:	02 c0       	rjmp	.+4      	; 0x10e2 <MDIO_Error_State_SetPinValue+0xb6>
    10de:	88 0f       	add	r24, r24
    10e0:	99 1f       	adc	r25, r25
    10e2:	0a 94       	dec	r0
    10e4:	e2 f7       	brpl	.-8      	; 0x10de <MDIO_Error_State_SetPinValue+0xb2>
    10e6:	80 95       	com	r24
    10e8:	84 23       	and	r24, r20
    10ea:	8c 93       	st	X, r24
    10ec:	98 c0       	rjmp	.+304    	; 0x121e <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    10ee:	19 82       	std	Y+1, r1	; 0x01
    10f0:	96 c0       	rjmp	.+300    	; 0x121e <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		case MDIO_PORTB:
			if(Copy_u8PinValue==PIN_HIGH)
    10f2:	8c 81       	ldd	r24, Y+4	; 0x04
    10f4:	81 30       	cpi	r24, 0x01	; 1
    10f6:	a1 f4       	brne	.+40     	; 0x1120 <MDIO_Error_State_SetPinValue+0xf4>
			{
				SET_BIT(PORTB,Copy_u8PinNumber);
    10f8:	a8 e3       	ldi	r26, 0x38	; 56
    10fa:	b0 e0       	ldi	r27, 0x00	; 0
    10fc:	e8 e3       	ldi	r30, 0x38	; 56
    10fe:	f0 e0       	ldi	r31, 0x00	; 0
    1100:	80 81       	ld	r24, Z
    1102:	48 2f       	mov	r20, r24
    1104:	8a 81       	ldd	r24, Y+2	; 0x02
    1106:	28 2f       	mov	r18, r24
    1108:	30 e0       	ldi	r19, 0x00	; 0
    110a:	81 e0       	ldi	r24, 0x01	; 1
    110c:	90 e0       	ldi	r25, 0x00	; 0
    110e:	02 2e       	mov	r0, r18
    1110:	02 c0       	rjmp	.+4      	; 0x1116 <MDIO_Error_State_SetPinValue+0xea>
    1112:	88 0f       	add	r24, r24
    1114:	99 1f       	adc	r25, r25
    1116:	0a 94       	dec	r0
    1118:	e2 f7       	brpl	.-8      	; 0x1112 <MDIO_Error_State_SetPinValue+0xe6>
    111a:	84 2b       	or	r24, r20
    111c:	8c 93       	st	X, r24
    111e:	7f c0       	rjmp	.+254    	; 0x121e <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    1120:	8c 81       	ldd	r24, Y+4	; 0x04
    1122:	88 23       	and	r24, r24
    1124:	a9 f4       	brne	.+42     	; 0x1150 <MDIO_Error_State_SetPinValue+0x124>
			{
				CLR_BIT(PORTB,Copy_u8PinNumber);
    1126:	a8 e3       	ldi	r26, 0x38	; 56
    1128:	b0 e0       	ldi	r27, 0x00	; 0
    112a:	e8 e3       	ldi	r30, 0x38	; 56
    112c:	f0 e0       	ldi	r31, 0x00	; 0
    112e:	80 81       	ld	r24, Z
    1130:	48 2f       	mov	r20, r24
    1132:	8a 81       	ldd	r24, Y+2	; 0x02
    1134:	28 2f       	mov	r18, r24
    1136:	30 e0       	ldi	r19, 0x00	; 0
    1138:	81 e0       	ldi	r24, 0x01	; 1
    113a:	90 e0       	ldi	r25, 0x00	; 0
    113c:	02 2e       	mov	r0, r18
    113e:	02 c0       	rjmp	.+4      	; 0x1144 <MDIO_Error_State_SetPinValue+0x118>
    1140:	88 0f       	add	r24, r24
    1142:	99 1f       	adc	r25, r25
    1144:	0a 94       	dec	r0
    1146:	e2 f7       	brpl	.-8      	; 0x1140 <MDIO_Error_State_SetPinValue+0x114>
    1148:	80 95       	com	r24
    114a:	84 23       	and	r24, r20
    114c:	8c 93       	st	X, r24
    114e:	67 c0       	rjmp	.+206    	; 0x121e <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    1150:	19 82       	std	Y+1, r1	; 0x01
    1152:	65 c0       	rjmp	.+202    	; 0x121e <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		case MDIO_PORTC:
			if(Copy_u8PinValue==PIN_HIGH)
    1154:	8c 81       	ldd	r24, Y+4	; 0x04
    1156:	81 30       	cpi	r24, 0x01	; 1
    1158:	a1 f4       	brne	.+40     	; 0x1182 <MDIO_Error_State_SetPinValue+0x156>
			{
				SET_BIT(PORTC,Copy_u8PinNumber);
    115a:	a5 e3       	ldi	r26, 0x35	; 53
    115c:	b0 e0       	ldi	r27, 0x00	; 0
    115e:	e5 e3       	ldi	r30, 0x35	; 53
    1160:	f0 e0       	ldi	r31, 0x00	; 0
    1162:	80 81       	ld	r24, Z
    1164:	48 2f       	mov	r20, r24
    1166:	8a 81       	ldd	r24, Y+2	; 0x02
    1168:	28 2f       	mov	r18, r24
    116a:	30 e0       	ldi	r19, 0x00	; 0
    116c:	81 e0       	ldi	r24, 0x01	; 1
    116e:	90 e0       	ldi	r25, 0x00	; 0
    1170:	02 2e       	mov	r0, r18
    1172:	02 c0       	rjmp	.+4      	; 0x1178 <MDIO_Error_State_SetPinValue+0x14c>
    1174:	88 0f       	add	r24, r24
    1176:	99 1f       	adc	r25, r25
    1178:	0a 94       	dec	r0
    117a:	e2 f7       	brpl	.-8      	; 0x1174 <MDIO_Error_State_SetPinValue+0x148>
    117c:	84 2b       	or	r24, r20
    117e:	8c 93       	st	X, r24
    1180:	4e c0       	rjmp	.+156    	; 0x121e <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    1182:	8c 81       	ldd	r24, Y+4	; 0x04
    1184:	88 23       	and	r24, r24
    1186:	a9 f4       	brne	.+42     	; 0x11b2 <MDIO_Error_State_SetPinValue+0x186>
			{
				CLR_BIT(PORTC,Copy_u8PinNumber);
    1188:	a5 e3       	ldi	r26, 0x35	; 53
    118a:	b0 e0       	ldi	r27, 0x00	; 0
    118c:	e5 e3       	ldi	r30, 0x35	; 53
    118e:	f0 e0       	ldi	r31, 0x00	; 0
    1190:	80 81       	ld	r24, Z
    1192:	48 2f       	mov	r20, r24
    1194:	8a 81       	ldd	r24, Y+2	; 0x02
    1196:	28 2f       	mov	r18, r24
    1198:	30 e0       	ldi	r19, 0x00	; 0
    119a:	81 e0       	ldi	r24, 0x01	; 1
    119c:	90 e0       	ldi	r25, 0x00	; 0
    119e:	02 2e       	mov	r0, r18
    11a0:	02 c0       	rjmp	.+4      	; 0x11a6 <MDIO_Error_State_SetPinValue+0x17a>
    11a2:	88 0f       	add	r24, r24
    11a4:	99 1f       	adc	r25, r25
    11a6:	0a 94       	dec	r0
    11a8:	e2 f7       	brpl	.-8      	; 0x11a2 <MDIO_Error_State_SetPinValue+0x176>
    11aa:	80 95       	com	r24
    11ac:	84 23       	and	r24, r20
    11ae:	8c 93       	st	X, r24
    11b0:	36 c0       	rjmp	.+108    	; 0x121e <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    11b2:	19 82       	std	Y+1, r1	; 0x01
    11b4:	34 c0       	rjmp	.+104    	; 0x121e <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;	
		case MDIO_PORTD:
			if(Copy_u8PinValue==PIN_HIGH)
    11b6:	8c 81       	ldd	r24, Y+4	; 0x04
    11b8:	81 30       	cpi	r24, 0x01	; 1
    11ba:	a1 f4       	brne	.+40     	; 0x11e4 <MDIO_Error_State_SetPinValue+0x1b8>
			{
				SET_BIT(PORTD,Copy_u8PinNumber);
    11bc:	a2 e3       	ldi	r26, 0x32	; 50
    11be:	b0 e0       	ldi	r27, 0x00	; 0
    11c0:	e2 e3       	ldi	r30, 0x32	; 50
    11c2:	f0 e0       	ldi	r31, 0x00	; 0
    11c4:	80 81       	ld	r24, Z
    11c6:	48 2f       	mov	r20, r24
    11c8:	8a 81       	ldd	r24, Y+2	; 0x02
    11ca:	28 2f       	mov	r18, r24
    11cc:	30 e0       	ldi	r19, 0x00	; 0
    11ce:	81 e0       	ldi	r24, 0x01	; 1
    11d0:	90 e0       	ldi	r25, 0x00	; 0
    11d2:	02 2e       	mov	r0, r18
    11d4:	02 c0       	rjmp	.+4      	; 0x11da <MDIO_Error_State_SetPinValue+0x1ae>
    11d6:	88 0f       	add	r24, r24
    11d8:	99 1f       	adc	r25, r25
    11da:	0a 94       	dec	r0
    11dc:	e2 f7       	brpl	.-8      	; 0x11d6 <MDIO_Error_State_SetPinValue+0x1aa>
    11de:	84 2b       	or	r24, r20
    11e0:	8c 93       	st	X, r24
    11e2:	1d c0       	rjmp	.+58     	; 0x121e <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    11e4:	8c 81       	ldd	r24, Y+4	; 0x04
    11e6:	88 23       	and	r24, r24
    11e8:	a9 f4       	brne	.+42     	; 0x1214 <MDIO_Error_State_SetPinValue+0x1e8>
			{
				CLR_BIT(PORTD,Copy_u8PinNumber);
    11ea:	a2 e3       	ldi	r26, 0x32	; 50
    11ec:	b0 e0       	ldi	r27, 0x00	; 0
    11ee:	e2 e3       	ldi	r30, 0x32	; 50
    11f0:	f0 e0       	ldi	r31, 0x00	; 0
    11f2:	80 81       	ld	r24, Z
    11f4:	48 2f       	mov	r20, r24
    11f6:	8a 81       	ldd	r24, Y+2	; 0x02
    11f8:	28 2f       	mov	r18, r24
    11fa:	30 e0       	ldi	r19, 0x00	; 0
    11fc:	81 e0       	ldi	r24, 0x01	; 1
    11fe:	90 e0       	ldi	r25, 0x00	; 0
    1200:	02 2e       	mov	r0, r18
    1202:	02 c0       	rjmp	.+4      	; 0x1208 <MDIO_Error_State_SetPinValue+0x1dc>
    1204:	88 0f       	add	r24, r24
    1206:	99 1f       	adc	r25, r25
    1208:	0a 94       	dec	r0
    120a:	e2 f7       	brpl	.-8      	; 0x1204 <MDIO_Error_State_SetPinValue+0x1d8>
    120c:	80 95       	com	r24
    120e:	84 23       	and	r24, r20
    1210:	8c 93       	st	X, r24
    1212:	05 c0       	rjmp	.+10     	; 0x121e <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    1214:	19 82       	std	Y+1, r1	; 0x01
    1216:	03 c0       	rjmp	.+6      	; 0x121e <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    1218:	19 82       	std	Y+1, r1	; 0x01
    121a:	01 c0       	rjmp	.+2      	; 0x121e <MDIO_Error_State_SetPinValue+0x1f2>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    121c:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    121e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1220:	26 96       	adiw	r28, 0x06	; 6
    1222:	0f b6       	in	r0, 0x3f	; 63
    1224:	f8 94       	cli
    1226:	de bf       	out	0x3e, r29	; 62
    1228:	0f be       	out	0x3f, r0	; 63
    122a:	cd bf       	out	0x3d, r28	; 61
    122c:	cf 91       	pop	r28
    122e:	df 91       	pop	r29
    1230:	08 95       	ret

00001232 <MDIO_Error_State_SetPortValue>:

/*Set Port Value Function */
Error_State MDIO_Error_State_SetPortValue(u8 Copy_u8PortNumber,u8 Copy_u8PortValue)
{
    1232:	df 93       	push	r29
    1234:	cf 93       	push	r28
    1236:	00 d0       	rcall	.+0      	; 0x1238 <MDIO_Error_State_SetPortValue+0x6>
    1238:	00 d0       	rcall	.+0      	; 0x123a <MDIO_Error_State_SetPortValue+0x8>
    123a:	0f 92       	push	r0
    123c:	cd b7       	in	r28, 0x3d	; 61
    123e:	de b7       	in	r29, 0x3e	; 62
    1240:	8a 83       	std	Y+2, r24	; 0x02
    1242:	6b 83       	std	Y+3, r22	; 0x03
	Error_State LOC_Error_State_ReturnState=OK;
    1244:	81 e0       	ldi	r24, 0x01	; 1
    1246:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_u8PortNumber)
    1248:	8a 81       	ldd	r24, Y+2	; 0x02
    124a:	28 2f       	mov	r18, r24
    124c:	30 e0       	ldi	r19, 0x00	; 0
    124e:	3d 83       	std	Y+5, r19	; 0x05
    1250:	2c 83       	std	Y+4, r18	; 0x04
    1252:	8c 81       	ldd	r24, Y+4	; 0x04
    1254:	9d 81       	ldd	r25, Y+5	; 0x05
    1256:	81 30       	cpi	r24, 0x01	; 1
    1258:	91 05       	cpc	r25, r1
    125a:	d1 f0       	breq	.+52     	; 0x1290 <MDIO_Error_State_SetPortValue+0x5e>
    125c:	2c 81       	ldd	r18, Y+4	; 0x04
    125e:	3d 81       	ldd	r19, Y+5	; 0x05
    1260:	22 30       	cpi	r18, 0x02	; 2
    1262:	31 05       	cpc	r19, r1
    1264:	2c f4       	brge	.+10     	; 0x1270 <MDIO_Error_State_SetPortValue+0x3e>
    1266:	8c 81       	ldd	r24, Y+4	; 0x04
    1268:	9d 81       	ldd	r25, Y+5	; 0x05
    126a:	00 97       	sbiw	r24, 0x00	; 0
    126c:	61 f0       	breq	.+24     	; 0x1286 <MDIO_Error_State_SetPortValue+0x54>
    126e:	1f c0       	rjmp	.+62     	; 0x12ae <MDIO_Error_State_SetPortValue+0x7c>
    1270:	2c 81       	ldd	r18, Y+4	; 0x04
    1272:	3d 81       	ldd	r19, Y+5	; 0x05
    1274:	22 30       	cpi	r18, 0x02	; 2
    1276:	31 05       	cpc	r19, r1
    1278:	81 f0       	breq	.+32     	; 0x129a <MDIO_Error_State_SetPortValue+0x68>
    127a:	8c 81       	ldd	r24, Y+4	; 0x04
    127c:	9d 81       	ldd	r25, Y+5	; 0x05
    127e:	83 30       	cpi	r24, 0x03	; 3
    1280:	91 05       	cpc	r25, r1
    1282:	81 f0       	breq	.+32     	; 0x12a4 <MDIO_Error_State_SetPortValue+0x72>
    1284:	14 c0       	rjmp	.+40     	; 0x12ae <MDIO_Error_State_SetPortValue+0x7c>
	{
	case MDIO_PORTA:
		PORTA=Copy_u8PortValue;
    1286:	eb e3       	ldi	r30, 0x3B	; 59
    1288:	f0 e0       	ldi	r31, 0x00	; 0
    128a:	8b 81       	ldd	r24, Y+3	; 0x03
    128c:	80 83       	st	Z, r24
    128e:	10 c0       	rjmp	.+32     	; 0x12b0 <MDIO_Error_State_SetPortValue+0x7e>
		break;
	case MDIO_PORTB:
		PORTB=Copy_u8PortValue;
    1290:	e8 e3       	ldi	r30, 0x38	; 56
    1292:	f0 e0       	ldi	r31, 0x00	; 0
    1294:	8b 81       	ldd	r24, Y+3	; 0x03
    1296:	80 83       	st	Z, r24
    1298:	0b c0       	rjmp	.+22     	; 0x12b0 <MDIO_Error_State_SetPortValue+0x7e>
		break;
	case MDIO_PORTC:
		PORTC=Copy_u8PortValue;
    129a:	e5 e3       	ldi	r30, 0x35	; 53
    129c:	f0 e0       	ldi	r31, 0x00	; 0
    129e:	8b 81       	ldd	r24, Y+3	; 0x03
    12a0:	80 83       	st	Z, r24
    12a2:	06 c0       	rjmp	.+12     	; 0x12b0 <MDIO_Error_State_SetPortValue+0x7e>
		break;	
	case MDIO_PORTD:
		PORTD=Copy_u8PortValue;
    12a4:	e2 e3       	ldi	r30, 0x32	; 50
    12a6:	f0 e0       	ldi	r31, 0x00	; 0
    12a8:	8b 81       	ldd	r24, Y+3	; 0x03
    12aa:	80 83       	st	Z, r24
    12ac:	01 c0       	rjmp	.+2      	; 0x12b0 <MDIO_Error_State_SetPortValue+0x7e>
		break;	
	default:
		LOC_Error_State_ReturnState=NOK;
    12ae:	19 82       	std	Y+1, r1	; 0x01
		break;
	}
	return LOC_Error_State_ReturnState;
    12b0:	89 81       	ldd	r24, Y+1	; 0x01
}
    12b2:	0f 90       	pop	r0
    12b4:	0f 90       	pop	r0
    12b6:	0f 90       	pop	r0
    12b8:	0f 90       	pop	r0
    12ba:	0f 90       	pop	r0
    12bc:	cf 91       	pop	r28
    12be:	df 91       	pop	r29
    12c0:	08 95       	ret

000012c2 <MDIO_Error_State_GetPinValue>:

/*Get Pin Value Function */
Error_State MDIO_Error_State_GetPinValue(u8 Copy_u8PinNumber,u8 Copy_u8PortNumber,u8* P_u8PinValue)
{
    12c2:	df 93       	push	r29
    12c4:	cf 93       	push	r28
    12c6:	cd b7       	in	r28, 0x3d	; 61
    12c8:	de b7       	in	r29, 0x3e	; 62
    12ca:	27 97       	sbiw	r28, 0x07	; 7
    12cc:	0f b6       	in	r0, 0x3f	; 63
    12ce:	f8 94       	cli
    12d0:	de bf       	out	0x3e, r29	; 62
    12d2:	0f be       	out	0x3f, r0	; 63
    12d4:	cd bf       	out	0x3d, r28	; 61
    12d6:	8a 83       	std	Y+2, r24	; 0x02
    12d8:	6b 83       	std	Y+3, r22	; 0x03
    12da:	5d 83       	std	Y+5, r21	; 0x05
    12dc:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    12de:	81 e0       	ldi	r24, 0x01	; 1
    12e0:	89 83       	std	Y+1, r24	; 0x01

	if(((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))&&(P_u8PinValue!=NULL_POINTER))
    12e2:	8a 81       	ldd	r24, Y+2	; 0x02
    12e4:	88 30       	cpi	r24, 0x08	; 8
    12e6:	08 f0       	brcs	.+2      	; 0x12ea <MDIO_Error_State_GetPinValue+0x28>
    12e8:	79 c0       	rjmp	.+242    	; 0x13dc <MDIO_Error_State_GetPinValue+0x11a>
    12ea:	8c 81       	ldd	r24, Y+4	; 0x04
    12ec:	9d 81       	ldd	r25, Y+5	; 0x05
    12ee:	81 30       	cpi	r24, 0x01	; 1
    12f0:	91 05       	cpc	r25, r1
    12f2:	09 f4       	brne	.+2      	; 0x12f6 <MDIO_Error_State_GetPinValue+0x34>
    12f4:	73 c0       	rjmp	.+230    	; 0x13dc <MDIO_Error_State_GetPinValue+0x11a>
	{
		switch(Copy_u8PortNumber)
    12f6:	8b 81       	ldd	r24, Y+3	; 0x03
    12f8:	28 2f       	mov	r18, r24
    12fa:	30 e0       	ldi	r19, 0x00	; 0
    12fc:	3f 83       	std	Y+7, r19	; 0x07
    12fe:	2e 83       	std	Y+6, r18	; 0x06
    1300:	4e 81       	ldd	r20, Y+6	; 0x06
    1302:	5f 81       	ldd	r21, Y+7	; 0x07
    1304:	41 30       	cpi	r20, 0x01	; 1
    1306:	51 05       	cpc	r21, r1
    1308:	59 f1       	breq	.+86     	; 0x1360 <MDIO_Error_State_GetPinValue+0x9e>
    130a:	8e 81       	ldd	r24, Y+6	; 0x06
    130c:	9f 81       	ldd	r25, Y+7	; 0x07
    130e:	82 30       	cpi	r24, 0x02	; 2
    1310:	91 05       	cpc	r25, r1
    1312:	34 f4       	brge	.+12     	; 0x1320 <MDIO_Error_State_GetPinValue+0x5e>
    1314:	2e 81       	ldd	r18, Y+6	; 0x06
    1316:	3f 81       	ldd	r19, Y+7	; 0x07
    1318:	21 15       	cp	r18, r1
    131a:	31 05       	cpc	r19, r1
    131c:	69 f0       	breq	.+26     	; 0x1338 <MDIO_Error_State_GetPinValue+0x76>
    131e:	5c c0       	rjmp	.+184    	; 0x13d8 <MDIO_Error_State_GetPinValue+0x116>
    1320:	4e 81       	ldd	r20, Y+6	; 0x06
    1322:	5f 81       	ldd	r21, Y+7	; 0x07
    1324:	42 30       	cpi	r20, 0x02	; 2
    1326:	51 05       	cpc	r21, r1
    1328:	79 f1       	breq	.+94     	; 0x1388 <MDIO_Error_State_GetPinValue+0xc6>
    132a:	8e 81       	ldd	r24, Y+6	; 0x06
    132c:	9f 81       	ldd	r25, Y+7	; 0x07
    132e:	83 30       	cpi	r24, 0x03	; 3
    1330:	91 05       	cpc	r25, r1
    1332:	09 f4       	brne	.+2      	; 0x1336 <MDIO_Error_State_GetPinValue+0x74>
    1334:	3d c0       	rjmp	.+122    	; 0x13b0 <MDIO_Error_State_GetPinValue+0xee>
    1336:	50 c0       	rjmp	.+160    	; 0x13d8 <MDIO_Error_State_GetPinValue+0x116>
		{
		case MDIO_PORTA:
			*P_u8PinValue=GET_BIT(PINA,Copy_u8PinNumber);
    1338:	e9 e3       	ldi	r30, 0x39	; 57
    133a:	f0 e0       	ldi	r31, 0x00	; 0
    133c:	80 81       	ld	r24, Z
    133e:	28 2f       	mov	r18, r24
    1340:	30 e0       	ldi	r19, 0x00	; 0
    1342:	8a 81       	ldd	r24, Y+2	; 0x02
    1344:	88 2f       	mov	r24, r24
    1346:	90 e0       	ldi	r25, 0x00	; 0
    1348:	a9 01       	movw	r20, r18
    134a:	02 c0       	rjmp	.+4      	; 0x1350 <MDIO_Error_State_GetPinValue+0x8e>
    134c:	55 95       	asr	r21
    134e:	47 95       	ror	r20
    1350:	8a 95       	dec	r24
    1352:	e2 f7       	brpl	.-8      	; 0x134c <MDIO_Error_State_GetPinValue+0x8a>
    1354:	ca 01       	movw	r24, r20
    1356:	81 70       	andi	r24, 0x01	; 1
    1358:	ec 81       	ldd	r30, Y+4	; 0x04
    135a:	fd 81       	ldd	r31, Y+5	; 0x05
    135c:	80 83       	st	Z, r24
    135e:	3f c0       	rjmp	.+126    	; 0x13de <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTB:
			*P_u8PinValue=GET_BIT(PINB,Copy_u8PinNumber);
    1360:	e6 e3       	ldi	r30, 0x36	; 54
    1362:	f0 e0       	ldi	r31, 0x00	; 0
    1364:	80 81       	ld	r24, Z
    1366:	28 2f       	mov	r18, r24
    1368:	30 e0       	ldi	r19, 0x00	; 0
    136a:	8a 81       	ldd	r24, Y+2	; 0x02
    136c:	88 2f       	mov	r24, r24
    136e:	90 e0       	ldi	r25, 0x00	; 0
    1370:	a9 01       	movw	r20, r18
    1372:	02 c0       	rjmp	.+4      	; 0x1378 <MDIO_Error_State_GetPinValue+0xb6>
    1374:	55 95       	asr	r21
    1376:	47 95       	ror	r20
    1378:	8a 95       	dec	r24
    137a:	e2 f7       	brpl	.-8      	; 0x1374 <MDIO_Error_State_GetPinValue+0xb2>
    137c:	ca 01       	movw	r24, r20
    137e:	81 70       	andi	r24, 0x01	; 1
    1380:	ec 81       	ldd	r30, Y+4	; 0x04
    1382:	fd 81       	ldd	r31, Y+5	; 0x05
    1384:	80 83       	st	Z, r24
    1386:	2b c0       	rjmp	.+86     	; 0x13de <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTC:
			*P_u8PinValue=GET_BIT(PINC,Copy_u8PinNumber);
    1388:	e3 e3       	ldi	r30, 0x33	; 51
    138a:	f0 e0       	ldi	r31, 0x00	; 0
    138c:	80 81       	ld	r24, Z
    138e:	28 2f       	mov	r18, r24
    1390:	30 e0       	ldi	r19, 0x00	; 0
    1392:	8a 81       	ldd	r24, Y+2	; 0x02
    1394:	88 2f       	mov	r24, r24
    1396:	90 e0       	ldi	r25, 0x00	; 0
    1398:	a9 01       	movw	r20, r18
    139a:	02 c0       	rjmp	.+4      	; 0x13a0 <MDIO_Error_State_GetPinValue+0xde>
    139c:	55 95       	asr	r21
    139e:	47 95       	ror	r20
    13a0:	8a 95       	dec	r24
    13a2:	e2 f7       	brpl	.-8      	; 0x139c <MDIO_Error_State_GetPinValue+0xda>
    13a4:	ca 01       	movw	r24, r20
    13a6:	81 70       	andi	r24, 0x01	; 1
    13a8:	ec 81       	ldd	r30, Y+4	; 0x04
    13aa:	fd 81       	ldd	r31, Y+5	; 0x05
    13ac:	80 83       	st	Z, r24
    13ae:	17 c0       	rjmp	.+46     	; 0x13de <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTD:
			*P_u8PinValue=GET_BIT(PIND,Copy_u8PinNumber);
    13b0:	e0 e3       	ldi	r30, 0x30	; 48
    13b2:	f0 e0       	ldi	r31, 0x00	; 0
    13b4:	80 81       	ld	r24, Z
    13b6:	28 2f       	mov	r18, r24
    13b8:	30 e0       	ldi	r19, 0x00	; 0
    13ba:	8a 81       	ldd	r24, Y+2	; 0x02
    13bc:	88 2f       	mov	r24, r24
    13be:	90 e0       	ldi	r25, 0x00	; 0
    13c0:	a9 01       	movw	r20, r18
    13c2:	02 c0       	rjmp	.+4      	; 0x13c8 <MDIO_Error_State_GetPinValue+0x106>
    13c4:	55 95       	asr	r21
    13c6:	47 95       	ror	r20
    13c8:	8a 95       	dec	r24
    13ca:	e2 f7       	brpl	.-8      	; 0x13c4 <MDIO_Error_State_GetPinValue+0x102>
    13cc:	ca 01       	movw	r24, r20
    13ce:	81 70       	andi	r24, 0x01	; 1
    13d0:	ec 81       	ldd	r30, Y+4	; 0x04
    13d2:	fd 81       	ldd	r31, Y+5	; 0x05
    13d4:	80 83       	st	Z, r24
    13d6:	03 c0       	rjmp	.+6      	; 0x13de <MDIO_Error_State_GetPinValue+0x11c>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    13d8:	19 82       	std	Y+1, r1	; 0x01
    13da:	01 c0       	rjmp	.+2      	; 0x13de <MDIO_Error_State_GetPinValue+0x11c>
			break;		
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    13dc:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    13de:	89 81       	ldd	r24, Y+1	; 0x01
}
    13e0:	27 96       	adiw	r28, 0x07	; 7
    13e2:	0f b6       	in	r0, 0x3f	; 63
    13e4:	f8 94       	cli
    13e6:	de bf       	out	0x3e, r29	; 62
    13e8:	0f be       	out	0x3f, r0	; 63
    13ea:	cd bf       	out	0x3d, r28	; 61
    13ec:	cf 91       	pop	r28
    13ee:	df 91       	pop	r29
    13f0:	08 95       	ret

000013f2 <MDIO_Error_State_SetNippleValue>:
/*Set Nipple Direction Function */

/*Set Nipple Values Function */
Error_State MDIO_Error_State_SetNippleValue(u8 Copy_u8PinStart,u8 Copy_u8PortNumber,u8 Copy_u8Value)
{
    13f2:	df 93       	push	r29
    13f4:	cf 93       	push	r28
    13f6:	00 d0       	rcall	.+0      	; 0x13f8 <MDIO_Error_State_SetNippleValue+0x6>
    13f8:	00 d0       	rcall	.+0      	; 0x13fa <MDIO_Error_State_SetNippleValue+0x8>
    13fa:	00 d0       	rcall	.+0      	; 0x13fc <MDIO_Error_State_SetNippleValue+0xa>
    13fc:	cd b7       	in	r28, 0x3d	; 61
    13fe:	de b7       	in	r29, 0x3e	; 62
    1400:	8a 83       	std	Y+2, r24	; 0x02
    1402:	6b 83       	std	Y+3, r22	; 0x03
    1404:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    1406:	81 e0       	ldi	r24, 0x01	; 1
    1408:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8PinStart<=4)
    140a:	8a 81       	ldd	r24, Y+2	; 0x02
    140c:	85 30       	cpi	r24, 0x05	; 5
    140e:	08 f0       	brcs	.+2      	; 0x1412 <MDIO_Error_State_SetNippleValue+0x20>
    1410:	97 c0       	rjmp	.+302    	; 0x1540 <MDIO_Error_State_SetNippleValue+0x14e>
	{
		switch(Copy_u8PortNumber)
    1412:	8b 81       	ldd	r24, Y+3	; 0x03
    1414:	28 2f       	mov	r18, r24
    1416:	30 e0       	ldi	r19, 0x00	; 0
    1418:	3e 83       	std	Y+6, r19	; 0x06
    141a:	2d 83       	std	Y+5, r18	; 0x05
    141c:	8d 81       	ldd	r24, Y+5	; 0x05
    141e:	9e 81       	ldd	r25, Y+6	; 0x06
    1420:	81 30       	cpi	r24, 0x01	; 1
    1422:	91 05       	cpc	r25, r1
    1424:	a1 f1       	breq	.+104    	; 0x148e <MDIO_Error_State_SetNippleValue+0x9c>
    1426:	2d 81       	ldd	r18, Y+5	; 0x05
    1428:	3e 81       	ldd	r19, Y+6	; 0x06
    142a:	22 30       	cpi	r18, 0x02	; 2
    142c:	31 05       	cpc	r19, r1
    142e:	2c f4       	brge	.+10     	; 0x143a <MDIO_Error_State_SetNippleValue+0x48>
    1430:	8d 81       	ldd	r24, Y+5	; 0x05
    1432:	9e 81       	ldd	r25, Y+6	; 0x06
    1434:	00 97       	sbiw	r24, 0x00	; 0
    1436:	71 f0       	breq	.+28     	; 0x1454 <MDIO_Error_State_SetNippleValue+0x62>
    1438:	81 c0       	rjmp	.+258    	; 0x153c <MDIO_Error_State_SetNippleValue+0x14a>
    143a:	2d 81       	ldd	r18, Y+5	; 0x05
    143c:	3e 81       	ldd	r19, Y+6	; 0x06
    143e:	22 30       	cpi	r18, 0x02	; 2
    1440:	31 05       	cpc	r19, r1
    1442:	09 f4       	brne	.+2      	; 0x1446 <MDIO_Error_State_SetNippleValue+0x54>
    1444:	41 c0       	rjmp	.+130    	; 0x14c8 <MDIO_Error_State_SetNippleValue+0xd6>
    1446:	8d 81       	ldd	r24, Y+5	; 0x05
    1448:	9e 81       	ldd	r25, Y+6	; 0x06
    144a:	83 30       	cpi	r24, 0x03	; 3
    144c:	91 05       	cpc	r25, r1
    144e:	09 f4       	brne	.+2      	; 0x1452 <MDIO_Error_State_SetNippleValue+0x60>
    1450:	58 c0       	rjmp	.+176    	; 0x1502 <MDIO_Error_State_SetNippleValue+0x110>
    1452:	74 c0       	rjmp	.+232    	; 0x153c <MDIO_Error_State_SetNippleValue+0x14a>
		case MDIO_PORTA:
		/*for(u8 i=Copy_u8PinStart;i<=7;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTA&=(~(0x0F<<Copy_u8PinStart));
    1454:	ab e3       	ldi	r26, 0x3B	; 59
    1456:	b0 e0       	ldi	r27, 0x00	; 0
    1458:	eb e3       	ldi	r30, 0x3B	; 59
    145a:	f0 e0       	ldi	r31, 0x00	; 0
    145c:	80 81       	ld	r24, Z
    145e:	48 2f       	mov	r20, r24
    1460:	8a 81       	ldd	r24, Y+2	; 0x02
    1462:	28 2f       	mov	r18, r24
    1464:	30 e0       	ldi	r19, 0x00	; 0
    1466:	8f e0       	ldi	r24, 0x0F	; 15
    1468:	90 e0       	ldi	r25, 0x00	; 0
    146a:	02 2e       	mov	r0, r18
    146c:	02 c0       	rjmp	.+4      	; 0x1472 <MDIO_Error_State_SetNippleValue+0x80>
    146e:	88 0f       	add	r24, r24
    1470:	99 1f       	adc	r25, r25
    1472:	0a 94       	dec	r0
    1474:	e2 f7       	brpl	.-8      	; 0x146e <MDIO_Error_State_SetNippleValue+0x7c>
    1476:	80 95       	com	r24
    1478:	84 23       	and	r24, r20
    147a:	8c 93       	st	X, r24
			PORTA|=Copy_u8Value;
    147c:	ab e3       	ldi	r26, 0x3B	; 59
    147e:	b0 e0       	ldi	r27, 0x00	; 0
    1480:	eb e3       	ldi	r30, 0x3B	; 59
    1482:	f0 e0       	ldi	r31, 0x00	; 0
    1484:	90 81       	ld	r25, Z
    1486:	8c 81       	ldd	r24, Y+4	; 0x04
    1488:	89 2b       	or	r24, r25
    148a:	8c 93       	st	X, r24
    148c:	5a c0       	rjmp	.+180    	; 0x1542 <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTB:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTB&=(~(0x0F<<Copy_u8PinStart));
    148e:	a8 e3       	ldi	r26, 0x38	; 56
    1490:	b0 e0       	ldi	r27, 0x00	; 0
    1492:	e8 e3       	ldi	r30, 0x38	; 56
    1494:	f0 e0       	ldi	r31, 0x00	; 0
    1496:	80 81       	ld	r24, Z
    1498:	48 2f       	mov	r20, r24
    149a:	8a 81       	ldd	r24, Y+2	; 0x02
    149c:	28 2f       	mov	r18, r24
    149e:	30 e0       	ldi	r19, 0x00	; 0
    14a0:	8f e0       	ldi	r24, 0x0F	; 15
    14a2:	90 e0       	ldi	r25, 0x00	; 0
    14a4:	02 2e       	mov	r0, r18
    14a6:	02 c0       	rjmp	.+4      	; 0x14ac <MDIO_Error_State_SetNippleValue+0xba>
    14a8:	88 0f       	add	r24, r24
    14aa:	99 1f       	adc	r25, r25
    14ac:	0a 94       	dec	r0
    14ae:	e2 f7       	brpl	.-8      	; 0x14a8 <MDIO_Error_State_SetNippleValue+0xb6>
    14b0:	80 95       	com	r24
    14b2:	84 23       	and	r24, r20
    14b4:	8c 93       	st	X, r24
			PORTB|=Copy_u8Value;
    14b6:	a8 e3       	ldi	r26, 0x38	; 56
    14b8:	b0 e0       	ldi	r27, 0x00	; 0
    14ba:	e8 e3       	ldi	r30, 0x38	; 56
    14bc:	f0 e0       	ldi	r31, 0x00	; 0
    14be:	90 81       	ld	r25, Z
    14c0:	8c 81       	ldd	r24, Y+4	; 0x04
    14c2:	89 2b       	or	r24, r25
    14c4:	8c 93       	st	X, r24
    14c6:	3d c0       	rjmp	.+122    	; 0x1542 <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTC:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTC&=(~(0x0F<<Copy_u8PinStart));
    14c8:	a5 e3       	ldi	r26, 0x35	; 53
    14ca:	b0 e0       	ldi	r27, 0x00	; 0
    14cc:	e5 e3       	ldi	r30, 0x35	; 53
    14ce:	f0 e0       	ldi	r31, 0x00	; 0
    14d0:	80 81       	ld	r24, Z
    14d2:	48 2f       	mov	r20, r24
    14d4:	8a 81       	ldd	r24, Y+2	; 0x02
    14d6:	28 2f       	mov	r18, r24
    14d8:	30 e0       	ldi	r19, 0x00	; 0
    14da:	8f e0       	ldi	r24, 0x0F	; 15
    14dc:	90 e0       	ldi	r25, 0x00	; 0
    14de:	02 2e       	mov	r0, r18
    14e0:	02 c0       	rjmp	.+4      	; 0x14e6 <MDIO_Error_State_SetNippleValue+0xf4>
    14e2:	88 0f       	add	r24, r24
    14e4:	99 1f       	adc	r25, r25
    14e6:	0a 94       	dec	r0
    14e8:	e2 f7       	brpl	.-8      	; 0x14e2 <MDIO_Error_State_SetNippleValue+0xf0>
    14ea:	80 95       	com	r24
    14ec:	84 23       	and	r24, r20
    14ee:	8c 93       	st	X, r24
			PORTC|=Copy_u8Value;
    14f0:	a5 e3       	ldi	r26, 0x35	; 53
    14f2:	b0 e0       	ldi	r27, 0x00	; 0
    14f4:	e5 e3       	ldi	r30, 0x35	; 53
    14f6:	f0 e0       	ldi	r31, 0x00	; 0
    14f8:	90 81       	ld	r25, Z
    14fa:	8c 81       	ldd	r24, Y+4	; 0x04
    14fc:	89 2b       	or	r24, r25
    14fe:	8c 93       	st	X, r24
    1500:	20 c0       	rjmp	.+64     	; 0x1542 <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTD:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTD&=(~(0x0F<<Copy_u8PinStart));
    1502:	a2 e3       	ldi	r26, 0x32	; 50
    1504:	b0 e0       	ldi	r27, 0x00	; 0
    1506:	e2 e3       	ldi	r30, 0x32	; 50
    1508:	f0 e0       	ldi	r31, 0x00	; 0
    150a:	80 81       	ld	r24, Z
    150c:	48 2f       	mov	r20, r24
    150e:	8a 81       	ldd	r24, Y+2	; 0x02
    1510:	28 2f       	mov	r18, r24
    1512:	30 e0       	ldi	r19, 0x00	; 0
    1514:	8f e0       	ldi	r24, 0x0F	; 15
    1516:	90 e0       	ldi	r25, 0x00	; 0
    1518:	02 2e       	mov	r0, r18
    151a:	02 c0       	rjmp	.+4      	; 0x1520 <MDIO_Error_State_SetNippleValue+0x12e>
    151c:	88 0f       	add	r24, r24
    151e:	99 1f       	adc	r25, r25
    1520:	0a 94       	dec	r0
    1522:	e2 f7       	brpl	.-8      	; 0x151c <MDIO_Error_State_SetNippleValue+0x12a>
    1524:	80 95       	com	r24
    1526:	84 23       	and	r24, r20
    1528:	8c 93       	st	X, r24
			PORTD|=Copy_u8Value;
    152a:	a2 e3       	ldi	r26, 0x32	; 50
    152c:	b0 e0       	ldi	r27, 0x00	; 0
    152e:	e2 e3       	ldi	r30, 0x32	; 50
    1530:	f0 e0       	ldi	r31, 0x00	; 0
    1532:	90 81       	ld	r25, Z
    1534:	8c 81       	ldd	r24, Y+4	; 0x04
    1536:	89 2b       	or	r24, r25
    1538:	8c 93       	st	X, r24
    153a:	03 c0       	rjmp	.+6      	; 0x1542 <MDIO_Error_State_SetNippleValue+0x150>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    153c:	19 82       	std	Y+1, r1	; 0x01
    153e:	01 c0       	rjmp	.+2      	; 0x1542 <MDIO_Error_State_SetNippleValue+0x150>
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    1540:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_Error_State_ReturnState;
    1542:	89 81       	ldd	r24, Y+1	; 0x01
}
    1544:	26 96       	adiw	r28, 0x06	; 6
    1546:	0f b6       	in	r0, 0x3f	; 63
    1548:	f8 94       	cli
    154a:	de bf       	out	0x3e, r29	; 62
    154c:	0f be       	out	0x3f, r0	; 63
    154e:	cd bf       	out	0x3d, r28	; 61
    1550:	cf 91       	pop	r28
    1552:	df 91       	pop	r29
    1554:	08 95       	ret

00001556 <MADC_VidInit>:

void (*MADC_CallBack)(void);

/*ADC Initialization*/
void MADC_VidInit(void)
{
    1556:	df 93       	push	r29
    1558:	cf 93       	push	r28
    155a:	cd b7       	in	r28, 0x3d	; 61
    155c:	de b7       	in	r29, 0x3e	; 62
	/*Select Reference Voltage*/
#if MADC_SET_REFERENCEVOLATGE == MADC_AVCC_REFERENCEVOLATGE
	SET_BIT(ADMUX,6);
    155e:	a7 e2       	ldi	r26, 0x27	; 39
    1560:	b0 e0       	ldi	r27, 0x00	; 0
    1562:	e7 e2       	ldi	r30, 0x27	; 39
    1564:	f0 e0       	ldi	r31, 0x00	; 0
    1566:	80 81       	ld	r24, Z
    1568:	80 64       	ori	r24, 0x40	; 64
    156a:	8c 93       	st	X, r24
	CLR_BIT(ADMUX,7);
    156c:	a7 e2       	ldi	r26, 0x27	; 39
    156e:	b0 e0       	ldi	r27, 0x00	; 0
    1570:	e7 e2       	ldi	r30, 0x27	; 39
    1572:	f0 e0       	ldi	r31, 0x00	; 0
    1574:	80 81       	ld	r24, Z
    1576:	8f 77       	andi	r24, 0x7F	; 127
    1578:	8c 93       	st	X, r24
	SET_BIT(ADMUX,7);
#else
#error"ADC Reference Voltage Option I s not valid.... "
#endif
/*Set Prescaler*/
ADCSRA&=MADC_BIT_MASKING_PRESCALER;
    157a:	a6 e2       	ldi	r26, 0x26	; 38
    157c:	b0 e0       	ldi	r27, 0x00	; 0
    157e:	e6 e2       	ldi	r30, 0x26	; 38
    1580:	f0 e0       	ldi	r31, 0x00	; 0
    1582:	80 81       	ld	r24, Z
    1584:	88 7f       	andi	r24, 0xF8	; 248
    1586:	8c 93       	st	X, r24
ADCSRA|=MADC_SET_PRESCALER;
    1588:	a6 e2       	ldi	r26, 0x26	; 38
    158a:	b0 e0       	ldi	r27, 0x00	; 0
    158c:	e6 e2       	ldi	r30, 0x26	; 38
    158e:	f0 e0       	ldi	r31, 0x00	; 0
    1590:	80 81       	ld	r24, Z
    1592:	87 60       	ori	r24, 0x07	; 7
    1594:	8c 93       	st	X, r24

#if MADC_SET_ADJUST == MADC_LEFT_ADJUST
	SET_BIT(ADMUX,5);
#elif MADC_SET_ADJUST == MADC_RIGHT_ADJUST
	CLR_BIT(ADMUX,5);
    1596:	a7 e2       	ldi	r26, 0x27	; 39
    1598:	b0 e0       	ldi	r27, 0x00	; 0
    159a:	e7 e2       	ldi	r30, 0x27	; 39
    159c:	f0 e0       	ldi	r31, 0x00	; 0
    159e:	80 81       	ld	r24, Z
    15a0:	8f 7d       	andi	r24, 0xDF	; 223
    15a2:	8c 93       	st	X, r24
#else
#error"ADC Left adjust option is not valid...."
#endif
/*Enable To ADC*/
SET_BIT(ADCSRA,7);
    15a4:	a6 e2       	ldi	r26, 0x26	; 38
    15a6:	b0 e0       	ldi	r27, 0x00	; 0
    15a8:	e6 e2       	ldi	r30, 0x26	; 38
    15aa:	f0 e0       	ldi	r31, 0x00	; 0
    15ac:	80 81       	ld	r24, Z
    15ae:	80 68       	ori	r24, 0x80	; 128
    15b0:	8c 93       	st	X, r24
}
    15b2:	cf 91       	pop	r28
    15b4:	df 91       	pop	r29
    15b6:	08 95       	ret

000015b8 <MADC_VidADCInterruptEnable>:
void MADC_VidADCInterruptEnable(void)
{
    15b8:	df 93       	push	r29
    15ba:	cf 93       	push	r28
    15bc:	cd b7       	in	r28, 0x3d	; 61
    15be:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(ADCSRA,3);
    15c0:	a6 e2       	ldi	r26, 0x26	; 38
    15c2:	b0 e0       	ldi	r27, 0x00	; 0
    15c4:	e6 e2       	ldi	r30, 0x26	; 38
    15c6:	f0 e0       	ldi	r31, 0x00	; 0
    15c8:	80 81       	ld	r24, Z
    15ca:	88 60       	ori	r24, 0x08	; 8
    15cc:	8c 93       	st	X, r24
}
    15ce:	cf 91       	pop	r28
    15d0:	df 91       	pop	r29
    15d2:	08 95       	ret

000015d4 <MADC_u16ADC_StartConversion>:
/*ADC Start Conversion-->Polling , Return ADC Value*/
u16 MADC_u16ADC_StartConversion(u8 Copy_u8Channel)
{
    15d4:	df 93       	push	r29
    15d6:	cf 93       	push	r28
    15d8:	0f 92       	push	r0
    15da:	cd b7       	in	r28, 0x3d	; 61
    15dc:	de b7       	in	r29, 0x3e	; 62
    15de:	89 83       	std	Y+1, r24	; 0x01
	/*Select Channel*/
	Copy_u8Channel&=MADC_BIT_MASKING_CHANNEL;
    15e0:	89 81       	ldd	r24, Y+1	; 0x01
    15e2:	87 70       	andi	r24, 0x07	; 7
    15e4:	89 83       	std	Y+1, r24	; 0x01
	ADMUX&=MADC_BIT_MASKING_REG_CHANNEL;
    15e6:	a7 e2       	ldi	r26, 0x27	; 39
    15e8:	b0 e0       	ldi	r27, 0x00	; 0
    15ea:	e7 e2       	ldi	r30, 0x27	; 39
    15ec:	f0 e0       	ldi	r31, 0x00	; 0
    15ee:	80 81       	ld	r24, Z
    15f0:	80 7e       	andi	r24, 0xE0	; 224
    15f2:	8c 93       	st	X, r24
	ADMUX|=Copy_u8Channel;
    15f4:	a7 e2       	ldi	r26, 0x27	; 39
    15f6:	b0 e0       	ldi	r27, 0x00	; 0
    15f8:	e7 e2       	ldi	r30, 0x27	; 39
    15fa:	f0 e0       	ldi	r31, 0x00	; 0
    15fc:	90 81       	ld	r25, Z
    15fe:	89 81       	ldd	r24, Y+1	; 0x01
    1600:	89 2b       	or	r24, r25
    1602:	8c 93       	st	X, r24
   /*send Start Conversion*/
	SET_BIT(ADCSRA,6);
    1604:	a6 e2       	ldi	r26, 0x26	; 38
    1606:	b0 e0       	ldi	r27, 0x00	; 0
    1608:	e6 e2       	ldi	r30, 0x26	; 38
    160a:	f0 e0       	ldi	r31, 0x00	; 0
    160c:	80 81       	ld	r24, Z
    160e:	80 64       	ori	r24, 0x40	; 64
    1610:	8c 93       	st	X, r24
	/*Wait On ADC Conversion Completed Flag is set to one */
	while(GET_BIT(ADCSRA,4)==0);
    1612:	e6 e2       	ldi	r30, 0x26	; 38
    1614:	f0 e0       	ldi	r31, 0x00	; 0
    1616:	80 81       	ld	r24, Z
    1618:	82 95       	swap	r24
    161a:	8f 70       	andi	r24, 0x0F	; 15
    161c:	88 2f       	mov	r24, r24
    161e:	90 e0       	ldi	r25, 0x00	; 0
    1620:	81 70       	andi	r24, 0x01	; 1
    1622:	90 70       	andi	r25, 0x00	; 0
    1624:	00 97       	sbiw	r24, 0x00	; 0
    1626:	a9 f3       	breq	.-22     	; 0x1612 <MADC_u16ADC_StartConversion+0x3e>

	return ADC;
    1628:	e4 e2       	ldi	r30, 0x24	; 36
    162a:	f0 e0       	ldi	r31, 0x00	; 0
    162c:	80 81       	ld	r24, Z
    162e:	91 81       	ldd	r25, Z+1	; 0x01
}
    1630:	0f 90       	pop	r0
    1632:	cf 91       	pop	r28
    1634:	df 91       	pop	r29
    1636:	08 95       	ret

00001638 <MADC_u16ADC_StartConversion_With_Interrupt>:
void MADC_u16ADC_StartConversion_With_Interrupt(u8 Copy_u8Channel)
{
    1638:	df 93       	push	r29
    163a:	cf 93       	push	r28
    163c:	0f 92       	push	r0
    163e:	cd b7       	in	r28, 0x3d	; 61
    1640:	de b7       	in	r29, 0x3e	; 62
    1642:	89 83       	std	Y+1, r24	; 0x01
	/*Select Channel*/
	Copy_u8Channel&=MADC_BIT_MASKING_CHANNEL;
    1644:	89 81       	ldd	r24, Y+1	; 0x01
    1646:	87 70       	andi	r24, 0x07	; 7
    1648:	89 83       	std	Y+1, r24	; 0x01
	ADMUX&=MADC_BIT_MASKING_REG_CHANNEL;
    164a:	a7 e2       	ldi	r26, 0x27	; 39
    164c:	b0 e0       	ldi	r27, 0x00	; 0
    164e:	e7 e2       	ldi	r30, 0x27	; 39
    1650:	f0 e0       	ldi	r31, 0x00	; 0
    1652:	80 81       	ld	r24, Z
    1654:	80 7e       	andi	r24, 0xE0	; 224
    1656:	8c 93       	st	X, r24
	ADMUX|=Copy_u8Channel;
    1658:	a7 e2       	ldi	r26, 0x27	; 39
    165a:	b0 e0       	ldi	r27, 0x00	; 0
    165c:	e7 e2       	ldi	r30, 0x27	; 39
    165e:	f0 e0       	ldi	r31, 0x00	; 0
    1660:	90 81       	ld	r25, Z
    1662:	89 81       	ldd	r24, Y+1	; 0x01
    1664:	89 2b       	or	r24, r25
    1666:	8c 93       	st	X, r24
   /*send Start Conversion*/
	SET_BIT(ADCSRA,6);
    1668:	a6 e2       	ldi	r26, 0x26	; 38
    166a:	b0 e0       	ldi	r27, 0x00	; 0
    166c:	e6 e2       	ldi	r30, 0x26	; 38
    166e:	f0 e0       	ldi	r31, 0x00	; 0
    1670:	80 81       	ld	r24, Z
    1672:	80 64       	ori	r24, 0x40	; 64
    1674:	8c 93       	st	X, r24
}
    1676:	0f 90       	pop	r0
    1678:	cf 91       	pop	r28
    167a:	df 91       	pop	r29
    167c:	08 95       	ret

0000167e <MADC_u16ADCRead>:
u16 MADC_u16ADCRead(void)
{
    167e:	df 93       	push	r29
    1680:	cf 93       	push	r28
    1682:	cd b7       	in	r28, 0x3d	; 61
    1684:	de b7       	in	r29, 0x3e	; 62
	return ADC;
    1686:	e4 e2       	ldi	r30, 0x24	; 36
    1688:	f0 e0       	ldi	r31, 0x00	; 0
    168a:	80 81       	ld	r24, Z
    168c:	91 81       	ldd	r25, Z+1	; 0x01
}
    168e:	cf 91       	pop	r28
    1690:	df 91       	pop	r29
    1692:	08 95       	ret

00001694 <MADC_VidSetCallBack>:
void MADC_VidSetCallBack(void (*Copy_pFun)(void))
{
    1694:	df 93       	push	r29
    1696:	cf 93       	push	r28
    1698:	00 d0       	rcall	.+0      	; 0x169a <MADC_VidSetCallBack+0x6>
    169a:	cd b7       	in	r28, 0x3d	; 61
    169c:	de b7       	in	r29, 0x3e	; 62
    169e:	9a 83       	std	Y+2, r25	; 0x02
    16a0:	89 83       	std	Y+1, r24	; 0x01
	MADC_CallBack=Copy_pFun;
    16a2:	89 81       	ldd	r24, Y+1	; 0x01
    16a4:	9a 81       	ldd	r25, Y+2	; 0x02
    16a6:	90 93 c4 07 	sts	0x07C4, r25
    16aa:	80 93 c3 07 	sts	0x07C3, r24
}
    16ae:	0f 90       	pop	r0
    16b0:	0f 90       	pop	r0
    16b2:	cf 91       	pop	r28
    16b4:	df 91       	pop	r29
    16b6:	08 95       	ret

000016b8 <__vector_16>:

void __vector_16(void)
{
    16b8:	1f 92       	push	r1
    16ba:	0f 92       	push	r0
    16bc:	0f b6       	in	r0, 0x3f	; 63
    16be:	0f 92       	push	r0
    16c0:	11 24       	eor	r1, r1
    16c2:	2f 93       	push	r18
    16c4:	3f 93       	push	r19
    16c6:	4f 93       	push	r20
    16c8:	5f 93       	push	r21
    16ca:	6f 93       	push	r22
    16cc:	7f 93       	push	r23
    16ce:	8f 93       	push	r24
    16d0:	9f 93       	push	r25
    16d2:	af 93       	push	r26
    16d4:	bf 93       	push	r27
    16d6:	ef 93       	push	r30
    16d8:	ff 93       	push	r31
    16da:	df 93       	push	r29
    16dc:	cf 93       	push	r28
    16de:	cd b7       	in	r28, 0x3d	; 61
    16e0:	de b7       	in	r29, 0x3e	; 62
	MADC_CallBack();
    16e2:	e0 91 c3 07 	lds	r30, 0x07C3
    16e6:	f0 91 c4 07 	lds	r31, 0x07C4
    16ea:	09 95       	icall
}
    16ec:	cf 91       	pop	r28
    16ee:	df 91       	pop	r29
    16f0:	ff 91       	pop	r31
    16f2:	ef 91       	pop	r30
    16f4:	bf 91       	pop	r27
    16f6:	af 91       	pop	r26
    16f8:	9f 91       	pop	r25
    16fa:	8f 91       	pop	r24
    16fc:	7f 91       	pop	r23
    16fe:	6f 91       	pop	r22
    1700:	5f 91       	pop	r21
    1702:	4f 91       	pop	r20
    1704:	3f 91       	pop	r19
    1706:	2f 91       	pop	r18
    1708:	0f 90       	pop	r0
    170a:	0f be       	out	0x3f, r0	; 63
    170c:	0f 90       	pop	r0
    170e:	1f 90       	pop	r1
    1710:	18 95       	reti

00001712 <HKPD_VidInit>:
		'+'
		},
};
/*KPD INIT*/
void HKPD_VidInit(void)
{
    1712:	df 93       	push	r29
    1714:	cf 93       	push	r28
    1716:	cd b7       	in	r28, 0x3d	; 61
    1718:	de b7       	in	r29, 0x3e	; 62
	/* Set Row Pins as an Input */
	MDIO_Error_State_SetPinDirection(ROW_PIN0,ROW_PORT,PIN_INPUT);
    171a:	84 e0       	ldi	r24, 0x04	; 4
    171c:	61 e0       	ldi	r22, 0x01	; 1
    171e:	40 e0       	ldi	r20, 0x00	; 0
    1720:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(ROW_PIN1,ROW_PORT,PIN_INPUT);
    1724:	85 e0       	ldi	r24, 0x05	; 5
    1726:	61 e0       	ldi	r22, 0x01	; 1
    1728:	40 e0       	ldi	r20, 0x00	; 0
    172a:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(ROW_PIN2,ROW_PORT,PIN_INPUT);
    172e:	86 e0       	ldi	r24, 0x06	; 6
    1730:	61 e0       	ldi	r22, 0x01	; 1
    1732:	40 e0       	ldi	r20, 0x00	; 0
    1734:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(ROW_PIN3,ROW_PORT,PIN_INPUT);
    1738:	87 e0       	ldi	r24, 0x07	; 7
    173a:	61 e0       	ldi	r22, 0x01	; 1
    173c:	40 e0       	ldi	r20, 0x00	; 0
    173e:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>
	/* Set Column Pins as an Output */
	MDIO_Error_State_SetPinDirection(COL_PIN0,COL_PORT,PIN_OUTPUT);
    1742:	82 e0       	ldi	r24, 0x02	; 2
    1744:	63 e0       	ldi	r22, 0x03	; 3
    1746:	41 e0       	ldi	r20, 0x01	; 1
    1748:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(COL_PIN1,COL_PORT,PIN_OUTPUT);
    174c:	83 e0       	ldi	r24, 0x03	; 3
    174e:	63 e0       	ldi	r22, 0x03	; 3
    1750:	41 e0       	ldi	r20, 0x01	; 1
    1752:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(COL_PIN2,COL_PORT,PIN_OUTPUT);
    1756:	84 e0       	ldi	r24, 0x04	; 4
    1758:	63 e0       	ldi	r22, 0x03	; 3
    175a:	41 e0       	ldi	r20, 0x01	; 1
    175c:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(COL_PIN3,COL_PORT,PIN_OUTPUT);
    1760:	85 e0       	ldi	r24, 0x05	; 5
    1762:	63 e0       	ldi	r22, 0x03	; 3
    1764:	41 e0       	ldi	r20, 0x01	; 1
    1766:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>
	/* Active Pull Up Resistor For Row Pins */
	MDIO_Error_State_SetPinValue(ROW_PIN0,ROW_PORT,PIN_HIGH);
    176a:	84 e0       	ldi	r24, 0x04	; 4
    176c:	61 e0       	ldi	r22, 0x01	; 1
    176e:	41 e0       	ldi	r20, 0x01	; 1
    1770:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(ROW_PIN1,ROW_PORT,PIN_HIGH);
    1774:	85 e0       	ldi	r24, 0x05	; 5
    1776:	61 e0       	ldi	r22, 0x01	; 1
    1778:	41 e0       	ldi	r20, 0x01	; 1
    177a:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(ROW_PIN2,ROW_PORT,PIN_HIGH);
    177e:	86 e0       	ldi	r24, 0x06	; 6
    1780:	61 e0       	ldi	r22, 0x01	; 1
    1782:	41 e0       	ldi	r20, 0x01	; 1
    1784:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(ROW_PIN3,ROW_PORT,PIN_HIGH);
    1788:	87 e0       	ldi	r24, 0x07	; 7
    178a:	61 e0       	ldi	r22, 0x01	; 1
    178c:	41 e0       	ldi	r20, 0x01	; 1
    178e:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
	/* Initialize 4 Column Pins By Ones */
	MDIO_Error_State_SetPinValue(COL_PIN0,COL_PORT,PIN_HIGH);
    1792:	82 e0       	ldi	r24, 0x02	; 2
    1794:	63 e0       	ldi	r22, 0x03	; 3
    1796:	41 e0       	ldi	r20, 0x01	; 1
    1798:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(COL_PIN1,COL_PORT,PIN_HIGH);
    179c:	83 e0       	ldi	r24, 0x03	; 3
    179e:	63 e0       	ldi	r22, 0x03	; 3
    17a0:	41 e0       	ldi	r20, 0x01	; 1
    17a2:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(COL_PIN2,COL_PORT,PIN_HIGH);
    17a6:	84 e0       	ldi	r24, 0x04	; 4
    17a8:	63 e0       	ldi	r22, 0x03	; 3
    17aa:	41 e0       	ldi	r20, 0x01	; 1
    17ac:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(COL_PIN3,COL_PORT,PIN_HIGH);
    17b0:	85 e0       	ldi	r24, 0x05	; 5
    17b2:	63 e0       	ldi	r22, 0x03	; 3
    17b4:	41 e0       	ldi	r20, 0x01	; 1
    17b6:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
}
    17ba:	cf 91       	pop	r28
    17bc:	df 91       	pop	r29
    17be:	08 95       	ret

000017c0 <HKPD_U8GetKeyPressed>:
/*KPD Get pressed*/
u8 HKPD_U8GetKeyPressed(void)
{
    17c0:	df 93       	push	r29
    17c2:	cf 93       	push	r28
    17c4:	00 d0       	rcall	.+0      	; 0x17c6 <HKPD_U8GetKeyPressed+0x6>
    17c6:	00 d0       	rcall	.+0      	; 0x17c8 <HKPD_U8GetKeyPressed+0x8>
    17c8:	cd b7       	in	r28, 0x3d	; 61
    17ca:	de b7       	in	r29, 0x3e	; 62
	u8 LOC_U8RowCount;
	u8 LOC_U8ColCount;
	/*Initialize the switch status to NOT PRESSED*/
	u8 LOC_U8ReturnValue=NOT_PRESSED;
    17cc:	8f ef       	ldi	r24, 0xFF	; 255
    17ce:	89 83       	std	Y+1, r24	; 0x01
	u8 LOC_U8PinState;
	/*Looping on columns of the keypad*/
	for(LOC_U8ColCount=COL_INIT;LOC_U8ColCount<COL_END;LOC_U8ColCount++)
    17d0:	82 e0       	ldi	r24, 0x02	; 2
    17d2:	8a 83       	std	Y+2, r24	; 0x02
    17d4:	45 c0       	rjmp	.+138    	; 0x1860 <HKPD_U8GetKeyPressed+0xa0>
	{
		/*Active the Column */
		MDIO_Error_State_SetPinValue(LOC_U8ColCount,COL_PORT,PIN_LOW);
    17d6:	8a 81       	ldd	r24, Y+2	; 0x02
    17d8:	63 e0       	ldi	r22, 0x03	; 3
    17da:	40 e0       	ldi	r20, 0x00	; 0
    17dc:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
		/*Loop to read the all row pins*/
		for(LOC_U8RowCount=ROW_INIT;LOC_U8RowCount<ROW_END;LOC_U8RowCount++)
    17e0:	84 e0       	ldi	r24, 0x04	; 4
    17e2:	8b 83       	std	Y+3, r24	; 0x03
    17e4:	32 c0       	rjmp	.+100    	; 0x184a <HKPD_U8GetKeyPressed+0x8a>
		{
			/*check the status of the switch*/
			MDIO_Error_State_GetPinValue(LOC_U8RowCount,ROW_PORT,&LOC_U8PinState);
    17e6:	9e 01       	movw	r18, r28
    17e8:	2c 5f       	subi	r18, 0xFC	; 252
    17ea:	3f 4f       	sbci	r19, 0xFF	; 255
    17ec:	8b 81       	ldd	r24, Y+3	; 0x03
    17ee:	61 e0       	ldi	r22, 0x01	; 1
    17f0:	a9 01       	movw	r20, r18
    17f2:	0e 94 61 09 	call	0x12c2	; 0x12c2 <MDIO_Error_State_GetPinValue>
			if(LOC_U8PinState==0)
    17f6:	8c 81       	ldd	r24, Y+4	; 0x04
    17f8:	88 23       	and	r24, r24
    17fa:	21 f5       	brne	.+72     	; 0x1844 <HKPD_U8GetKeyPressed+0x84>
			{
				/*Get the Value of the current pressed switch*/
				LOC_U8ReturnValue=KPD_u8SwitchVal[LOC_U8ColCount-COL_INIT][LOC_U8RowCount-ROW_INIT];
    17fc:	8a 81       	ldd	r24, Y+2	; 0x02
    17fe:	88 2f       	mov	r24, r24
    1800:	90 e0       	ldi	r25, 0x00	; 0
    1802:	ac 01       	movw	r20, r24
    1804:	42 50       	subi	r20, 0x02	; 2
    1806:	50 40       	sbci	r21, 0x00	; 0
    1808:	8b 81       	ldd	r24, Y+3	; 0x03
    180a:	88 2f       	mov	r24, r24
    180c:	90 e0       	ldi	r25, 0x00	; 0
    180e:	9c 01       	movw	r18, r24
    1810:	24 50       	subi	r18, 0x04	; 4
    1812:	30 40       	sbci	r19, 0x00	; 0
    1814:	ca 01       	movw	r24, r20
    1816:	88 0f       	add	r24, r24
    1818:	99 1f       	adc	r25, r25
    181a:	88 0f       	add	r24, r24
    181c:	99 1f       	adc	r25, r25
    181e:	82 0f       	add	r24, r18
    1820:	93 1f       	adc	r25, r19
    1822:	fc 01       	movw	r30, r24
    1824:	ee 55       	subi	r30, 0x5E	; 94
    1826:	ff 4f       	sbci	r31, 0xFF	; 255
    1828:	80 81       	ld	r24, Z
    182a:	89 83       	std	Y+1, r24	; 0x01
    182c:	08 c0       	rjmp	.+16     	; 0x183e <HKPD_U8GetKeyPressed+0x7e>
				/*wait until the switch is released(Single Press)*/
				while(LOC_U8PinState==0)
				{
					MDIO_Error_State_GetPinValue(LOC_U8RowCount,ROW_PORT,&LOC_U8PinState);
    182e:	9e 01       	movw	r18, r28
    1830:	2c 5f       	subi	r18, 0xFC	; 252
    1832:	3f 4f       	sbci	r19, 0xFF	; 255
    1834:	8b 81       	ldd	r24, Y+3	; 0x03
    1836:	61 e0       	ldi	r22, 0x01	; 1
    1838:	a9 01       	movw	r20, r18
    183a:	0e 94 61 09 	call	0x12c2	; 0x12c2 <MDIO_Error_State_GetPinValue>
			if(LOC_U8PinState==0)
			{
				/*Get the Value of the current pressed switch*/
				LOC_U8ReturnValue=KPD_u8SwitchVal[LOC_U8ColCount-COL_INIT][LOC_U8RowCount-ROW_INIT];
				/*wait until the switch is released(Single Press)*/
				while(LOC_U8PinState==0)
    183e:	8c 81       	ldd	r24, Y+4	; 0x04
    1840:	88 23       	and	r24, r24
    1842:	a9 f3       	breq	.-22     	; 0x182e <HKPD_U8GetKeyPressed+0x6e>
	for(LOC_U8ColCount=COL_INIT;LOC_U8ColCount<COL_END;LOC_U8ColCount++)
	{
		/*Active the Column */
		MDIO_Error_State_SetPinValue(LOC_U8ColCount,COL_PORT,PIN_LOW);
		/*Loop to read the all row pins*/
		for(LOC_U8RowCount=ROW_INIT;LOC_U8RowCount<ROW_END;LOC_U8RowCount++)
    1844:	8b 81       	ldd	r24, Y+3	; 0x03
    1846:	8f 5f       	subi	r24, 0xFF	; 255
    1848:	8b 83       	std	Y+3, r24	; 0x03
    184a:	8b 81       	ldd	r24, Y+3	; 0x03
    184c:	88 30       	cpi	r24, 0x08	; 8
    184e:	58 f2       	brcs	.-106    	; 0x17e6 <HKPD_U8GetKeyPressed+0x26>
			{
				/*Do Nothing*/
			}
		}
		/*Deactivate the Column*/
		MDIO_Error_State_SetPinValue(LOC_U8ColCount,COL_PORT,PIN_HIGH);
    1850:	8a 81       	ldd	r24, Y+2	; 0x02
    1852:	63 e0       	ldi	r22, 0x03	; 3
    1854:	41 e0       	ldi	r20, 0x01	; 1
    1856:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
	u8 LOC_U8ColCount;
	/*Initialize the switch status to NOT PRESSED*/
	u8 LOC_U8ReturnValue=NOT_PRESSED;
	u8 LOC_U8PinState;
	/*Looping on columns of the keypad*/
	for(LOC_U8ColCount=COL_INIT;LOC_U8ColCount<COL_END;LOC_U8ColCount++)
    185a:	8a 81       	ldd	r24, Y+2	; 0x02
    185c:	8f 5f       	subi	r24, 0xFF	; 255
    185e:	8a 83       	std	Y+2, r24	; 0x02
    1860:	8a 81       	ldd	r24, Y+2	; 0x02
    1862:	86 30       	cpi	r24, 0x06	; 6
    1864:	08 f4       	brcc	.+2      	; 0x1868 <HKPD_U8GetKeyPressed+0xa8>
    1866:	b7 cf       	rjmp	.-146    	; 0x17d6 <HKPD_U8GetKeyPressed+0x16>
			}
		}
		/*Deactivate the Column*/
		MDIO_Error_State_SetPinValue(LOC_U8ColCount,COL_PORT,PIN_HIGH);
	}
	return LOC_U8ReturnValue;
    1868:	89 81       	ldd	r24, Y+1	; 0x01
}
    186a:	0f 90       	pop	r0
    186c:	0f 90       	pop	r0
    186e:	0f 90       	pop	r0
    1870:	0f 90       	pop	r0
    1872:	cf 91       	pop	r28
    1874:	df 91       	pop	r29
    1876:	08 95       	ret

00001878 <HCLCD_VidWriteCommand_8Bits>:
#include"HCLCD_Interface.h"

#include"util/delay.h"

void HCLCD_VidWriteCommand_8Bits(u8 Copy_u8Command)
{
    1878:	df 93       	push	r29
    187a:	cf 93       	push	r28
    187c:	cd b7       	in	r28, 0x3d	; 61
    187e:	de b7       	in	r29, 0x3e	; 62
    1880:	6d 97       	sbiw	r28, 0x1d	; 29
    1882:	0f b6       	in	r0, 0x3f	; 63
    1884:	f8 94       	cli
    1886:	de bf       	out	0x3e, r29	; 62
    1888:	0f be       	out	0x3f, r0	; 63
    188a:	cd bf       	out	0x3d, r28	; 61
    188c:	8d 8f       	std	Y+29, r24	; 0x1d
	/*select Command register--> Write zero on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_LOW);
    188e:	81 e0       	ldi	r24, 0x01	; 1
    1890:	62 e0       	ldi	r22, 0x02	; 2
    1892:	40 e0       	ldi	r20, 0x00	; 0
    1894:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	//MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
	/*Send Command ON port Data*/
	MDIO_Error_State_SetPortValue(DATA_PORT,Copy_u8Command);
    1898:	82 e0       	ldi	r24, 0x02	; 2
    189a:	6d 8d       	ldd	r22, Y+29	; 0x1d
    189c:	0e 94 19 09 	call	0x1232	; 0x1232 <MDIO_Error_State_SetPortValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    18a0:	82 e0       	ldi	r24, 0x02	; 2
    18a2:	62 e0       	ldi	r22, 0x02	; 2
    18a4:	41 e0       	ldi	r20, 0x01	; 1
    18a6:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
    18aa:	80 e0       	ldi	r24, 0x00	; 0
    18ac:	90 e0       	ldi	r25, 0x00	; 0
    18ae:	a0 e0       	ldi	r26, 0x00	; 0
    18b0:	b0 e4       	ldi	r27, 0x40	; 64
    18b2:	89 8f       	std	Y+25, r24	; 0x19
    18b4:	9a 8f       	std	Y+26, r25	; 0x1a
    18b6:	ab 8f       	std	Y+27, r26	; 0x1b
    18b8:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    18ba:	69 8d       	ldd	r22, Y+25	; 0x19
    18bc:	7a 8d       	ldd	r23, Y+26	; 0x1a
    18be:	8b 8d       	ldd	r24, Y+27	; 0x1b
    18c0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    18c2:	20 e0       	ldi	r18, 0x00	; 0
    18c4:	30 e0       	ldi	r19, 0x00	; 0
    18c6:	4a ef       	ldi	r20, 0xFA	; 250
    18c8:	54 e4       	ldi	r21, 0x44	; 68
    18ca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    18ce:	dc 01       	movw	r26, r24
    18d0:	cb 01       	movw	r24, r22
    18d2:	8d 8b       	std	Y+21, r24	; 0x15
    18d4:	9e 8b       	std	Y+22, r25	; 0x16
    18d6:	af 8b       	std	Y+23, r26	; 0x17
    18d8:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    18da:	6d 89       	ldd	r22, Y+21	; 0x15
    18dc:	7e 89       	ldd	r23, Y+22	; 0x16
    18de:	8f 89       	ldd	r24, Y+23	; 0x17
    18e0:	98 8d       	ldd	r25, Y+24	; 0x18
    18e2:	20 e0       	ldi	r18, 0x00	; 0
    18e4:	30 e0       	ldi	r19, 0x00	; 0
    18e6:	40 e8       	ldi	r20, 0x80	; 128
    18e8:	5f e3       	ldi	r21, 0x3F	; 63
    18ea:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    18ee:	88 23       	and	r24, r24
    18f0:	2c f4       	brge	.+10     	; 0x18fc <HCLCD_VidWriteCommand_8Bits+0x84>
		__ticks = 1;
    18f2:	81 e0       	ldi	r24, 0x01	; 1
    18f4:	90 e0       	ldi	r25, 0x00	; 0
    18f6:	9c 8b       	std	Y+20, r25	; 0x14
    18f8:	8b 8b       	std	Y+19, r24	; 0x13
    18fa:	3f c0       	rjmp	.+126    	; 0x197a <HCLCD_VidWriteCommand_8Bits+0x102>
	else if (__tmp > 65535)
    18fc:	6d 89       	ldd	r22, Y+21	; 0x15
    18fe:	7e 89       	ldd	r23, Y+22	; 0x16
    1900:	8f 89       	ldd	r24, Y+23	; 0x17
    1902:	98 8d       	ldd	r25, Y+24	; 0x18
    1904:	20 e0       	ldi	r18, 0x00	; 0
    1906:	3f ef       	ldi	r19, 0xFF	; 255
    1908:	4f e7       	ldi	r20, 0x7F	; 127
    190a:	57 e4       	ldi	r21, 0x47	; 71
    190c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1910:	18 16       	cp	r1, r24
    1912:	4c f5       	brge	.+82     	; 0x1966 <HCLCD_VidWriteCommand_8Bits+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1914:	69 8d       	ldd	r22, Y+25	; 0x19
    1916:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1918:	8b 8d       	ldd	r24, Y+27	; 0x1b
    191a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    191c:	20 e0       	ldi	r18, 0x00	; 0
    191e:	30 e0       	ldi	r19, 0x00	; 0
    1920:	40 e2       	ldi	r20, 0x20	; 32
    1922:	51 e4       	ldi	r21, 0x41	; 65
    1924:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1928:	dc 01       	movw	r26, r24
    192a:	cb 01       	movw	r24, r22
    192c:	bc 01       	movw	r22, r24
    192e:	cd 01       	movw	r24, r26
    1930:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1934:	dc 01       	movw	r26, r24
    1936:	cb 01       	movw	r24, r22
    1938:	9c 8b       	std	Y+20, r25	; 0x14
    193a:	8b 8b       	std	Y+19, r24	; 0x13
    193c:	0f c0       	rjmp	.+30     	; 0x195c <HCLCD_VidWriteCommand_8Bits+0xe4>
    193e:	88 ec       	ldi	r24, 0xC8	; 200
    1940:	90 e0       	ldi	r25, 0x00	; 0
    1942:	9a 8b       	std	Y+18, r25	; 0x12
    1944:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1946:	89 89       	ldd	r24, Y+17	; 0x11
    1948:	9a 89       	ldd	r25, Y+18	; 0x12
    194a:	01 97       	sbiw	r24, 0x01	; 1
    194c:	f1 f7       	brne	.-4      	; 0x194a <HCLCD_VidWriteCommand_8Bits+0xd2>
    194e:	9a 8b       	std	Y+18, r25	; 0x12
    1950:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1952:	8b 89       	ldd	r24, Y+19	; 0x13
    1954:	9c 89       	ldd	r25, Y+20	; 0x14
    1956:	01 97       	sbiw	r24, 0x01	; 1
    1958:	9c 8b       	std	Y+20, r25	; 0x14
    195a:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    195c:	8b 89       	ldd	r24, Y+19	; 0x13
    195e:	9c 89       	ldd	r25, Y+20	; 0x14
    1960:	00 97       	sbiw	r24, 0x00	; 0
    1962:	69 f7       	brne	.-38     	; 0x193e <HCLCD_VidWriteCommand_8Bits+0xc6>
    1964:	14 c0       	rjmp	.+40     	; 0x198e <HCLCD_VidWriteCommand_8Bits+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1966:	6d 89       	ldd	r22, Y+21	; 0x15
    1968:	7e 89       	ldd	r23, Y+22	; 0x16
    196a:	8f 89       	ldd	r24, Y+23	; 0x17
    196c:	98 8d       	ldd	r25, Y+24	; 0x18
    196e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1972:	dc 01       	movw	r26, r24
    1974:	cb 01       	movw	r24, r22
    1976:	9c 8b       	std	Y+20, r25	; 0x14
    1978:	8b 8b       	std	Y+19, r24	; 0x13
    197a:	8b 89       	ldd	r24, Y+19	; 0x13
    197c:	9c 89       	ldd	r25, Y+20	; 0x14
    197e:	98 8b       	std	Y+16, r25	; 0x10
    1980:	8f 87       	std	Y+15, r24	; 0x0f
    1982:	8f 85       	ldd	r24, Y+15	; 0x0f
    1984:	98 89       	ldd	r25, Y+16	; 0x10
    1986:	01 97       	sbiw	r24, 0x01	; 1
    1988:	f1 f7       	brne	.-4      	; 0x1986 <HCLCD_VidWriteCommand_8Bits+0x10e>
    198a:	98 8b       	std	Y+16, r25	; 0x10
    198c:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    198e:	82 e0       	ldi	r24, 0x02	; 2
    1990:	62 e0       	ldi	r22, 0x02	; 2
    1992:	40 e0       	ldi	r20, 0x00	; 0
    1994:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
    1998:	80 e0       	ldi	r24, 0x00	; 0
    199a:	90 e0       	ldi	r25, 0x00	; 0
    199c:	a0 e0       	ldi	r26, 0x00	; 0
    199e:	b0 e4       	ldi	r27, 0x40	; 64
    19a0:	8b 87       	std	Y+11, r24	; 0x0b
    19a2:	9c 87       	std	Y+12, r25	; 0x0c
    19a4:	ad 87       	std	Y+13, r26	; 0x0d
    19a6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    19a8:	6b 85       	ldd	r22, Y+11	; 0x0b
    19aa:	7c 85       	ldd	r23, Y+12	; 0x0c
    19ac:	8d 85       	ldd	r24, Y+13	; 0x0d
    19ae:	9e 85       	ldd	r25, Y+14	; 0x0e
    19b0:	20 e0       	ldi	r18, 0x00	; 0
    19b2:	30 e0       	ldi	r19, 0x00	; 0
    19b4:	4a ef       	ldi	r20, 0xFA	; 250
    19b6:	54 e4       	ldi	r21, 0x44	; 68
    19b8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    19bc:	dc 01       	movw	r26, r24
    19be:	cb 01       	movw	r24, r22
    19c0:	8f 83       	std	Y+7, r24	; 0x07
    19c2:	98 87       	std	Y+8, r25	; 0x08
    19c4:	a9 87       	std	Y+9, r26	; 0x09
    19c6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    19c8:	6f 81       	ldd	r22, Y+7	; 0x07
    19ca:	78 85       	ldd	r23, Y+8	; 0x08
    19cc:	89 85       	ldd	r24, Y+9	; 0x09
    19ce:	9a 85       	ldd	r25, Y+10	; 0x0a
    19d0:	20 e0       	ldi	r18, 0x00	; 0
    19d2:	30 e0       	ldi	r19, 0x00	; 0
    19d4:	40 e8       	ldi	r20, 0x80	; 128
    19d6:	5f e3       	ldi	r21, 0x3F	; 63
    19d8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    19dc:	88 23       	and	r24, r24
    19de:	2c f4       	brge	.+10     	; 0x19ea <HCLCD_VidWriteCommand_8Bits+0x172>
		__ticks = 1;
    19e0:	81 e0       	ldi	r24, 0x01	; 1
    19e2:	90 e0       	ldi	r25, 0x00	; 0
    19e4:	9e 83       	std	Y+6, r25	; 0x06
    19e6:	8d 83       	std	Y+5, r24	; 0x05
    19e8:	3f c0       	rjmp	.+126    	; 0x1a68 <HCLCD_VidWriteCommand_8Bits+0x1f0>
	else if (__tmp > 65535)
    19ea:	6f 81       	ldd	r22, Y+7	; 0x07
    19ec:	78 85       	ldd	r23, Y+8	; 0x08
    19ee:	89 85       	ldd	r24, Y+9	; 0x09
    19f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    19f2:	20 e0       	ldi	r18, 0x00	; 0
    19f4:	3f ef       	ldi	r19, 0xFF	; 255
    19f6:	4f e7       	ldi	r20, 0x7F	; 127
    19f8:	57 e4       	ldi	r21, 0x47	; 71
    19fa:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    19fe:	18 16       	cp	r1, r24
    1a00:	4c f5       	brge	.+82     	; 0x1a54 <HCLCD_VidWriteCommand_8Bits+0x1dc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a02:	6b 85       	ldd	r22, Y+11	; 0x0b
    1a04:	7c 85       	ldd	r23, Y+12	; 0x0c
    1a06:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a08:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a0a:	20 e0       	ldi	r18, 0x00	; 0
    1a0c:	30 e0       	ldi	r19, 0x00	; 0
    1a0e:	40 e2       	ldi	r20, 0x20	; 32
    1a10:	51 e4       	ldi	r21, 0x41	; 65
    1a12:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a16:	dc 01       	movw	r26, r24
    1a18:	cb 01       	movw	r24, r22
    1a1a:	bc 01       	movw	r22, r24
    1a1c:	cd 01       	movw	r24, r26
    1a1e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a22:	dc 01       	movw	r26, r24
    1a24:	cb 01       	movw	r24, r22
    1a26:	9e 83       	std	Y+6, r25	; 0x06
    1a28:	8d 83       	std	Y+5, r24	; 0x05
    1a2a:	0f c0       	rjmp	.+30     	; 0x1a4a <HCLCD_VidWriteCommand_8Bits+0x1d2>
    1a2c:	88 ec       	ldi	r24, 0xC8	; 200
    1a2e:	90 e0       	ldi	r25, 0x00	; 0
    1a30:	9c 83       	std	Y+4, r25	; 0x04
    1a32:	8b 83       	std	Y+3, r24	; 0x03
    1a34:	8b 81       	ldd	r24, Y+3	; 0x03
    1a36:	9c 81       	ldd	r25, Y+4	; 0x04
    1a38:	01 97       	sbiw	r24, 0x01	; 1
    1a3a:	f1 f7       	brne	.-4      	; 0x1a38 <HCLCD_VidWriteCommand_8Bits+0x1c0>
    1a3c:	9c 83       	std	Y+4, r25	; 0x04
    1a3e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a40:	8d 81       	ldd	r24, Y+5	; 0x05
    1a42:	9e 81       	ldd	r25, Y+6	; 0x06
    1a44:	01 97       	sbiw	r24, 0x01	; 1
    1a46:	9e 83       	std	Y+6, r25	; 0x06
    1a48:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a4a:	8d 81       	ldd	r24, Y+5	; 0x05
    1a4c:	9e 81       	ldd	r25, Y+6	; 0x06
    1a4e:	00 97       	sbiw	r24, 0x00	; 0
    1a50:	69 f7       	brne	.-38     	; 0x1a2c <HCLCD_VidWriteCommand_8Bits+0x1b4>
    1a52:	14 c0       	rjmp	.+40     	; 0x1a7c <HCLCD_VidWriteCommand_8Bits+0x204>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1a54:	6f 81       	ldd	r22, Y+7	; 0x07
    1a56:	78 85       	ldd	r23, Y+8	; 0x08
    1a58:	89 85       	ldd	r24, Y+9	; 0x09
    1a5a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a5c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a60:	dc 01       	movw	r26, r24
    1a62:	cb 01       	movw	r24, r22
    1a64:	9e 83       	std	Y+6, r25	; 0x06
    1a66:	8d 83       	std	Y+5, r24	; 0x05
    1a68:	8d 81       	ldd	r24, Y+5	; 0x05
    1a6a:	9e 81       	ldd	r25, Y+6	; 0x06
    1a6c:	9a 83       	std	Y+2, r25	; 0x02
    1a6e:	89 83       	std	Y+1, r24	; 0x01
    1a70:	89 81       	ldd	r24, Y+1	; 0x01
    1a72:	9a 81       	ldd	r25, Y+2	; 0x02
    1a74:	01 97       	sbiw	r24, 0x01	; 1
    1a76:	f1 f7       	brne	.-4      	; 0x1a74 <HCLCD_VidWriteCommand_8Bits+0x1fc>
    1a78:	9a 83       	std	Y+2, r25	; 0x02
    1a7a:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);	
    1a7c:	82 e0       	ldi	r24, 0x02	; 2
    1a7e:	62 e0       	ldi	r22, 0x02	; 2
    1a80:	41 e0       	ldi	r20, 0x01	; 1
    1a82:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
}
    1a86:	6d 96       	adiw	r28, 0x1d	; 29
    1a88:	0f b6       	in	r0, 0x3f	; 63
    1a8a:	f8 94       	cli
    1a8c:	de bf       	out	0x3e, r29	; 62
    1a8e:	0f be       	out	0x3f, r0	; 63
    1a90:	cd bf       	out	0x3d, r28	; 61
    1a92:	cf 91       	pop	r28
    1a94:	df 91       	pop	r29
    1a96:	08 95       	ret

00001a98 <HCLCD_Vid8Bits_Init>:

void HCLCD_Vid8Bits_Init(void)
{
    1a98:	df 93       	push	r29
    1a9a:	cf 93       	push	r28
    1a9c:	cd b7       	in	r28, 0x3d	; 61
    1a9e:	de b7       	in	r29, 0x3e	; 62
    1aa0:	e8 97       	sbiw	r28, 0x38	; 56
    1aa2:	0f b6       	in	r0, 0x3f	; 63
    1aa4:	f8 94       	cli
    1aa6:	de bf       	out	0x3e, r29	; 62
    1aa8:	0f be       	out	0x3f, r0	; 63
    1aaa:	cd bf       	out	0x3d, r28	; 61
	/*LCD Data and control port intialization*/
	MDIO_Error_State_SetPortDirection(DATA_PORT,PORT_OUTPUT);
    1aac:	82 e0       	ldi	r24, 0x02	; 2
    1aae:	6f ef       	ldi	r22, 0xFF	; 255
    1ab0:	0e 94 c6 07 	call	0xf8c	; 0xf8c <MDIO_Error_State_SetPortDirection>
	MDIO_Error_State_SetPinDirection(RS,CONTROL_PORT,PIN_OUTPUT);
    1ab4:	81 e0       	ldi	r24, 0x01	; 1
    1ab6:	62 e0       	ldi	r22, 0x02	; 2
    1ab8:	41 e0       	ldi	r20, 0x01	; 1
    1aba:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>
	//MDIO_Error_State_SetPinDirection(RW,CONTROL_PORT,PIN_OUTPUT);
	MDIO_Error_State_SetPinDirection(E,CONTROL_PORT,PIN_OUTPUT);
    1abe:	82 e0       	ldi	r24, 0x02	; 2
    1ac0:	62 e0       	ldi	r22, 0x02	; 2
    1ac2:	41 e0       	ldi	r20, 0x01	; 1
    1ac4:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>
    1ac8:	80 e0       	ldi	r24, 0x00	; 0
    1aca:	90 e0       	ldi	r25, 0x00	; 0
    1acc:	a0 ef       	ldi	r26, 0xF0	; 240
    1ace:	b1 e4       	ldi	r27, 0x41	; 65
    1ad0:	8d ab       	std	Y+53, r24	; 0x35
    1ad2:	9e ab       	std	Y+54, r25	; 0x36
    1ad4:	af ab       	std	Y+55, r26	; 0x37
    1ad6:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1ad8:	6d a9       	ldd	r22, Y+53	; 0x35
    1ada:	7e a9       	ldd	r23, Y+54	; 0x36
    1adc:	8f a9       	ldd	r24, Y+55	; 0x37
    1ade:	98 ad       	ldd	r25, Y+56	; 0x38
    1ae0:	20 e0       	ldi	r18, 0x00	; 0
    1ae2:	30 e0       	ldi	r19, 0x00	; 0
    1ae4:	4a ef       	ldi	r20, 0xFA	; 250
    1ae6:	54 e4       	ldi	r21, 0x44	; 68
    1ae8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1aec:	dc 01       	movw	r26, r24
    1aee:	cb 01       	movw	r24, r22
    1af0:	89 ab       	std	Y+49, r24	; 0x31
    1af2:	9a ab       	std	Y+50, r25	; 0x32
    1af4:	ab ab       	std	Y+51, r26	; 0x33
    1af6:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    1af8:	69 a9       	ldd	r22, Y+49	; 0x31
    1afa:	7a a9       	ldd	r23, Y+50	; 0x32
    1afc:	8b a9       	ldd	r24, Y+51	; 0x33
    1afe:	9c a9       	ldd	r25, Y+52	; 0x34
    1b00:	20 e0       	ldi	r18, 0x00	; 0
    1b02:	30 e0       	ldi	r19, 0x00	; 0
    1b04:	40 e8       	ldi	r20, 0x80	; 128
    1b06:	5f e3       	ldi	r21, 0x3F	; 63
    1b08:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1b0c:	88 23       	and	r24, r24
    1b0e:	2c f4       	brge	.+10     	; 0x1b1a <HCLCD_Vid8Bits_Init+0x82>
		__ticks = 1;
    1b10:	81 e0       	ldi	r24, 0x01	; 1
    1b12:	90 e0       	ldi	r25, 0x00	; 0
    1b14:	98 ab       	std	Y+48, r25	; 0x30
    1b16:	8f a7       	std	Y+47, r24	; 0x2f
    1b18:	3f c0       	rjmp	.+126    	; 0x1b98 <HCLCD_Vid8Bits_Init+0x100>
	else if (__tmp > 65535)
    1b1a:	69 a9       	ldd	r22, Y+49	; 0x31
    1b1c:	7a a9       	ldd	r23, Y+50	; 0x32
    1b1e:	8b a9       	ldd	r24, Y+51	; 0x33
    1b20:	9c a9       	ldd	r25, Y+52	; 0x34
    1b22:	20 e0       	ldi	r18, 0x00	; 0
    1b24:	3f ef       	ldi	r19, 0xFF	; 255
    1b26:	4f e7       	ldi	r20, 0x7F	; 127
    1b28:	57 e4       	ldi	r21, 0x47	; 71
    1b2a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1b2e:	18 16       	cp	r1, r24
    1b30:	4c f5       	brge	.+82     	; 0x1b84 <HCLCD_Vid8Bits_Init+0xec>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1b32:	6d a9       	ldd	r22, Y+53	; 0x35
    1b34:	7e a9       	ldd	r23, Y+54	; 0x36
    1b36:	8f a9       	ldd	r24, Y+55	; 0x37
    1b38:	98 ad       	ldd	r25, Y+56	; 0x38
    1b3a:	20 e0       	ldi	r18, 0x00	; 0
    1b3c:	30 e0       	ldi	r19, 0x00	; 0
    1b3e:	40 e2       	ldi	r20, 0x20	; 32
    1b40:	51 e4       	ldi	r21, 0x41	; 65
    1b42:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b46:	dc 01       	movw	r26, r24
    1b48:	cb 01       	movw	r24, r22
    1b4a:	bc 01       	movw	r22, r24
    1b4c:	cd 01       	movw	r24, r26
    1b4e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1b52:	dc 01       	movw	r26, r24
    1b54:	cb 01       	movw	r24, r22
    1b56:	98 ab       	std	Y+48, r25	; 0x30
    1b58:	8f a7       	std	Y+47, r24	; 0x2f
    1b5a:	0f c0       	rjmp	.+30     	; 0x1b7a <HCLCD_Vid8Bits_Init+0xe2>
    1b5c:	88 ec       	ldi	r24, 0xC8	; 200
    1b5e:	90 e0       	ldi	r25, 0x00	; 0
    1b60:	9e a7       	std	Y+46, r25	; 0x2e
    1b62:	8d a7       	std	Y+45, r24	; 0x2d
    1b64:	8d a5       	ldd	r24, Y+45	; 0x2d
    1b66:	9e a5       	ldd	r25, Y+46	; 0x2e
    1b68:	01 97       	sbiw	r24, 0x01	; 1
    1b6a:	f1 f7       	brne	.-4      	; 0x1b68 <HCLCD_Vid8Bits_Init+0xd0>
    1b6c:	9e a7       	std	Y+46, r25	; 0x2e
    1b6e:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b70:	8f a5       	ldd	r24, Y+47	; 0x2f
    1b72:	98 a9       	ldd	r25, Y+48	; 0x30
    1b74:	01 97       	sbiw	r24, 0x01	; 1
    1b76:	98 ab       	std	Y+48, r25	; 0x30
    1b78:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b7a:	8f a5       	ldd	r24, Y+47	; 0x2f
    1b7c:	98 a9       	ldd	r25, Y+48	; 0x30
    1b7e:	00 97       	sbiw	r24, 0x00	; 0
    1b80:	69 f7       	brne	.-38     	; 0x1b5c <HCLCD_Vid8Bits_Init+0xc4>
    1b82:	14 c0       	rjmp	.+40     	; 0x1bac <HCLCD_Vid8Bits_Init+0x114>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1b84:	69 a9       	ldd	r22, Y+49	; 0x31
    1b86:	7a a9       	ldd	r23, Y+50	; 0x32
    1b88:	8b a9       	ldd	r24, Y+51	; 0x33
    1b8a:	9c a9       	ldd	r25, Y+52	; 0x34
    1b8c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1b90:	dc 01       	movw	r26, r24
    1b92:	cb 01       	movw	r24, r22
    1b94:	98 ab       	std	Y+48, r25	; 0x30
    1b96:	8f a7       	std	Y+47, r24	; 0x2f
    1b98:	8f a5       	ldd	r24, Y+47	; 0x2f
    1b9a:	98 a9       	ldd	r25, Y+48	; 0x30
    1b9c:	9c a7       	std	Y+44, r25	; 0x2c
    1b9e:	8b a7       	std	Y+43, r24	; 0x2b
    1ba0:	8b a5       	ldd	r24, Y+43	; 0x2b
    1ba2:	9c a5       	ldd	r25, Y+44	; 0x2c
    1ba4:	01 97       	sbiw	r24, 0x01	; 1
    1ba6:	f1 f7       	brne	.-4      	; 0x1ba4 <HCLCD_Vid8Bits_Init+0x10c>
    1ba8:	9c a7       	std	Y+44, r25	; 0x2c
    1baa:	8b a7       	std	Y+43, r24	; 0x2b

	/*wait to 30ms*/
	_delay_ms(30);
	/*send function set command*/
	HCLCD_VidWriteCommand_8Bits(HCLCD_FUNCTION_SET);
    1bac:	88 e2       	ldi	r24, 0x28	; 40
    1bae:	0e 94 3c 0c 	call	0x1878	; 0x1878 <HCLCD_VidWriteCommand_8Bits>
    1bb2:	80 e0       	ldi	r24, 0x00	; 0
    1bb4:	90 e0       	ldi	r25, 0x00	; 0
    1bb6:	a0 e8       	ldi	r26, 0x80	; 128
    1bb8:	bf e3       	ldi	r27, 0x3F	; 63
    1bba:	8f a3       	std	Y+39, r24	; 0x27
    1bbc:	98 a7       	std	Y+40, r25	; 0x28
    1bbe:	a9 a7       	std	Y+41, r26	; 0x29
    1bc0:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1bc2:	6f a1       	ldd	r22, Y+39	; 0x27
    1bc4:	78 a5       	ldd	r23, Y+40	; 0x28
    1bc6:	89 a5       	ldd	r24, Y+41	; 0x29
    1bc8:	9a a5       	ldd	r25, Y+42	; 0x2a
    1bca:	20 e0       	ldi	r18, 0x00	; 0
    1bcc:	30 e0       	ldi	r19, 0x00	; 0
    1bce:	4a ef       	ldi	r20, 0xFA	; 250
    1bd0:	54 e4       	ldi	r21, 0x44	; 68
    1bd2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1bd6:	dc 01       	movw	r26, r24
    1bd8:	cb 01       	movw	r24, r22
    1bda:	8b a3       	std	Y+35, r24	; 0x23
    1bdc:	9c a3       	std	Y+36, r25	; 0x24
    1bde:	ad a3       	std	Y+37, r26	; 0x25
    1be0:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1be2:	6b a1       	ldd	r22, Y+35	; 0x23
    1be4:	7c a1       	ldd	r23, Y+36	; 0x24
    1be6:	8d a1       	ldd	r24, Y+37	; 0x25
    1be8:	9e a1       	ldd	r25, Y+38	; 0x26
    1bea:	20 e0       	ldi	r18, 0x00	; 0
    1bec:	30 e0       	ldi	r19, 0x00	; 0
    1bee:	40 e8       	ldi	r20, 0x80	; 128
    1bf0:	5f e3       	ldi	r21, 0x3F	; 63
    1bf2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1bf6:	88 23       	and	r24, r24
    1bf8:	2c f4       	brge	.+10     	; 0x1c04 <HCLCD_Vid8Bits_Init+0x16c>
		__ticks = 1;
    1bfa:	81 e0       	ldi	r24, 0x01	; 1
    1bfc:	90 e0       	ldi	r25, 0x00	; 0
    1bfe:	9a a3       	std	Y+34, r25	; 0x22
    1c00:	89 a3       	std	Y+33, r24	; 0x21
    1c02:	3f c0       	rjmp	.+126    	; 0x1c82 <HCLCD_Vid8Bits_Init+0x1ea>
	else if (__tmp > 65535)
    1c04:	6b a1       	ldd	r22, Y+35	; 0x23
    1c06:	7c a1       	ldd	r23, Y+36	; 0x24
    1c08:	8d a1       	ldd	r24, Y+37	; 0x25
    1c0a:	9e a1       	ldd	r25, Y+38	; 0x26
    1c0c:	20 e0       	ldi	r18, 0x00	; 0
    1c0e:	3f ef       	ldi	r19, 0xFF	; 255
    1c10:	4f e7       	ldi	r20, 0x7F	; 127
    1c12:	57 e4       	ldi	r21, 0x47	; 71
    1c14:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1c18:	18 16       	cp	r1, r24
    1c1a:	4c f5       	brge	.+82     	; 0x1c6e <HCLCD_Vid8Bits_Init+0x1d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1c1c:	6f a1       	ldd	r22, Y+39	; 0x27
    1c1e:	78 a5       	ldd	r23, Y+40	; 0x28
    1c20:	89 a5       	ldd	r24, Y+41	; 0x29
    1c22:	9a a5       	ldd	r25, Y+42	; 0x2a
    1c24:	20 e0       	ldi	r18, 0x00	; 0
    1c26:	30 e0       	ldi	r19, 0x00	; 0
    1c28:	40 e2       	ldi	r20, 0x20	; 32
    1c2a:	51 e4       	ldi	r21, 0x41	; 65
    1c2c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c30:	dc 01       	movw	r26, r24
    1c32:	cb 01       	movw	r24, r22
    1c34:	bc 01       	movw	r22, r24
    1c36:	cd 01       	movw	r24, r26
    1c38:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c3c:	dc 01       	movw	r26, r24
    1c3e:	cb 01       	movw	r24, r22
    1c40:	9a a3       	std	Y+34, r25	; 0x22
    1c42:	89 a3       	std	Y+33, r24	; 0x21
    1c44:	0f c0       	rjmp	.+30     	; 0x1c64 <HCLCD_Vid8Bits_Init+0x1cc>
    1c46:	88 ec       	ldi	r24, 0xC8	; 200
    1c48:	90 e0       	ldi	r25, 0x00	; 0
    1c4a:	98 a3       	std	Y+32, r25	; 0x20
    1c4c:	8f 8f       	std	Y+31, r24	; 0x1f
    1c4e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1c50:	98 a1       	ldd	r25, Y+32	; 0x20
    1c52:	01 97       	sbiw	r24, 0x01	; 1
    1c54:	f1 f7       	brne	.-4      	; 0x1c52 <HCLCD_Vid8Bits_Init+0x1ba>
    1c56:	98 a3       	std	Y+32, r25	; 0x20
    1c58:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1c5a:	89 a1       	ldd	r24, Y+33	; 0x21
    1c5c:	9a a1       	ldd	r25, Y+34	; 0x22
    1c5e:	01 97       	sbiw	r24, 0x01	; 1
    1c60:	9a a3       	std	Y+34, r25	; 0x22
    1c62:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1c64:	89 a1       	ldd	r24, Y+33	; 0x21
    1c66:	9a a1       	ldd	r25, Y+34	; 0x22
    1c68:	00 97       	sbiw	r24, 0x00	; 0
    1c6a:	69 f7       	brne	.-38     	; 0x1c46 <HCLCD_Vid8Bits_Init+0x1ae>
    1c6c:	14 c0       	rjmp	.+40     	; 0x1c96 <HCLCD_Vid8Bits_Init+0x1fe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1c6e:	6b a1       	ldd	r22, Y+35	; 0x23
    1c70:	7c a1       	ldd	r23, Y+36	; 0x24
    1c72:	8d a1       	ldd	r24, Y+37	; 0x25
    1c74:	9e a1       	ldd	r25, Y+38	; 0x26
    1c76:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c7a:	dc 01       	movw	r26, r24
    1c7c:	cb 01       	movw	r24, r22
    1c7e:	9a a3       	std	Y+34, r25	; 0x22
    1c80:	89 a3       	std	Y+33, r24	; 0x21
    1c82:	89 a1       	ldd	r24, Y+33	; 0x21
    1c84:	9a a1       	ldd	r25, Y+34	; 0x22
    1c86:	9e 8f       	std	Y+30, r25	; 0x1e
    1c88:	8d 8f       	std	Y+29, r24	; 0x1d
    1c8a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1c8c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1c8e:	01 97       	sbiw	r24, 0x01	; 1
    1c90:	f1 f7       	brne	.-4      	; 0x1c8e <HCLCD_Vid8Bits_Init+0x1f6>
    1c92:	9e 8f       	std	Y+30, r25	; 0x1e
    1c94:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1);
	/*send Display on/off  command*/
	HCLCD_VidWriteCommand_8Bits(HCLCD_DISPLAY_ON_OFF);
    1c96:	8f e0       	ldi	r24, 0x0F	; 15
    1c98:	0e 94 3c 0c 	call	0x1878	; 0x1878 <HCLCD_VidWriteCommand_8Bits>
    1c9c:	80 e0       	ldi	r24, 0x00	; 0
    1c9e:	90 e0       	ldi	r25, 0x00	; 0
    1ca0:	a0 e8       	ldi	r26, 0x80	; 128
    1ca2:	bf e3       	ldi	r27, 0x3F	; 63
    1ca4:	89 8f       	std	Y+25, r24	; 0x19
    1ca6:	9a 8f       	std	Y+26, r25	; 0x1a
    1ca8:	ab 8f       	std	Y+27, r26	; 0x1b
    1caa:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1cac:	69 8d       	ldd	r22, Y+25	; 0x19
    1cae:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1cb0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1cb2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1cb4:	20 e0       	ldi	r18, 0x00	; 0
    1cb6:	30 e0       	ldi	r19, 0x00	; 0
    1cb8:	4a ef       	ldi	r20, 0xFA	; 250
    1cba:	54 e4       	ldi	r21, 0x44	; 68
    1cbc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1cc0:	dc 01       	movw	r26, r24
    1cc2:	cb 01       	movw	r24, r22
    1cc4:	8d 8b       	std	Y+21, r24	; 0x15
    1cc6:	9e 8b       	std	Y+22, r25	; 0x16
    1cc8:	af 8b       	std	Y+23, r26	; 0x17
    1cca:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1ccc:	6d 89       	ldd	r22, Y+21	; 0x15
    1cce:	7e 89       	ldd	r23, Y+22	; 0x16
    1cd0:	8f 89       	ldd	r24, Y+23	; 0x17
    1cd2:	98 8d       	ldd	r25, Y+24	; 0x18
    1cd4:	20 e0       	ldi	r18, 0x00	; 0
    1cd6:	30 e0       	ldi	r19, 0x00	; 0
    1cd8:	40 e8       	ldi	r20, 0x80	; 128
    1cda:	5f e3       	ldi	r21, 0x3F	; 63
    1cdc:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1ce0:	88 23       	and	r24, r24
    1ce2:	2c f4       	brge	.+10     	; 0x1cee <HCLCD_Vid8Bits_Init+0x256>
		__ticks = 1;
    1ce4:	81 e0       	ldi	r24, 0x01	; 1
    1ce6:	90 e0       	ldi	r25, 0x00	; 0
    1ce8:	9c 8b       	std	Y+20, r25	; 0x14
    1cea:	8b 8b       	std	Y+19, r24	; 0x13
    1cec:	3f c0       	rjmp	.+126    	; 0x1d6c <HCLCD_Vid8Bits_Init+0x2d4>
	else if (__tmp > 65535)
    1cee:	6d 89       	ldd	r22, Y+21	; 0x15
    1cf0:	7e 89       	ldd	r23, Y+22	; 0x16
    1cf2:	8f 89       	ldd	r24, Y+23	; 0x17
    1cf4:	98 8d       	ldd	r25, Y+24	; 0x18
    1cf6:	20 e0       	ldi	r18, 0x00	; 0
    1cf8:	3f ef       	ldi	r19, 0xFF	; 255
    1cfa:	4f e7       	ldi	r20, 0x7F	; 127
    1cfc:	57 e4       	ldi	r21, 0x47	; 71
    1cfe:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1d02:	18 16       	cp	r1, r24
    1d04:	4c f5       	brge	.+82     	; 0x1d58 <HCLCD_Vid8Bits_Init+0x2c0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1d06:	69 8d       	ldd	r22, Y+25	; 0x19
    1d08:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1d0a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1d0c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1d0e:	20 e0       	ldi	r18, 0x00	; 0
    1d10:	30 e0       	ldi	r19, 0x00	; 0
    1d12:	40 e2       	ldi	r20, 0x20	; 32
    1d14:	51 e4       	ldi	r21, 0x41	; 65
    1d16:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d1a:	dc 01       	movw	r26, r24
    1d1c:	cb 01       	movw	r24, r22
    1d1e:	bc 01       	movw	r22, r24
    1d20:	cd 01       	movw	r24, r26
    1d22:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d26:	dc 01       	movw	r26, r24
    1d28:	cb 01       	movw	r24, r22
    1d2a:	9c 8b       	std	Y+20, r25	; 0x14
    1d2c:	8b 8b       	std	Y+19, r24	; 0x13
    1d2e:	0f c0       	rjmp	.+30     	; 0x1d4e <HCLCD_Vid8Bits_Init+0x2b6>
    1d30:	88 ec       	ldi	r24, 0xC8	; 200
    1d32:	90 e0       	ldi	r25, 0x00	; 0
    1d34:	9a 8b       	std	Y+18, r25	; 0x12
    1d36:	89 8b       	std	Y+17, r24	; 0x11
    1d38:	89 89       	ldd	r24, Y+17	; 0x11
    1d3a:	9a 89       	ldd	r25, Y+18	; 0x12
    1d3c:	01 97       	sbiw	r24, 0x01	; 1
    1d3e:	f1 f7       	brne	.-4      	; 0x1d3c <HCLCD_Vid8Bits_Init+0x2a4>
    1d40:	9a 8b       	std	Y+18, r25	; 0x12
    1d42:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d44:	8b 89       	ldd	r24, Y+19	; 0x13
    1d46:	9c 89       	ldd	r25, Y+20	; 0x14
    1d48:	01 97       	sbiw	r24, 0x01	; 1
    1d4a:	9c 8b       	std	Y+20, r25	; 0x14
    1d4c:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d4e:	8b 89       	ldd	r24, Y+19	; 0x13
    1d50:	9c 89       	ldd	r25, Y+20	; 0x14
    1d52:	00 97       	sbiw	r24, 0x00	; 0
    1d54:	69 f7       	brne	.-38     	; 0x1d30 <HCLCD_Vid8Bits_Init+0x298>
    1d56:	14 c0       	rjmp	.+40     	; 0x1d80 <HCLCD_Vid8Bits_Init+0x2e8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1d58:	6d 89       	ldd	r22, Y+21	; 0x15
    1d5a:	7e 89       	ldd	r23, Y+22	; 0x16
    1d5c:	8f 89       	ldd	r24, Y+23	; 0x17
    1d5e:	98 8d       	ldd	r25, Y+24	; 0x18
    1d60:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d64:	dc 01       	movw	r26, r24
    1d66:	cb 01       	movw	r24, r22
    1d68:	9c 8b       	std	Y+20, r25	; 0x14
    1d6a:	8b 8b       	std	Y+19, r24	; 0x13
    1d6c:	8b 89       	ldd	r24, Y+19	; 0x13
    1d6e:	9c 89       	ldd	r25, Y+20	; 0x14
    1d70:	98 8b       	std	Y+16, r25	; 0x10
    1d72:	8f 87       	std	Y+15, r24	; 0x0f
    1d74:	8f 85       	ldd	r24, Y+15	; 0x0f
    1d76:	98 89       	ldd	r25, Y+16	; 0x10
    1d78:	01 97       	sbiw	r24, 0x01	; 1
    1d7a:	f1 f7       	brne	.-4      	; 0x1d78 <HCLCD_Vid8Bits_Init+0x2e0>
    1d7c:	98 8b       	std	Y+16, r25	; 0x10
    1d7e:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);
	/*send Display Clear  command*/
	HCLCD_VidWriteCommand_8Bits(DISPLAY_CLEAR);
    1d80:	81 e0       	ldi	r24, 0x01	; 1
    1d82:	0e 94 3c 0c 	call	0x1878	; 0x1878 <HCLCD_VidWriteCommand_8Bits>
    1d86:	80 e0       	ldi	r24, 0x00	; 0
    1d88:	90 e0       	ldi	r25, 0x00	; 0
    1d8a:	a0 e0       	ldi	r26, 0x00	; 0
    1d8c:	b0 e4       	ldi	r27, 0x40	; 64
    1d8e:	8b 87       	std	Y+11, r24	; 0x0b
    1d90:	9c 87       	std	Y+12, r25	; 0x0c
    1d92:	ad 87       	std	Y+13, r26	; 0x0d
    1d94:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1d96:	6b 85       	ldd	r22, Y+11	; 0x0b
    1d98:	7c 85       	ldd	r23, Y+12	; 0x0c
    1d9a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1d9c:	9e 85       	ldd	r25, Y+14	; 0x0e
    1d9e:	20 e0       	ldi	r18, 0x00	; 0
    1da0:	30 e0       	ldi	r19, 0x00	; 0
    1da2:	4a ef       	ldi	r20, 0xFA	; 250
    1da4:	54 e4       	ldi	r21, 0x44	; 68
    1da6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1daa:	dc 01       	movw	r26, r24
    1dac:	cb 01       	movw	r24, r22
    1dae:	8f 83       	std	Y+7, r24	; 0x07
    1db0:	98 87       	std	Y+8, r25	; 0x08
    1db2:	a9 87       	std	Y+9, r26	; 0x09
    1db4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1db6:	6f 81       	ldd	r22, Y+7	; 0x07
    1db8:	78 85       	ldd	r23, Y+8	; 0x08
    1dba:	89 85       	ldd	r24, Y+9	; 0x09
    1dbc:	9a 85       	ldd	r25, Y+10	; 0x0a
    1dbe:	20 e0       	ldi	r18, 0x00	; 0
    1dc0:	30 e0       	ldi	r19, 0x00	; 0
    1dc2:	40 e8       	ldi	r20, 0x80	; 128
    1dc4:	5f e3       	ldi	r21, 0x3F	; 63
    1dc6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1dca:	88 23       	and	r24, r24
    1dcc:	2c f4       	brge	.+10     	; 0x1dd8 <HCLCD_Vid8Bits_Init+0x340>
		__ticks = 1;
    1dce:	81 e0       	ldi	r24, 0x01	; 1
    1dd0:	90 e0       	ldi	r25, 0x00	; 0
    1dd2:	9e 83       	std	Y+6, r25	; 0x06
    1dd4:	8d 83       	std	Y+5, r24	; 0x05
    1dd6:	3f c0       	rjmp	.+126    	; 0x1e56 <HCLCD_Vid8Bits_Init+0x3be>
	else if (__tmp > 65535)
    1dd8:	6f 81       	ldd	r22, Y+7	; 0x07
    1dda:	78 85       	ldd	r23, Y+8	; 0x08
    1ddc:	89 85       	ldd	r24, Y+9	; 0x09
    1dde:	9a 85       	ldd	r25, Y+10	; 0x0a
    1de0:	20 e0       	ldi	r18, 0x00	; 0
    1de2:	3f ef       	ldi	r19, 0xFF	; 255
    1de4:	4f e7       	ldi	r20, 0x7F	; 127
    1de6:	57 e4       	ldi	r21, 0x47	; 71
    1de8:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1dec:	18 16       	cp	r1, r24
    1dee:	4c f5       	brge	.+82     	; 0x1e42 <HCLCD_Vid8Bits_Init+0x3aa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1df0:	6b 85       	ldd	r22, Y+11	; 0x0b
    1df2:	7c 85       	ldd	r23, Y+12	; 0x0c
    1df4:	8d 85       	ldd	r24, Y+13	; 0x0d
    1df6:	9e 85       	ldd	r25, Y+14	; 0x0e
    1df8:	20 e0       	ldi	r18, 0x00	; 0
    1dfa:	30 e0       	ldi	r19, 0x00	; 0
    1dfc:	40 e2       	ldi	r20, 0x20	; 32
    1dfe:	51 e4       	ldi	r21, 0x41	; 65
    1e00:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e04:	dc 01       	movw	r26, r24
    1e06:	cb 01       	movw	r24, r22
    1e08:	bc 01       	movw	r22, r24
    1e0a:	cd 01       	movw	r24, r26
    1e0c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e10:	dc 01       	movw	r26, r24
    1e12:	cb 01       	movw	r24, r22
    1e14:	9e 83       	std	Y+6, r25	; 0x06
    1e16:	8d 83       	std	Y+5, r24	; 0x05
    1e18:	0f c0       	rjmp	.+30     	; 0x1e38 <HCLCD_Vid8Bits_Init+0x3a0>
    1e1a:	88 ec       	ldi	r24, 0xC8	; 200
    1e1c:	90 e0       	ldi	r25, 0x00	; 0
    1e1e:	9c 83       	std	Y+4, r25	; 0x04
    1e20:	8b 83       	std	Y+3, r24	; 0x03
    1e22:	8b 81       	ldd	r24, Y+3	; 0x03
    1e24:	9c 81       	ldd	r25, Y+4	; 0x04
    1e26:	01 97       	sbiw	r24, 0x01	; 1
    1e28:	f1 f7       	brne	.-4      	; 0x1e26 <HCLCD_Vid8Bits_Init+0x38e>
    1e2a:	9c 83       	std	Y+4, r25	; 0x04
    1e2c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e2e:	8d 81       	ldd	r24, Y+5	; 0x05
    1e30:	9e 81       	ldd	r25, Y+6	; 0x06
    1e32:	01 97       	sbiw	r24, 0x01	; 1
    1e34:	9e 83       	std	Y+6, r25	; 0x06
    1e36:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e38:	8d 81       	ldd	r24, Y+5	; 0x05
    1e3a:	9e 81       	ldd	r25, Y+6	; 0x06
    1e3c:	00 97       	sbiw	r24, 0x00	; 0
    1e3e:	69 f7       	brne	.-38     	; 0x1e1a <HCLCD_Vid8Bits_Init+0x382>
    1e40:	14 c0       	rjmp	.+40     	; 0x1e6a <HCLCD_Vid8Bits_Init+0x3d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e42:	6f 81       	ldd	r22, Y+7	; 0x07
    1e44:	78 85       	ldd	r23, Y+8	; 0x08
    1e46:	89 85       	ldd	r24, Y+9	; 0x09
    1e48:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e4a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e4e:	dc 01       	movw	r26, r24
    1e50:	cb 01       	movw	r24, r22
    1e52:	9e 83       	std	Y+6, r25	; 0x06
    1e54:	8d 83       	std	Y+5, r24	; 0x05
    1e56:	8d 81       	ldd	r24, Y+5	; 0x05
    1e58:	9e 81       	ldd	r25, Y+6	; 0x06
    1e5a:	9a 83       	std	Y+2, r25	; 0x02
    1e5c:	89 83       	std	Y+1, r24	; 0x01
    1e5e:	89 81       	ldd	r24, Y+1	; 0x01
    1e60:	9a 81       	ldd	r25, Y+2	; 0x02
    1e62:	01 97       	sbiw	r24, 0x01	; 1
    1e64:	f1 f7       	brne	.-4      	; 0x1e62 <HCLCD_Vid8Bits_Init+0x3ca>
    1e66:	9a 83       	std	Y+2, r25	; 0x02
    1e68:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	/*send Entry Mode  set command*/
	HCLCD_VidWriteCommand_8Bits(HCLCD_ENTRY_MODE_SET);
    1e6a:	86 e0       	ldi	r24, 0x06	; 6
    1e6c:	0e 94 3c 0c 	call	0x1878	; 0x1878 <HCLCD_VidWriteCommand_8Bits>
}
    1e70:	e8 96       	adiw	r28, 0x38	; 56
    1e72:	0f b6       	in	r0, 0x3f	; 63
    1e74:	f8 94       	cli
    1e76:	de bf       	out	0x3e, r29	; 62
    1e78:	0f be       	out	0x3f, r0	; 63
    1e7a:	cd bf       	out	0x3d, r28	; 61
    1e7c:	cf 91       	pop	r28
    1e7e:	df 91       	pop	r29
    1e80:	08 95       	ret

00001e82 <HCLCD_VidWriteChar_8Bits>:
void HCLCD_VidWriteChar_8Bits(u8 Copy_u8Data)
{
    1e82:	df 93       	push	r29
    1e84:	cf 93       	push	r28
    1e86:	cd b7       	in	r28, 0x3d	; 61
    1e88:	de b7       	in	r29, 0x3e	; 62
    1e8a:	6d 97       	sbiw	r28, 0x1d	; 29
    1e8c:	0f b6       	in	r0, 0x3f	; 63
    1e8e:	f8 94       	cli
    1e90:	de bf       	out	0x3e, r29	; 62
    1e92:	0f be       	out	0x3f, r0	; 63
    1e94:	cd bf       	out	0x3d, r28	; 61
    1e96:	8d 8f       	std	Y+29, r24	; 0x1d
	/*select Data register--> Write one on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_HIGH);
    1e98:	81 e0       	ldi	r24, 0x01	; 1
    1e9a:	62 e0       	ldi	r22, 0x02	; 2
    1e9c:	41 e0       	ldi	r20, 0x01	; 1
    1e9e:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	//MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
	/*Send Command ON port Data*/
	MDIO_Error_State_SetPortValue(DATA_PORT,Copy_u8Data);
    1ea2:	82 e0       	ldi	r24, 0x02	; 2
    1ea4:	6d 8d       	ldd	r22, Y+29	; 0x1d
    1ea6:	0e 94 19 09 	call	0x1232	; 0x1232 <MDIO_Error_State_SetPortValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    1eaa:	82 e0       	ldi	r24, 0x02	; 2
    1eac:	62 e0       	ldi	r22, 0x02	; 2
    1eae:	41 e0       	ldi	r20, 0x01	; 1
    1eb0:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
    1eb4:	80 e0       	ldi	r24, 0x00	; 0
    1eb6:	90 e0       	ldi	r25, 0x00	; 0
    1eb8:	a0 e0       	ldi	r26, 0x00	; 0
    1eba:	b0 e4       	ldi	r27, 0x40	; 64
    1ebc:	89 8f       	std	Y+25, r24	; 0x19
    1ebe:	9a 8f       	std	Y+26, r25	; 0x1a
    1ec0:	ab 8f       	std	Y+27, r26	; 0x1b
    1ec2:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1ec4:	69 8d       	ldd	r22, Y+25	; 0x19
    1ec6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1ec8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1eca:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1ecc:	20 e0       	ldi	r18, 0x00	; 0
    1ece:	30 e0       	ldi	r19, 0x00	; 0
    1ed0:	4a ef       	ldi	r20, 0xFA	; 250
    1ed2:	54 e4       	ldi	r21, 0x44	; 68
    1ed4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ed8:	dc 01       	movw	r26, r24
    1eda:	cb 01       	movw	r24, r22
    1edc:	8d 8b       	std	Y+21, r24	; 0x15
    1ede:	9e 8b       	std	Y+22, r25	; 0x16
    1ee0:	af 8b       	std	Y+23, r26	; 0x17
    1ee2:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1ee4:	6d 89       	ldd	r22, Y+21	; 0x15
    1ee6:	7e 89       	ldd	r23, Y+22	; 0x16
    1ee8:	8f 89       	ldd	r24, Y+23	; 0x17
    1eea:	98 8d       	ldd	r25, Y+24	; 0x18
    1eec:	20 e0       	ldi	r18, 0x00	; 0
    1eee:	30 e0       	ldi	r19, 0x00	; 0
    1ef0:	40 e8       	ldi	r20, 0x80	; 128
    1ef2:	5f e3       	ldi	r21, 0x3F	; 63
    1ef4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1ef8:	88 23       	and	r24, r24
    1efa:	2c f4       	brge	.+10     	; 0x1f06 <HCLCD_VidWriteChar_8Bits+0x84>
		__ticks = 1;
    1efc:	81 e0       	ldi	r24, 0x01	; 1
    1efe:	90 e0       	ldi	r25, 0x00	; 0
    1f00:	9c 8b       	std	Y+20, r25	; 0x14
    1f02:	8b 8b       	std	Y+19, r24	; 0x13
    1f04:	3f c0       	rjmp	.+126    	; 0x1f84 <HCLCD_VidWriteChar_8Bits+0x102>
	else if (__tmp > 65535)
    1f06:	6d 89       	ldd	r22, Y+21	; 0x15
    1f08:	7e 89       	ldd	r23, Y+22	; 0x16
    1f0a:	8f 89       	ldd	r24, Y+23	; 0x17
    1f0c:	98 8d       	ldd	r25, Y+24	; 0x18
    1f0e:	20 e0       	ldi	r18, 0x00	; 0
    1f10:	3f ef       	ldi	r19, 0xFF	; 255
    1f12:	4f e7       	ldi	r20, 0x7F	; 127
    1f14:	57 e4       	ldi	r21, 0x47	; 71
    1f16:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1f1a:	18 16       	cp	r1, r24
    1f1c:	4c f5       	brge	.+82     	; 0x1f70 <HCLCD_VidWriteChar_8Bits+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1f1e:	69 8d       	ldd	r22, Y+25	; 0x19
    1f20:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1f22:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1f24:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1f26:	20 e0       	ldi	r18, 0x00	; 0
    1f28:	30 e0       	ldi	r19, 0x00	; 0
    1f2a:	40 e2       	ldi	r20, 0x20	; 32
    1f2c:	51 e4       	ldi	r21, 0x41	; 65
    1f2e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f32:	dc 01       	movw	r26, r24
    1f34:	cb 01       	movw	r24, r22
    1f36:	bc 01       	movw	r22, r24
    1f38:	cd 01       	movw	r24, r26
    1f3a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f3e:	dc 01       	movw	r26, r24
    1f40:	cb 01       	movw	r24, r22
    1f42:	9c 8b       	std	Y+20, r25	; 0x14
    1f44:	8b 8b       	std	Y+19, r24	; 0x13
    1f46:	0f c0       	rjmp	.+30     	; 0x1f66 <HCLCD_VidWriteChar_8Bits+0xe4>
    1f48:	88 ec       	ldi	r24, 0xC8	; 200
    1f4a:	90 e0       	ldi	r25, 0x00	; 0
    1f4c:	9a 8b       	std	Y+18, r25	; 0x12
    1f4e:	89 8b       	std	Y+17, r24	; 0x11
    1f50:	89 89       	ldd	r24, Y+17	; 0x11
    1f52:	9a 89       	ldd	r25, Y+18	; 0x12
    1f54:	01 97       	sbiw	r24, 0x01	; 1
    1f56:	f1 f7       	brne	.-4      	; 0x1f54 <HCLCD_VidWriteChar_8Bits+0xd2>
    1f58:	9a 8b       	std	Y+18, r25	; 0x12
    1f5a:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f5c:	8b 89       	ldd	r24, Y+19	; 0x13
    1f5e:	9c 89       	ldd	r25, Y+20	; 0x14
    1f60:	01 97       	sbiw	r24, 0x01	; 1
    1f62:	9c 8b       	std	Y+20, r25	; 0x14
    1f64:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1f66:	8b 89       	ldd	r24, Y+19	; 0x13
    1f68:	9c 89       	ldd	r25, Y+20	; 0x14
    1f6a:	00 97       	sbiw	r24, 0x00	; 0
    1f6c:	69 f7       	brne	.-38     	; 0x1f48 <HCLCD_VidWriteChar_8Bits+0xc6>
    1f6e:	14 c0       	rjmp	.+40     	; 0x1f98 <HCLCD_VidWriteChar_8Bits+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1f70:	6d 89       	ldd	r22, Y+21	; 0x15
    1f72:	7e 89       	ldd	r23, Y+22	; 0x16
    1f74:	8f 89       	ldd	r24, Y+23	; 0x17
    1f76:	98 8d       	ldd	r25, Y+24	; 0x18
    1f78:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f7c:	dc 01       	movw	r26, r24
    1f7e:	cb 01       	movw	r24, r22
    1f80:	9c 8b       	std	Y+20, r25	; 0x14
    1f82:	8b 8b       	std	Y+19, r24	; 0x13
    1f84:	8b 89       	ldd	r24, Y+19	; 0x13
    1f86:	9c 89       	ldd	r25, Y+20	; 0x14
    1f88:	98 8b       	std	Y+16, r25	; 0x10
    1f8a:	8f 87       	std	Y+15, r24	; 0x0f
    1f8c:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f8e:	98 89       	ldd	r25, Y+16	; 0x10
    1f90:	01 97       	sbiw	r24, 0x01	; 1
    1f92:	f1 f7       	brne	.-4      	; 0x1f90 <HCLCD_VidWriteChar_8Bits+0x10e>
    1f94:	98 8b       	std	Y+16, r25	; 0x10
    1f96:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    1f98:	82 e0       	ldi	r24, 0x02	; 2
    1f9a:	62 e0       	ldi	r22, 0x02	; 2
    1f9c:	40 e0       	ldi	r20, 0x00	; 0
    1f9e:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
    1fa2:	80 e0       	ldi	r24, 0x00	; 0
    1fa4:	90 e0       	ldi	r25, 0x00	; 0
    1fa6:	a0 e0       	ldi	r26, 0x00	; 0
    1fa8:	b0 e4       	ldi	r27, 0x40	; 64
    1faa:	8b 87       	std	Y+11, r24	; 0x0b
    1fac:	9c 87       	std	Y+12, r25	; 0x0c
    1fae:	ad 87       	std	Y+13, r26	; 0x0d
    1fb0:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1fb2:	6b 85       	ldd	r22, Y+11	; 0x0b
    1fb4:	7c 85       	ldd	r23, Y+12	; 0x0c
    1fb6:	8d 85       	ldd	r24, Y+13	; 0x0d
    1fb8:	9e 85       	ldd	r25, Y+14	; 0x0e
    1fba:	20 e0       	ldi	r18, 0x00	; 0
    1fbc:	30 e0       	ldi	r19, 0x00	; 0
    1fbe:	4a ef       	ldi	r20, 0xFA	; 250
    1fc0:	54 e4       	ldi	r21, 0x44	; 68
    1fc2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1fc6:	dc 01       	movw	r26, r24
    1fc8:	cb 01       	movw	r24, r22
    1fca:	8f 83       	std	Y+7, r24	; 0x07
    1fcc:	98 87       	std	Y+8, r25	; 0x08
    1fce:	a9 87       	std	Y+9, r26	; 0x09
    1fd0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1fd2:	6f 81       	ldd	r22, Y+7	; 0x07
    1fd4:	78 85       	ldd	r23, Y+8	; 0x08
    1fd6:	89 85       	ldd	r24, Y+9	; 0x09
    1fd8:	9a 85       	ldd	r25, Y+10	; 0x0a
    1fda:	20 e0       	ldi	r18, 0x00	; 0
    1fdc:	30 e0       	ldi	r19, 0x00	; 0
    1fde:	40 e8       	ldi	r20, 0x80	; 128
    1fe0:	5f e3       	ldi	r21, 0x3F	; 63
    1fe2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1fe6:	88 23       	and	r24, r24
    1fe8:	2c f4       	brge	.+10     	; 0x1ff4 <HCLCD_VidWriteChar_8Bits+0x172>
		__ticks = 1;
    1fea:	81 e0       	ldi	r24, 0x01	; 1
    1fec:	90 e0       	ldi	r25, 0x00	; 0
    1fee:	9e 83       	std	Y+6, r25	; 0x06
    1ff0:	8d 83       	std	Y+5, r24	; 0x05
    1ff2:	3f c0       	rjmp	.+126    	; 0x2072 <HCLCD_VidWriteChar_8Bits+0x1f0>
	else if (__tmp > 65535)
    1ff4:	6f 81       	ldd	r22, Y+7	; 0x07
    1ff6:	78 85       	ldd	r23, Y+8	; 0x08
    1ff8:	89 85       	ldd	r24, Y+9	; 0x09
    1ffa:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ffc:	20 e0       	ldi	r18, 0x00	; 0
    1ffe:	3f ef       	ldi	r19, 0xFF	; 255
    2000:	4f e7       	ldi	r20, 0x7F	; 127
    2002:	57 e4       	ldi	r21, 0x47	; 71
    2004:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2008:	18 16       	cp	r1, r24
    200a:	4c f5       	brge	.+82     	; 0x205e <HCLCD_VidWriteChar_8Bits+0x1dc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    200c:	6b 85       	ldd	r22, Y+11	; 0x0b
    200e:	7c 85       	ldd	r23, Y+12	; 0x0c
    2010:	8d 85       	ldd	r24, Y+13	; 0x0d
    2012:	9e 85       	ldd	r25, Y+14	; 0x0e
    2014:	20 e0       	ldi	r18, 0x00	; 0
    2016:	30 e0       	ldi	r19, 0x00	; 0
    2018:	40 e2       	ldi	r20, 0x20	; 32
    201a:	51 e4       	ldi	r21, 0x41	; 65
    201c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2020:	dc 01       	movw	r26, r24
    2022:	cb 01       	movw	r24, r22
    2024:	bc 01       	movw	r22, r24
    2026:	cd 01       	movw	r24, r26
    2028:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    202c:	dc 01       	movw	r26, r24
    202e:	cb 01       	movw	r24, r22
    2030:	9e 83       	std	Y+6, r25	; 0x06
    2032:	8d 83       	std	Y+5, r24	; 0x05
    2034:	0f c0       	rjmp	.+30     	; 0x2054 <HCLCD_VidWriteChar_8Bits+0x1d2>
    2036:	88 ec       	ldi	r24, 0xC8	; 200
    2038:	90 e0       	ldi	r25, 0x00	; 0
    203a:	9c 83       	std	Y+4, r25	; 0x04
    203c:	8b 83       	std	Y+3, r24	; 0x03
    203e:	8b 81       	ldd	r24, Y+3	; 0x03
    2040:	9c 81       	ldd	r25, Y+4	; 0x04
    2042:	01 97       	sbiw	r24, 0x01	; 1
    2044:	f1 f7       	brne	.-4      	; 0x2042 <HCLCD_VidWriteChar_8Bits+0x1c0>
    2046:	9c 83       	std	Y+4, r25	; 0x04
    2048:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    204a:	8d 81       	ldd	r24, Y+5	; 0x05
    204c:	9e 81       	ldd	r25, Y+6	; 0x06
    204e:	01 97       	sbiw	r24, 0x01	; 1
    2050:	9e 83       	std	Y+6, r25	; 0x06
    2052:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2054:	8d 81       	ldd	r24, Y+5	; 0x05
    2056:	9e 81       	ldd	r25, Y+6	; 0x06
    2058:	00 97       	sbiw	r24, 0x00	; 0
    205a:	69 f7       	brne	.-38     	; 0x2036 <HCLCD_VidWriteChar_8Bits+0x1b4>
    205c:	14 c0       	rjmp	.+40     	; 0x2086 <HCLCD_VidWriteChar_8Bits+0x204>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    205e:	6f 81       	ldd	r22, Y+7	; 0x07
    2060:	78 85       	ldd	r23, Y+8	; 0x08
    2062:	89 85       	ldd	r24, Y+9	; 0x09
    2064:	9a 85       	ldd	r25, Y+10	; 0x0a
    2066:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    206a:	dc 01       	movw	r26, r24
    206c:	cb 01       	movw	r24, r22
    206e:	9e 83       	std	Y+6, r25	; 0x06
    2070:	8d 83       	std	Y+5, r24	; 0x05
    2072:	8d 81       	ldd	r24, Y+5	; 0x05
    2074:	9e 81       	ldd	r25, Y+6	; 0x06
    2076:	9a 83       	std	Y+2, r25	; 0x02
    2078:	89 83       	std	Y+1, r24	; 0x01
    207a:	89 81       	ldd	r24, Y+1	; 0x01
    207c:	9a 81       	ldd	r25, Y+2	; 0x02
    207e:	01 97       	sbiw	r24, 0x01	; 1
    2080:	f1 f7       	brne	.-4      	; 0x207e <HCLCD_VidWriteChar_8Bits+0x1fc>
    2082:	9a 83       	std	Y+2, r25	; 0x02
    2084:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);	
    2086:	82 e0       	ldi	r24, 0x02	; 2
    2088:	62 e0       	ldi	r22, 0x02	; 2
    208a:	41 e0       	ldi	r20, 0x01	; 1
    208c:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
}
    2090:	6d 96       	adiw	r28, 0x1d	; 29
    2092:	0f b6       	in	r0, 0x3f	; 63
    2094:	f8 94       	cli
    2096:	de bf       	out	0x3e, r29	; 62
    2098:	0f be       	out	0x3f, r0	; 63
    209a:	cd bf       	out	0x3d, r28	; 61
    209c:	cf 91       	pop	r28
    209e:	df 91       	pop	r29
    20a0:	08 95       	ret

000020a2 <HCLCD_VidWriteString_8Bits>:

void HCLCD_VidWriteString_8Bits(u8* PCopy_u8String)
{
    20a2:	df 93       	push	r29
    20a4:	cf 93       	push	r28
    20a6:	00 d0       	rcall	.+0      	; 0x20a8 <HCLCD_VidWriteString_8Bits+0x6>
    20a8:	0f 92       	push	r0
    20aa:	cd b7       	in	r28, 0x3d	; 61
    20ac:	de b7       	in	r29, 0x3e	; 62
    20ae:	9b 83       	std	Y+3, r25	; 0x03
    20b0:	8a 83       	std	Y+2, r24	; 0x02
	u8 Loc_u8Count=0;
    20b2:	19 82       	std	Y+1, r1	; 0x01
    20b4:	0e c0       	rjmp	.+28     	; 0x20d2 <HCLCD_VidWriteString_8Bits+0x30>
	while(PCopy_u8String[Loc_u8Count]!=NULL)
	{
		HCLCD_VidWriteChar_8Bits(PCopy_u8String[Loc_u8Count]);
    20b6:	89 81       	ldd	r24, Y+1	; 0x01
    20b8:	28 2f       	mov	r18, r24
    20ba:	30 e0       	ldi	r19, 0x00	; 0
    20bc:	8a 81       	ldd	r24, Y+2	; 0x02
    20be:	9b 81       	ldd	r25, Y+3	; 0x03
    20c0:	fc 01       	movw	r30, r24
    20c2:	e2 0f       	add	r30, r18
    20c4:	f3 1f       	adc	r31, r19
    20c6:	80 81       	ld	r24, Z
    20c8:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <HCLCD_VidWriteChar_8Bits>
		Loc_u8Count++;
    20cc:	89 81       	ldd	r24, Y+1	; 0x01
    20ce:	8f 5f       	subi	r24, 0xFF	; 255
    20d0:	89 83       	std	Y+1, r24	; 0x01
}

void HCLCD_VidWriteString_8Bits(u8* PCopy_u8String)
{
	u8 Loc_u8Count=0;
	while(PCopy_u8String[Loc_u8Count]!=NULL)
    20d2:	89 81       	ldd	r24, Y+1	; 0x01
    20d4:	28 2f       	mov	r18, r24
    20d6:	30 e0       	ldi	r19, 0x00	; 0
    20d8:	8a 81       	ldd	r24, Y+2	; 0x02
    20da:	9b 81       	ldd	r25, Y+3	; 0x03
    20dc:	fc 01       	movw	r30, r24
    20de:	e2 0f       	add	r30, r18
    20e0:	f3 1f       	adc	r31, r19
    20e2:	80 81       	ld	r24, Z
    20e4:	88 23       	and	r24, r24
    20e6:	39 f7       	brne	.-50     	; 0x20b6 <HCLCD_VidWriteString_8Bits+0x14>
	{
		HCLCD_VidWriteChar_8Bits(PCopy_u8String[Loc_u8Count]);
		Loc_u8Count++;
	}
}
    20e8:	0f 90       	pop	r0
    20ea:	0f 90       	pop	r0
    20ec:	0f 90       	pop	r0
    20ee:	cf 91       	pop	r28
    20f0:	df 91       	pop	r29
    20f2:	08 95       	ret

000020f4 <HCLCD_VidWriteNumber_8Bits>:
void HCLCD_VidWriteNumber_8Bits(u32 Copy_u8Number)
{
    20f4:	0f 93       	push	r16
    20f6:	1f 93       	push	r17
    20f8:	df 93       	push	r29
    20fa:	cf 93       	push	r28
    20fc:	cd b7       	in	r28, 0x3d	; 61
    20fe:	de b7       	in	r29, 0x3e	; 62
    2100:	60 97       	sbiw	r28, 0x10	; 16
    2102:	0f b6       	in	r0, 0x3f	; 63
    2104:	f8 94       	cli
    2106:	de bf       	out	0x3e, r29	; 62
    2108:	0f be       	out	0x3f, r0	; 63
    210a:	cd bf       	out	0x3d, r28	; 61
    210c:	6d 87       	std	Y+13, r22	; 0x0d
    210e:	7e 87       	std	Y+14, r23	; 0x0e
    2110:	8f 87       	std	Y+15, r24	; 0x0f
    2112:	98 8b       	std	Y+16, r25	; 0x10
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
    2114:	1a 82       	std	Y+2, r1	; 0x02
	if(Copy_u8Number>0)
    2116:	8d 85       	ldd	r24, Y+13	; 0x0d
    2118:	9e 85       	ldd	r25, Y+14	; 0x0e
    211a:	af 85       	ldd	r26, Y+15	; 0x0f
    211c:	b8 89       	ldd	r27, Y+16	; 0x10
    211e:	00 97       	sbiw	r24, 0x00	; 0
    2120:	a1 05       	cpc	r26, r1
    2122:	b1 05       	cpc	r27, r1
    2124:	09 f4       	brne	.+2      	; 0x2128 <HCLCD_VidWriteNumber_8Bits+0x34>
    2126:	4f c0       	rjmp	.+158    	; 0x21c6 <HCLCD_VidWriteNumber_8Bits+0xd2>
    2128:	2d c0       	rjmp	.+90     	; 0x2184 <HCLCD_VidWriteNumber_8Bits+0x90>
	{
		while(Copy_u8Number!=0)
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
    212a:	8a 81       	ldd	r24, Y+2	; 0x02
    212c:	08 2f       	mov	r16, r24
    212e:	10 e0       	ldi	r17, 0x00	; 0
    2130:	8d 85       	ldd	r24, Y+13	; 0x0d
    2132:	9e 85       	ldd	r25, Y+14	; 0x0e
    2134:	af 85       	ldd	r26, Y+15	; 0x0f
    2136:	b8 89       	ldd	r27, Y+16	; 0x10
    2138:	2a e0       	ldi	r18, 0x0A	; 10
    213a:	30 e0       	ldi	r19, 0x00	; 0
    213c:	40 e0       	ldi	r20, 0x00	; 0
    213e:	50 e0       	ldi	r21, 0x00	; 0
    2140:	bc 01       	movw	r22, r24
    2142:	cd 01       	movw	r24, r26
    2144:	0e 94 8a 2e 	call	0x5d14	; 0x5d14 <__udivmodsi4>
    2148:	dc 01       	movw	r26, r24
    214a:	cb 01       	movw	r24, r22
    214c:	28 2f       	mov	r18, r24
    214e:	ce 01       	movw	r24, r28
    2150:	03 96       	adiw	r24, 0x03	; 3
    2152:	fc 01       	movw	r30, r24
    2154:	e0 0f       	add	r30, r16
    2156:	f1 1f       	adc	r31, r17
    2158:	20 83       	st	Z, r18
			Copy_u8Number/=10;
    215a:	8d 85       	ldd	r24, Y+13	; 0x0d
    215c:	9e 85       	ldd	r25, Y+14	; 0x0e
    215e:	af 85       	ldd	r26, Y+15	; 0x0f
    2160:	b8 89       	ldd	r27, Y+16	; 0x10
    2162:	2a e0       	ldi	r18, 0x0A	; 10
    2164:	30 e0       	ldi	r19, 0x00	; 0
    2166:	40 e0       	ldi	r20, 0x00	; 0
    2168:	50 e0       	ldi	r21, 0x00	; 0
    216a:	bc 01       	movw	r22, r24
    216c:	cd 01       	movw	r24, r26
    216e:	0e 94 8a 2e 	call	0x5d14	; 0x5d14 <__udivmodsi4>
    2172:	da 01       	movw	r26, r20
    2174:	c9 01       	movw	r24, r18
    2176:	8d 87       	std	Y+13, r24	; 0x0d
    2178:	9e 87       	std	Y+14, r25	; 0x0e
    217a:	af 87       	std	Y+15, r26	; 0x0f
    217c:	b8 8b       	std	Y+16, r27	; 0x10
			LOC_Count++;
    217e:	8a 81       	ldd	r24, Y+2	; 0x02
    2180:	8f 5f       	subi	r24, 0xFF	; 255
    2182:	8a 83       	std	Y+2, r24	; 0x02
{
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
	if(Copy_u8Number>0)
	{
		while(Copy_u8Number!=0)
    2184:	8d 85       	ldd	r24, Y+13	; 0x0d
    2186:	9e 85       	ldd	r25, Y+14	; 0x0e
    2188:	af 85       	ldd	r26, Y+15	; 0x0f
    218a:	b8 89       	ldd	r27, Y+16	; 0x10
    218c:	00 97       	sbiw	r24, 0x00	; 0
    218e:	a1 05       	cpc	r26, r1
    2190:	b1 05       	cpc	r27, r1
    2192:	59 f6       	brne	.-106    	; 0x212a <HCLCD_VidWriteNumber_8Bits+0x36>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    2194:	8a 81       	ldd	r24, Y+2	; 0x02
    2196:	81 50       	subi	r24, 0x01	; 1
    2198:	89 83       	std	Y+1, r24	; 0x01
    219a:	11 c0       	rjmp	.+34     	; 0x21be <HCLCD_VidWriteNumber_8Bits+0xca>
		{
			HCLCD_VidWriteChar_8Bits(ARR_Digits[i]+'0');
    219c:	89 81       	ldd	r24, Y+1	; 0x01
    219e:	28 2f       	mov	r18, r24
    21a0:	33 27       	eor	r19, r19
    21a2:	27 fd       	sbrc	r18, 7
    21a4:	30 95       	com	r19
    21a6:	ce 01       	movw	r24, r28
    21a8:	03 96       	adiw	r24, 0x03	; 3
    21aa:	fc 01       	movw	r30, r24
    21ac:	e2 0f       	add	r30, r18
    21ae:	f3 1f       	adc	r31, r19
    21b0:	80 81       	ld	r24, Z
    21b2:	80 5d       	subi	r24, 0xD0	; 208
    21b4:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <HCLCD_VidWriteChar_8Bits>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    21b8:	89 81       	ldd	r24, Y+1	; 0x01
    21ba:	81 50       	subi	r24, 0x01	; 1
    21bc:	89 83       	std	Y+1, r24	; 0x01
    21be:	89 81       	ldd	r24, Y+1	; 0x01
    21c0:	88 23       	and	r24, r24
    21c2:	64 f7       	brge	.-40     	; 0x219c <HCLCD_VidWriteNumber_8Bits+0xa8>
    21c4:	03 c0       	rjmp	.+6      	; 0x21cc <HCLCD_VidWriteNumber_8Bits+0xd8>
			HCLCD_VidWriteChar_8Bits(ARR_Digits[i]+'0');
		}
	}
	else
	{
		HCLCD_VidWriteChar_8Bits('0');
    21c6:	80 e3       	ldi	r24, 0x30	; 48
    21c8:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <HCLCD_VidWriteChar_8Bits>
	}
}
    21cc:	60 96       	adiw	r28, 0x10	; 16
    21ce:	0f b6       	in	r0, 0x3f	; 63
    21d0:	f8 94       	cli
    21d2:	de bf       	out	0x3e, r29	; 62
    21d4:	0f be       	out	0x3f, r0	; 63
    21d6:	cd bf       	out	0x3d, r28	; 61
    21d8:	cf 91       	pop	r28
    21da:	df 91       	pop	r29
    21dc:	1f 91       	pop	r17
    21de:	0f 91       	pop	r16
    21e0:	08 95       	ret

000021e2 <HCLCD_VidSetPosition>:
void HCLCD_VidSetPosition(u8 Copy_u8LineNumber , u8 Copy_u8PositionNumber)
{
    21e2:	df 93       	push	r29
    21e4:	cf 93       	push	r28
    21e6:	00 d0       	rcall	.+0      	; 0x21e8 <HCLCD_VidSetPosition+0x6>
    21e8:	cd b7       	in	r28, 0x3d	; 61
    21ea:	de b7       	in	r29, 0x3e	; 62
    21ec:	89 83       	std	Y+1, r24	; 0x01
    21ee:	6a 83       	std	Y+2, r22	; 0x02
	if((Copy_u8LineNumber==HCLCD_LINE1)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    21f0:	89 81       	ldd	r24, Y+1	; 0x01
    21f2:	81 30       	cpi	r24, 0x01	; 1
    21f4:	41 f4       	brne	.+16     	; 0x2206 <HCLCD_VidSetPosition+0x24>
    21f6:	8a 81       	ldd	r24, Y+2	; 0x02
    21f8:	80 31       	cpi	r24, 0x10	; 16
    21fa:	28 f4       	brcc	.+10     	; 0x2206 <HCLCD_VidSetPosition+0x24>
	{
		HCLCD_VidWriteCommand_8Bits((LINE1_OFFSET_ADDRESS+Copy_u8PositionNumber));
    21fc:	8a 81       	ldd	r24, Y+2	; 0x02
    21fe:	80 58       	subi	r24, 0x80	; 128
    2200:	0e 94 3c 0c 	call	0x1878	; 0x1878 <HCLCD_VidWriteCommand_8Bits>
    2204:	0a c0       	rjmp	.+20     	; 0x221a <HCLCD_VidSetPosition+0x38>
	}
	else if((Copy_u8LineNumber==HCLCD_LINE2)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    2206:	89 81       	ldd	r24, Y+1	; 0x01
    2208:	82 30       	cpi	r24, 0x02	; 2
    220a:	39 f4       	brne	.+14     	; 0x221a <HCLCD_VidSetPosition+0x38>
    220c:	8a 81       	ldd	r24, Y+2	; 0x02
    220e:	80 31       	cpi	r24, 0x10	; 16
    2210:	20 f4       	brcc	.+8      	; 0x221a <HCLCD_VidSetPosition+0x38>
	{
		HCLCD_VidWriteCommand_8Bits((LINE2_OFFSET_ADDRESS+Copy_u8PositionNumber));
    2212:	8a 81       	ldd	r24, Y+2	; 0x02
    2214:	80 54       	subi	r24, 0x40	; 64
    2216:	0e 94 3c 0c 	call	0x1878	; 0x1878 <HCLCD_VidWriteCommand_8Bits>
	}
	else
	{
		/*Do Nothing*/
	}
}
    221a:	0f 90       	pop	r0
    221c:	0f 90       	pop	r0
    221e:	cf 91       	pop	r28
    2220:	df 91       	pop	r29
    2222:	08 95       	ret

00002224 <HCLCD_VidWriteCommand_4Bits>:

void HCLCD_VidWriteCommand_4Bits(u8 Copy_u8Command)
{
    2224:	df 93       	push	r29
    2226:	cf 93       	push	r28
    2228:	cd b7       	in	r28, 0x3d	; 61
    222a:	de b7       	in	r29, 0x3e	; 62
    222c:	60 97       	sbiw	r28, 0x10	; 16
    222e:	0f b6       	in	r0, 0x3f	; 63
    2230:	f8 94       	cli
    2232:	de bf       	out	0x3e, r29	; 62
    2234:	0f be       	out	0x3f, r0	; 63
    2236:	cd bf       	out	0x3d, r28	; 61
    2238:	88 8b       	std	Y+16, r24	; 0x10
	u8 LOC_u8CopyCommand;
	/*select Command register--> Write zero on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_LOW);
    223a:	81 e0       	ldi	r24, 0x01	; 1
    223c:	62 e0       	ldi	r22, 0x02	; 2
    223e:	40 e0       	ldi	r20, 0x00	; 0
    2240:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	//MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
	/*Send  Command*/
	LOC_u8CopyCommand=(Copy_u8Command&0x0F)<<HCLCD_PINSTART;
    2244:	88 89       	ldd	r24, Y+16	; 0x10
    2246:	8f 70       	andi	r24, 0x0F	; 15
    2248:	88 0f       	add	r24, r24
    224a:	88 0f       	add	r24, r24
    224c:	88 0f       	add	r24, r24
    224e:	8f 87       	std	Y+15, r24	; 0x0f
	MDIO_Error_State_SetNippleValue(HCLCD_PINSTART,DATA_PORT,LOC_u8CopyCommand);
    2250:	83 e0       	ldi	r24, 0x03	; 3
    2252:	62 e0       	ldi	r22, 0x02	; 2
    2254:	4f 85       	ldd	r20, Y+15	; 0x0f
    2256:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <MDIO_Error_State_SetNippleValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    225a:	82 e0       	ldi	r24, 0x02	; 2
    225c:	62 e0       	ldi	r22, 0x02	; 2
    225e:	41 e0       	ldi	r20, 0x01	; 1
    2260:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
    2264:	80 e0       	ldi	r24, 0x00	; 0
    2266:	90 e0       	ldi	r25, 0x00	; 0
    2268:	a0 e0       	ldi	r26, 0x00	; 0
    226a:	b0 e4       	ldi	r27, 0x40	; 64
    226c:	8b 87       	std	Y+11, r24	; 0x0b
    226e:	9c 87       	std	Y+12, r25	; 0x0c
    2270:	ad 87       	std	Y+13, r26	; 0x0d
    2272:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2274:	6b 85       	ldd	r22, Y+11	; 0x0b
    2276:	7c 85       	ldd	r23, Y+12	; 0x0c
    2278:	8d 85       	ldd	r24, Y+13	; 0x0d
    227a:	9e 85       	ldd	r25, Y+14	; 0x0e
    227c:	20 e0       	ldi	r18, 0x00	; 0
    227e:	30 e0       	ldi	r19, 0x00	; 0
    2280:	4a ef       	ldi	r20, 0xFA	; 250
    2282:	54 e4       	ldi	r21, 0x44	; 68
    2284:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2288:	dc 01       	movw	r26, r24
    228a:	cb 01       	movw	r24, r22
    228c:	8f 83       	std	Y+7, r24	; 0x07
    228e:	98 87       	std	Y+8, r25	; 0x08
    2290:	a9 87       	std	Y+9, r26	; 0x09
    2292:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2294:	6f 81       	ldd	r22, Y+7	; 0x07
    2296:	78 85       	ldd	r23, Y+8	; 0x08
    2298:	89 85       	ldd	r24, Y+9	; 0x09
    229a:	9a 85       	ldd	r25, Y+10	; 0x0a
    229c:	20 e0       	ldi	r18, 0x00	; 0
    229e:	30 e0       	ldi	r19, 0x00	; 0
    22a0:	40 e8       	ldi	r20, 0x80	; 128
    22a2:	5f e3       	ldi	r21, 0x3F	; 63
    22a4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    22a8:	88 23       	and	r24, r24
    22aa:	2c f4       	brge	.+10     	; 0x22b6 <HCLCD_VidWriteCommand_4Bits+0x92>
		__ticks = 1;
    22ac:	81 e0       	ldi	r24, 0x01	; 1
    22ae:	90 e0       	ldi	r25, 0x00	; 0
    22b0:	9e 83       	std	Y+6, r25	; 0x06
    22b2:	8d 83       	std	Y+5, r24	; 0x05
    22b4:	3f c0       	rjmp	.+126    	; 0x2334 <HCLCD_VidWriteCommand_4Bits+0x110>
	else if (__tmp > 65535)
    22b6:	6f 81       	ldd	r22, Y+7	; 0x07
    22b8:	78 85       	ldd	r23, Y+8	; 0x08
    22ba:	89 85       	ldd	r24, Y+9	; 0x09
    22bc:	9a 85       	ldd	r25, Y+10	; 0x0a
    22be:	20 e0       	ldi	r18, 0x00	; 0
    22c0:	3f ef       	ldi	r19, 0xFF	; 255
    22c2:	4f e7       	ldi	r20, 0x7F	; 127
    22c4:	57 e4       	ldi	r21, 0x47	; 71
    22c6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    22ca:	18 16       	cp	r1, r24
    22cc:	4c f5       	brge	.+82     	; 0x2320 <HCLCD_VidWriteCommand_4Bits+0xfc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    22ce:	6b 85       	ldd	r22, Y+11	; 0x0b
    22d0:	7c 85       	ldd	r23, Y+12	; 0x0c
    22d2:	8d 85       	ldd	r24, Y+13	; 0x0d
    22d4:	9e 85       	ldd	r25, Y+14	; 0x0e
    22d6:	20 e0       	ldi	r18, 0x00	; 0
    22d8:	30 e0       	ldi	r19, 0x00	; 0
    22da:	40 e2       	ldi	r20, 0x20	; 32
    22dc:	51 e4       	ldi	r21, 0x41	; 65
    22de:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    22e2:	dc 01       	movw	r26, r24
    22e4:	cb 01       	movw	r24, r22
    22e6:	bc 01       	movw	r22, r24
    22e8:	cd 01       	movw	r24, r26
    22ea:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    22ee:	dc 01       	movw	r26, r24
    22f0:	cb 01       	movw	r24, r22
    22f2:	9e 83       	std	Y+6, r25	; 0x06
    22f4:	8d 83       	std	Y+5, r24	; 0x05
    22f6:	0f c0       	rjmp	.+30     	; 0x2316 <HCLCD_VidWriteCommand_4Bits+0xf2>
    22f8:	88 ec       	ldi	r24, 0xC8	; 200
    22fa:	90 e0       	ldi	r25, 0x00	; 0
    22fc:	9c 83       	std	Y+4, r25	; 0x04
    22fe:	8b 83       	std	Y+3, r24	; 0x03
    2300:	8b 81       	ldd	r24, Y+3	; 0x03
    2302:	9c 81       	ldd	r25, Y+4	; 0x04
    2304:	01 97       	sbiw	r24, 0x01	; 1
    2306:	f1 f7       	brne	.-4      	; 0x2304 <HCLCD_VidWriteCommand_4Bits+0xe0>
    2308:	9c 83       	std	Y+4, r25	; 0x04
    230a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    230c:	8d 81       	ldd	r24, Y+5	; 0x05
    230e:	9e 81       	ldd	r25, Y+6	; 0x06
    2310:	01 97       	sbiw	r24, 0x01	; 1
    2312:	9e 83       	std	Y+6, r25	; 0x06
    2314:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2316:	8d 81       	ldd	r24, Y+5	; 0x05
    2318:	9e 81       	ldd	r25, Y+6	; 0x06
    231a:	00 97       	sbiw	r24, 0x00	; 0
    231c:	69 f7       	brne	.-38     	; 0x22f8 <HCLCD_VidWriteCommand_4Bits+0xd4>
    231e:	14 c0       	rjmp	.+40     	; 0x2348 <HCLCD_VidWriteCommand_4Bits+0x124>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2320:	6f 81       	ldd	r22, Y+7	; 0x07
    2322:	78 85       	ldd	r23, Y+8	; 0x08
    2324:	89 85       	ldd	r24, Y+9	; 0x09
    2326:	9a 85       	ldd	r25, Y+10	; 0x0a
    2328:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    232c:	dc 01       	movw	r26, r24
    232e:	cb 01       	movw	r24, r22
    2330:	9e 83       	std	Y+6, r25	; 0x06
    2332:	8d 83       	std	Y+5, r24	; 0x05
    2334:	8d 81       	ldd	r24, Y+5	; 0x05
    2336:	9e 81       	ldd	r25, Y+6	; 0x06
    2338:	9a 83       	std	Y+2, r25	; 0x02
    233a:	89 83       	std	Y+1, r24	; 0x01
    233c:	89 81       	ldd	r24, Y+1	; 0x01
    233e:	9a 81       	ldd	r25, Y+2	; 0x02
    2340:	01 97       	sbiw	r24, 0x01	; 1
    2342:	f1 f7       	brne	.-4      	; 0x2340 <HCLCD_VidWriteCommand_4Bits+0x11c>
    2344:	9a 83       	std	Y+2, r25	; 0x02
    2346:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    2348:	82 e0       	ldi	r24, 0x02	; 2
    234a:	62 e0       	ldi	r22, 0x02	; 2
    234c:	40 e0       	ldi	r20, 0x00	; 0
    234e:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
}
    2352:	60 96       	adiw	r28, 0x10	; 16
    2354:	0f b6       	in	r0, 0x3f	; 63
    2356:	f8 94       	cli
    2358:	de bf       	out	0x3e, r29	; 62
    235a:	0f be       	out	0x3f, r0	; 63
    235c:	cd bf       	out	0x3d, r28	; 61
    235e:	cf 91       	pop	r28
    2360:	df 91       	pop	r29
    2362:	08 95       	ret

00002364 <HCLCD_Vid4Bits_Init>:
void HCLCD_Vid4Bits_Init(void)
{
    2364:	df 93       	push	r29
    2366:	cf 93       	push	r28
    2368:	cd b7       	in	r28, 0x3d	; 61
    236a:	de b7       	in	r29, 0x3e	; 62
    236c:	e9 97       	sbiw	r28, 0x39	; 57
    236e:	0f b6       	in	r0, 0x3f	; 63
    2370:	f8 94       	cli
    2372:	de bf       	out	0x3e, r29	; 62
    2374:	0f be       	out	0x3f, r0	; 63
    2376:	cd bf       	out	0x3d, r28	; 61
	s8 LOC_u8PinCount;
	/*LCD Data and control port initialization*/
	for(LOC_u8PinCount=HCLCD_PINEND;LOC_u8PinCount>=HCLCD_PINSTART;LOC_u8PinCount--)
    2378:	86 e0       	ldi	r24, 0x06	; 6
    237a:	89 af       	std	Y+57, r24	; 0x39
    237c:	08 c0       	rjmp	.+16     	; 0x238e <HCLCD_Vid4Bits_Init+0x2a>
	{
	MDIO_Error_State_SetPinDirection(LOC_u8PinCount,DATA_PORT,PIN_OUTPUT);
    237e:	89 ad       	ldd	r24, Y+57	; 0x39
    2380:	62 e0       	ldi	r22, 0x02	; 2
    2382:	41 e0       	ldi	r20, 0x01	; 1
    2384:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>
}
void HCLCD_Vid4Bits_Init(void)
{
	s8 LOC_u8PinCount;
	/*LCD Data and control port initialization*/
	for(LOC_u8PinCount=HCLCD_PINEND;LOC_u8PinCount>=HCLCD_PINSTART;LOC_u8PinCount--)
    2388:	89 ad       	ldd	r24, Y+57	; 0x39
    238a:	81 50       	subi	r24, 0x01	; 1
    238c:	89 af       	std	Y+57, r24	; 0x39
    238e:	89 ad       	ldd	r24, Y+57	; 0x39
    2390:	83 30       	cpi	r24, 0x03	; 3
    2392:	ac f7       	brge	.-22     	; 0x237e <HCLCD_Vid4Bits_Init+0x1a>
	{
	MDIO_Error_State_SetPinDirection(LOC_u8PinCount,DATA_PORT,PIN_OUTPUT);
	}
	MDIO_Error_State_SetPinDirection(RS,CONTROL_PORT,PIN_OUTPUT);
    2394:	81 e0       	ldi	r24, 0x01	; 1
    2396:	62 e0       	ldi	r22, 0x02	; 2
    2398:	41 e0       	ldi	r20, 0x01	; 1
    239a:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>
	//MDIO_Error_State_SetPinDirection(RW,CONTROL_PORT,PIN_OUTPUT);
	MDIO_Error_State_SetPinDirection(E,CONTROL_PORT,PIN_OUTPUT);
    239e:	82 e0       	ldi	r24, 0x02	; 2
    23a0:	62 e0       	ldi	r22, 0x02	; 2
    23a2:	41 e0       	ldi	r20, 0x01	; 1
    23a4:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>
    23a8:	80 e0       	ldi	r24, 0x00	; 0
    23aa:	90 e0       	ldi	r25, 0x00	; 0
    23ac:	a0 ef       	ldi	r26, 0xF0	; 240
    23ae:	b1 e4       	ldi	r27, 0x41	; 65
    23b0:	8d ab       	std	Y+53, r24	; 0x35
    23b2:	9e ab       	std	Y+54, r25	; 0x36
    23b4:	af ab       	std	Y+55, r26	; 0x37
    23b6:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    23b8:	6d a9       	ldd	r22, Y+53	; 0x35
    23ba:	7e a9       	ldd	r23, Y+54	; 0x36
    23bc:	8f a9       	ldd	r24, Y+55	; 0x37
    23be:	98 ad       	ldd	r25, Y+56	; 0x38
    23c0:	20 e0       	ldi	r18, 0x00	; 0
    23c2:	30 e0       	ldi	r19, 0x00	; 0
    23c4:	4a ef       	ldi	r20, 0xFA	; 250
    23c6:	54 e4       	ldi	r21, 0x44	; 68
    23c8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    23cc:	dc 01       	movw	r26, r24
    23ce:	cb 01       	movw	r24, r22
    23d0:	89 ab       	std	Y+49, r24	; 0x31
    23d2:	9a ab       	std	Y+50, r25	; 0x32
    23d4:	ab ab       	std	Y+51, r26	; 0x33
    23d6:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    23d8:	69 a9       	ldd	r22, Y+49	; 0x31
    23da:	7a a9       	ldd	r23, Y+50	; 0x32
    23dc:	8b a9       	ldd	r24, Y+51	; 0x33
    23de:	9c a9       	ldd	r25, Y+52	; 0x34
    23e0:	20 e0       	ldi	r18, 0x00	; 0
    23e2:	30 e0       	ldi	r19, 0x00	; 0
    23e4:	40 e8       	ldi	r20, 0x80	; 128
    23e6:	5f e3       	ldi	r21, 0x3F	; 63
    23e8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    23ec:	88 23       	and	r24, r24
    23ee:	2c f4       	brge	.+10     	; 0x23fa <HCLCD_Vid4Bits_Init+0x96>
		__ticks = 1;
    23f0:	81 e0       	ldi	r24, 0x01	; 1
    23f2:	90 e0       	ldi	r25, 0x00	; 0
    23f4:	98 ab       	std	Y+48, r25	; 0x30
    23f6:	8f a7       	std	Y+47, r24	; 0x2f
    23f8:	3f c0       	rjmp	.+126    	; 0x2478 <HCLCD_Vid4Bits_Init+0x114>
	else if (__tmp > 65535)
    23fa:	69 a9       	ldd	r22, Y+49	; 0x31
    23fc:	7a a9       	ldd	r23, Y+50	; 0x32
    23fe:	8b a9       	ldd	r24, Y+51	; 0x33
    2400:	9c a9       	ldd	r25, Y+52	; 0x34
    2402:	20 e0       	ldi	r18, 0x00	; 0
    2404:	3f ef       	ldi	r19, 0xFF	; 255
    2406:	4f e7       	ldi	r20, 0x7F	; 127
    2408:	57 e4       	ldi	r21, 0x47	; 71
    240a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    240e:	18 16       	cp	r1, r24
    2410:	4c f5       	brge	.+82     	; 0x2464 <HCLCD_Vid4Bits_Init+0x100>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2412:	6d a9       	ldd	r22, Y+53	; 0x35
    2414:	7e a9       	ldd	r23, Y+54	; 0x36
    2416:	8f a9       	ldd	r24, Y+55	; 0x37
    2418:	98 ad       	ldd	r25, Y+56	; 0x38
    241a:	20 e0       	ldi	r18, 0x00	; 0
    241c:	30 e0       	ldi	r19, 0x00	; 0
    241e:	40 e2       	ldi	r20, 0x20	; 32
    2420:	51 e4       	ldi	r21, 0x41	; 65
    2422:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2426:	dc 01       	movw	r26, r24
    2428:	cb 01       	movw	r24, r22
    242a:	bc 01       	movw	r22, r24
    242c:	cd 01       	movw	r24, r26
    242e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2432:	dc 01       	movw	r26, r24
    2434:	cb 01       	movw	r24, r22
    2436:	98 ab       	std	Y+48, r25	; 0x30
    2438:	8f a7       	std	Y+47, r24	; 0x2f
    243a:	0f c0       	rjmp	.+30     	; 0x245a <HCLCD_Vid4Bits_Init+0xf6>
    243c:	88 ec       	ldi	r24, 0xC8	; 200
    243e:	90 e0       	ldi	r25, 0x00	; 0
    2440:	9e a7       	std	Y+46, r25	; 0x2e
    2442:	8d a7       	std	Y+45, r24	; 0x2d
    2444:	8d a5       	ldd	r24, Y+45	; 0x2d
    2446:	9e a5       	ldd	r25, Y+46	; 0x2e
    2448:	01 97       	sbiw	r24, 0x01	; 1
    244a:	f1 f7       	brne	.-4      	; 0x2448 <HCLCD_Vid4Bits_Init+0xe4>
    244c:	9e a7       	std	Y+46, r25	; 0x2e
    244e:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2450:	8f a5       	ldd	r24, Y+47	; 0x2f
    2452:	98 a9       	ldd	r25, Y+48	; 0x30
    2454:	01 97       	sbiw	r24, 0x01	; 1
    2456:	98 ab       	std	Y+48, r25	; 0x30
    2458:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    245a:	8f a5       	ldd	r24, Y+47	; 0x2f
    245c:	98 a9       	ldd	r25, Y+48	; 0x30
    245e:	00 97       	sbiw	r24, 0x00	; 0
    2460:	69 f7       	brne	.-38     	; 0x243c <HCLCD_Vid4Bits_Init+0xd8>
    2462:	14 c0       	rjmp	.+40     	; 0x248c <HCLCD_Vid4Bits_Init+0x128>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2464:	69 a9       	ldd	r22, Y+49	; 0x31
    2466:	7a a9       	ldd	r23, Y+50	; 0x32
    2468:	8b a9       	ldd	r24, Y+51	; 0x33
    246a:	9c a9       	ldd	r25, Y+52	; 0x34
    246c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2470:	dc 01       	movw	r26, r24
    2472:	cb 01       	movw	r24, r22
    2474:	98 ab       	std	Y+48, r25	; 0x30
    2476:	8f a7       	std	Y+47, r24	; 0x2f
    2478:	8f a5       	ldd	r24, Y+47	; 0x2f
    247a:	98 a9       	ldd	r25, Y+48	; 0x30
    247c:	9c a7       	std	Y+44, r25	; 0x2c
    247e:	8b a7       	std	Y+43, r24	; 0x2b
    2480:	8b a5       	ldd	r24, Y+43	; 0x2b
    2482:	9c a5       	ldd	r25, Y+44	; 0x2c
    2484:	01 97       	sbiw	r24, 0x01	; 1
    2486:	f1 f7       	brne	.-4      	; 0x2484 <HCLCD_Vid4Bits_Init+0x120>
    2488:	9c a7       	std	Y+44, r25	; 0x2c
    248a:	8b a7       	std	Y+43, r24	; 0x2b
	/*wait to 30ms*/
	_delay_ms(30);
	/*send function set command*/
	HCLCD_VidWriteCommand_4Bits(HCLCD_FUNCTION_SET>>4);
    248c:	82 e0       	ldi	r24, 0x02	; 2
    248e:	0e 94 12 11 	call	0x2224	; 0x2224 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_FUNCTION_SET>>4);
    2492:	82 e0       	ldi	r24, 0x02	; 2
    2494:	0e 94 12 11 	call	0x2224	; 0x2224 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_FUNCTION_SET);
    2498:	88 e2       	ldi	r24, 0x28	; 40
    249a:	0e 94 12 11 	call	0x2224	; 0x2224 <HCLCD_VidWriteCommand_4Bits>
    249e:	80 e0       	ldi	r24, 0x00	; 0
    24a0:	90 e0       	ldi	r25, 0x00	; 0
    24a2:	a0 e8       	ldi	r26, 0x80	; 128
    24a4:	bf e3       	ldi	r27, 0x3F	; 63
    24a6:	8f a3       	std	Y+39, r24	; 0x27
    24a8:	98 a7       	std	Y+40, r25	; 0x28
    24aa:	a9 a7       	std	Y+41, r26	; 0x29
    24ac:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    24ae:	6f a1       	ldd	r22, Y+39	; 0x27
    24b0:	78 a5       	ldd	r23, Y+40	; 0x28
    24b2:	89 a5       	ldd	r24, Y+41	; 0x29
    24b4:	9a a5       	ldd	r25, Y+42	; 0x2a
    24b6:	20 e0       	ldi	r18, 0x00	; 0
    24b8:	30 e0       	ldi	r19, 0x00	; 0
    24ba:	4a ef       	ldi	r20, 0xFA	; 250
    24bc:	54 e4       	ldi	r21, 0x44	; 68
    24be:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    24c2:	dc 01       	movw	r26, r24
    24c4:	cb 01       	movw	r24, r22
    24c6:	8b a3       	std	Y+35, r24	; 0x23
    24c8:	9c a3       	std	Y+36, r25	; 0x24
    24ca:	ad a3       	std	Y+37, r26	; 0x25
    24cc:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    24ce:	6b a1       	ldd	r22, Y+35	; 0x23
    24d0:	7c a1       	ldd	r23, Y+36	; 0x24
    24d2:	8d a1       	ldd	r24, Y+37	; 0x25
    24d4:	9e a1       	ldd	r25, Y+38	; 0x26
    24d6:	20 e0       	ldi	r18, 0x00	; 0
    24d8:	30 e0       	ldi	r19, 0x00	; 0
    24da:	40 e8       	ldi	r20, 0x80	; 128
    24dc:	5f e3       	ldi	r21, 0x3F	; 63
    24de:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    24e2:	88 23       	and	r24, r24
    24e4:	2c f4       	brge	.+10     	; 0x24f0 <HCLCD_Vid4Bits_Init+0x18c>
		__ticks = 1;
    24e6:	81 e0       	ldi	r24, 0x01	; 1
    24e8:	90 e0       	ldi	r25, 0x00	; 0
    24ea:	9a a3       	std	Y+34, r25	; 0x22
    24ec:	89 a3       	std	Y+33, r24	; 0x21
    24ee:	3f c0       	rjmp	.+126    	; 0x256e <HCLCD_Vid4Bits_Init+0x20a>
	else if (__tmp > 65535)
    24f0:	6b a1       	ldd	r22, Y+35	; 0x23
    24f2:	7c a1       	ldd	r23, Y+36	; 0x24
    24f4:	8d a1       	ldd	r24, Y+37	; 0x25
    24f6:	9e a1       	ldd	r25, Y+38	; 0x26
    24f8:	20 e0       	ldi	r18, 0x00	; 0
    24fa:	3f ef       	ldi	r19, 0xFF	; 255
    24fc:	4f e7       	ldi	r20, 0x7F	; 127
    24fe:	57 e4       	ldi	r21, 0x47	; 71
    2500:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2504:	18 16       	cp	r1, r24
    2506:	4c f5       	brge	.+82     	; 0x255a <HCLCD_Vid4Bits_Init+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2508:	6f a1       	ldd	r22, Y+39	; 0x27
    250a:	78 a5       	ldd	r23, Y+40	; 0x28
    250c:	89 a5       	ldd	r24, Y+41	; 0x29
    250e:	9a a5       	ldd	r25, Y+42	; 0x2a
    2510:	20 e0       	ldi	r18, 0x00	; 0
    2512:	30 e0       	ldi	r19, 0x00	; 0
    2514:	40 e2       	ldi	r20, 0x20	; 32
    2516:	51 e4       	ldi	r21, 0x41	; 65
    2518:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    251c:	dc 01       	movw	r26, r24
    251e:	cb 01       	movw	r24, r22
    2520:	bc 01       	movw	r22, r24
    2522:	cd 01       	movw	r24, r26
    2524:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2528:	dc 01       	movw	r26, r24
    252a:	cb 01       	movw	r24, r22
    252c:	9a a3       	std	Y+34, r25	; 0x22
    252e:	89 a3       	std	Y+33, r24	; 0x21
    2530:	0f c0       	rjmp	.+30     	; 0x2550 <HCLCD_Vid4Bits_Init+0x1ec>
    2532:	88 ec       	ldi	r24, 0xC8	; 200
    2534:	90 e0       	ldi	r25, 0x00	; 0
    2536:	98 a3       	std	Y+32, r25	; 0x20
    2538:	8f 8f       	std	Y+31, r24	; 0x1f
    253a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    253c:	98 a1       	ldd	r25, Y+32	; 0x20
    253e:	01 97       	sbiw	r24, 0x01	; 1
    2540:	f1 f7       	brne	.-4      	; 0x253e <HCLCD_Vid4Bits_Init+0x1da>
    2542:	98 a3       	std	Y+32, r25	; 0x20
    2544:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2546:	89 a1       	ldd	r24, Y+33	; 0x21
    2548:	9a a1       	ldd	r25, Y+34	; 0x22
    254a:	01 97       	sbiw	r24, 0x01	; 1
    254c:	9a a3       	std	Y+34, r25	; 0x22
    254e:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2550:	89 a1       	ldd	r24, Y+33	; 0x21
    2552:	9a a1       	ldd	r25, Y+34	; 0x22
    2554:	00 97       	sbiw	r24, 0x00	; 0
    2556:	69 f7       	brne	.-38     	; 0x2532 <HCLCD_Vid4Bits_Init+0x1ce>
    2558:	14 c0       	rjmp	.+40     	; 0x2582 <HCLCD_Vid4Bits_Init+0x21e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    255a:	6b a1       	ldd	r22, Y+35	; 0x23
    255c:	7c a1       	ldd	r23, Y+36	; 0x24
    255e:	8d a1       	ldd	r24, Y+37	; 0x25
    2560:	9e a1       	ldd	r25, Y+38	; 0x26
    2562:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2566:	dc 01       	movw	r26, r24
    2568:	cb 01       	movw	r24, r22
    256a:	9a a3       	std	Y+34, r25	; 0x22
    256c:	89 a3       	std	Y+33, r24	; 0x21
    256e:	89 a1       	ldd	r24, Y+33	; 0x21
    2570:	9a a1       	ldd	r25, Y+34	; 0x22
    2572:	9e 8f       	std	Y+30, r25	; 0x1e
    2574:	8d 8f       	std	Y+29, r24	; 0x1d
    2576:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2578:	9e 8d       	ldd	r25, Y+30	; 0x1e
    257a:	01 97       	sbiw	r24, 0x01	; 1
    257c:	f1 f7       	brne	.-4      	; 0x257a <HCLCD_Vid4Bits_Init+0x216>
    257e:	9e 8f       	std	Y+30, r25	; 0x1e
    2580:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1);
	/*send Display on/off  command*/
	HCLCD_VidWriteCommand_4Bits(HCLCD_DISPLAY_ON_OFF>>4);
    2582:	80 e0       	ldi	r24, 0x00	; 0
    2584:	0e 94 12 11 	call	0x2224	; 0x2224 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_DISPLAY_ON_OFF);
    2588:	8f e0       	ldi	r24, 0x0F	; 15
    258a:	0e 94 12 11 	call	0x2224	; 0x2224 <HCLCD_VidWriteCommand_4Bits>
    258e:	80 e0       	ldi	r24, 0x00	; 0
    2590:	90 e0       	ldi	r25, 0x00	; 0
    2592:	a0 e8       	ldi	r26, 0x80	; 128
    2594:	bf e3       	ldi	r27, 0x3F	; 63
    2596:	89 8f       	std	Y+25, r24	; 0x19
    2598:	9a 8f       	std	Y+26, r25	; 0x1a
    259a:	ab 8f       	std	Y+27, r26	; 0x1b
    259c:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    259e:	69 8d       	ldd	r22, Y+25	; 0x19
    25a0:	7a 8d       	ldd	r23, Y+26	; 0x1a
    25a2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    25a4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    25a6:	20 e0       	ldi	r18, 0x00	; 0
    25a8:	30 e0       	ldi	r19, 0x00	; 0
    25aa:	4a ef       	ldi	r20, 0xFA	; 250
    25ac:	54 e4       	ldi	r21, 0x44	; 68
    25ae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    25b2:	dc 01       	movw	r26, r24
    25b4:	cb 01       	movw	r24, r22
    25b6:	8d 8b       	std	Y+21, r24	; 0x15
    25b8:	9e 8b       	std	Y+22, r25	; 0x16
    25ba:	af 8b       	std	Y+23, r26	; 0x17
    25bc:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    25be:	6d 89       	ldd	r22, Y+21	; 0x15
    25c0:	7e 89       	ldd	r23, Y+22	; 0x16
    25c2:	8f 89       	ldd	r24, Y+23	; 0x17
    25c4:	98 8d       	ldd	r25, Y+24	; 0x18
    25c6:	20 e0       	ldi	r18, 0x00	; 0
    25c8:	30 e0       	ldi	r19, 0x00	; 0
    25ca:	40 e8       	ldi	r20, 0x80	; 128
    25cc:	5f e3       	ldi	r21, 0x3F	; 63
    25ce:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    25d2:	88 23       	and	r24, r24
    25d4:	2c f4       	brge	.+10     	; 0x25e0 <HCLCD_Vid4Bits_Init+0x27c>
		__ticks = 1;
    25d6:	81 e0       	ldi	r24, 0x01	; 1
    25d8:	90 e0       	ldi	r25, 0x00	; 0
    25da:	9c 8b       	std	Y+20, r25	; 0x14
    25dc:	8b 8b       	std	Y+19, r24	; 0x13
    25de:	3f c0       	rjmp	.+126    	; 0x265e <HCLCD_Vid4Bits_Init+0x2fa>
	else if (__tmp > 65535)
    25e0:	6d 89       	ldd	r22, Y+21	; 0x15
    25e2:	7e 89       	ldd	r23, Y+22	; 0x16
    25e4:	8f 89       	ldd	r24, Y+23	; 0x17
    25e6:	98 8d       	ldd	r25, Y+24	; 0x18
    25e8:	20 e0       	ldi	r18, 0x00	; 0
    25ea:	3f ef       	ldi	r19, 0xFF	; 255
    25ec:	4f e7       	ldi	r20, 0x7F	; 127
    25ee:	57 e4       	ldi	r21, 0x47	; 71
    25f0:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    25f4:	18 16       	cp	r1, r24
    25f6:	4c f5       	brge	.+82     	; 0x264a <HCLCD_Vid4Bits_Init+0x2e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    25f8:	69 8d       	ldd	r22, Y+25	; 0x19
    25fa:	7a 8d       	ldd	r23, Y+26	; 0x1a
    25fc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    25fe:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2600:	20 e0       	ldi	r18, 0x00	; 0
    2602:	30 e0       	ldi	r19, 0x00	; 0
    2604:	40 e2       	ldi	r20, 0x20	; 32
    2606:	51 e4       	ldi	r21, 0x41	; 65
    2608:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    260c:	dc 01       	movw	r26, r24
    260e:	cb 01       	movw	r24, r22
    2610:	bc 01       	movw	r22, r24
    2612:	cd 01       	movw	r24, r26
    2614:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2618:	dc 01       	movw	r26, r24
    261a:	cb 01       	movw	r24, r22
    261c:	9c 8b       	std	Y+20, r25	; 0x14
    261e:	8b 8b       	std	Y+19, r24	; 0x13
    2620:	0f c0       	rjmp	.+30     	; 0x2640 <HCLCD_Vid4Bits_Init+0x2dc>
    2622:	88 ec       	ldi	r24, 0xC8	; 200
    2624:	90 e0       	ldi	r25, 0x00	; 0
    2626:	9a 8b       	std	Y+18, r25	; 0x12
    2628:	89 8b       	std	Y+17, r24	; 0x11
    262a:	89 89       	ldd	r24, Y+17	; 0x11
    262c:	9a 89       	ldd	r25, Y+18	; 0x12
    262e:	01 97       	sbiw	r24, 0x01	; 1
    2630:	f1 f7       	brne	.-4      	; 0x262e <HCLCD_Vid4Bits_Init+0x2ca>
    2632:	9a 8b       	std	Y+18, r25	; 0x12
    2634:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2636:	8b 89       	ldd	r24, Y+19	; 0x13
    2638:	9c 89       	ldd	r25, Y+20	; 0x14
    263a:	01 97       	sbiw	r24, 0x01	; 1
    263c:	9c 8b       	std	Y+20, r25	; 0x14
    263e:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2640:	8b 89       	ldd	r24, Y+19	; 0x13
    2642:	9c 89       	ldd	r25, Y+20	; 0x14
    2644:	00 97       	sbiw	r24, 0x00	; 0
    2646:	69 f7       	brne	.-38     	; 0x2622 <HCLCD_Vid4Bits_Init+0x2be>
    2648:	14 c0       	rjmp	.+40     	; 0x2672 <HCLCD_Vid4Bits_Init+0x30e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    264a:	6d 89       	ldd	r22, Y+21	; 0x15
    264c:	7e 89       	ldd	r23, Y+22	; 0x16
    264e:	8f 89       	ldd	r24, Y+23	; 0x17
    2650:	98 8d       	ldd	r25, Y+24	; 0x18
    2652:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2656:	dc 01       	movw	r26, r24
    2658:	cb 01       	movw	r24, r22
    265a:	9c 8b       	std	Y+20, r25	; 0x14
    265c:	8b 8b       	std	Y+19, r24	; 0x13
    265e:	8b 89       	ldd	r24, Y+19	; 0x13
    2660:	9c 89       	ldd	r25, Y+20	; 0x14
    2662:	98 8b       	std	Y+16, r25	; 0x10
    2664:	8f 87       	std	Y+15, r24	; 0x0f
    2666:	8f 85       	ldd	r24, Y+15	; 0x0f
    2668:	98 89       	ldd	r25, Y+16	; 0x10
    266a:	01 97       	sbiw	r24, 0x01	; 1
    266c:	f1 f7       	brne	.-4      	; 0x266a <HCLCD_Vid4Bits_Init+0x306>
    266e:	98 8b       	std	Y+16, r25	; 0x10
    2670:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);
	/*send Display Clear  command*/
	HCLCD_VidWriteCommand_4Bits(DISPLAY_CLEAR>>4);
    2672:	80 e0       	ldi	r24, 0x00	; 0
    2674:	0e 94 12 11 	call	0x2224	; 0x2224 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(DISPLAY_CLEAR);
    2678:	81 e0       	ldi	r24, 0x01	; 1
    267a:	0e 94 12 11 	call	0x2224	; 0x2224 <HCLCD_VidWriteCommand_4Bits>
    267e:	80 e0       	ldi	r24, 0x00	; 0
    2680:	90 e0       	ldi	r25, 0x00	; 0
    2682:	a0 e0       	ldi	r26, 0x00	; 0
    2684:	b0 e4       	ldi	r27, 0x40	; 64
    2686:	8b 87       	std	Y+11, r24	; 0x0b
    2688:	9c 87       	std	Y+12, r25	; 0x0c
    268a:	ad 87       	std	Y+13, r26	; 0x0d
    268c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    268e:	6b 85       	ldd	r22, Y+11	; 0x0b
    2690:	7c 85       	ldd	r23, Y+12	; 0x0c
    2692:	8d 85       	ldd	r24, Y+13	; 0x0d
    2694:	9e 85       	ldd	r25, Y+14	; 0x0e
    2696:	20 e0       	ldi	r18, 0x00	; 0
    2698:	30 e0       	ldi	r19, 0x00	; 0
    269a:	4a ef       	ldi	r20, 0xFA	; 250
    269c:	54 e4       	ldi	r21, 0x44	; 68
    269e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    26a2:	dc 01       	movw	r26, r24
    26a4:	cb 01       	movw	r24, r22
    26a6:	8f 83       	std	Y+7, r24	; 0x07
    26a8:	98 87       	std	Y+8, r25	; 0x08
    26aa:	a9 87       	std	Y+9, r26	; 0x09
    26ac:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    26ae:	6f 81       	ldd	r22, Y+7	; 0x07
    26b0:	78 85       	ldd	r23, Y+8	; 0x08
    26b2:	89 85       	ldd	r24, Y+9	; 0x09
    26b4:	9a 85       	ldd	r25, Y+10	; 0x0a
    26b6:	20 e0       	ldi	r18, 0x00	; 0
    26b8:	30 e0       	ldi	r19, 0x00	; 0
    26ba:	40 e8       	ldi	r20, 0x80	; 128
    26bc:	5f e3       	ldi	r21, 0x3F	; 63
    26be:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    26c2:	88 23       	and	r24, r24
    26c4:	2c f4       	brge	.+10     	; 0x26d0 <HCLCD_Vid4Bits_Init+0x36c>
		__ticks = 1;
    26c6:	81 e0       	ldi	r24, 0x01	; 1
    26c8:	90 e0       	ldi	r25, 0x00	; 0
    26ca:	9e 83       	std	Y+6, r25	; 0x06
    26cc:	8d 83       	std	Y+5, r24	; 0x05
    26ce:	3f c0       	rjmp	.+126    	; 0x274e <HCLCD_Vid4Bits_Init+0x3ea>
	else if (__tmp > 65535)
    26d0:	6f 81       	ldd	r22, Y+7	; 0x07
    26d2:	78 85       	ldd	r23, Y+8	; 0x08
    26d4:	89 85       	ldd	r24, Y+9	; 0x09
    26d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    26d8:	20 e0       	ldi	r18, 0x00	; 0
    26da:	3f ef       	ldi	r19, 0xFF	; 255
    26dc:	4f e7       	ldi	r20, 0x7F	; 127
    26de:	57 e4       	ldi	r21, 0x47	; 71
    26e0:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    26e4:	18 16       	cp	r1, r24
    26e6:	4c f5       	brge	.+82     	; 0x273a <HCLCD_Vid4Bits_Init+0x3d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    26e8:	6b 85       	ldd	r22, Y+11	; 0x0b
    26ea:	7c 85       	ldd	r23, Y+12	; 0x0c
    26ec:	8d 85       	ldd	r24, Y+13	; 0x0d
    26ee:	9e 85       	ldd	r25, Y+14	; 0x0e
    26f0:	20 e0       	ldi	r18, 0x00	; 0
    26f2:	30 e0       	ldi	r19, 0x00	; 0
    26f4:	40 e2       	ldi	r20, 0x20	; 32
    26f6:	51 e4       	ldi	r21, 0x41	; 65
    26f8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    26fc:	dc 01       	movw	r26, r24
    26fe:	cb 01       	movw	r24, r22
    2700:	bc 01       	movw	r22, r24
    2702:	cd 01       	movw	r24, r26
    2704:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2708:	dc 01       	movw	r26, r24
    270a:	cb 01       	movw	r24, r22
    270c:	9e 83       	std	Y+6, r25	; 0x06
    270e:	8d 83       	std	Y+5, r24	; 0x05
    2710:	0f c0       	rjmp	.+30     	; 0x2730 <HCLCD_Vid4Bits_Init+0x3cc>
    2712:	88 ec       	ldi	r24, 0xC8	; 200
    2714:	90 e0       	ldi	r25, 0x00	; 0
    2716:	9c 83       	std	Y+4, r25	; 0x04
    2718:	8b 83       	std	Y+3, r24	; 0x03
    271a:	8b 81       	ldd	r24, Y+3	; 0x03
    271c:	9c 81       	ldd	r25, Y+4	; 0x04
    271e:	01 97       	sbiw	r24, 0x01	; 1
    2720:	f1 f7       	brne	.-4      	; 0x271e <HCLCD_Vid4Bits_Init+0x3ba>
    2722:	9c 83       	std	Y+4, r25	; 0x04
    2724:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2726:	8d 81       	ldd	r24, Y+5	; 0x05
    2728:	9e 81       	ldd	r25, Y+6	; 0x06
    272a:	01 97       	sbiw	r24, 0x01	; 1
    272c:	9e 83       	std	Y+6, r25	; 0x06
    272e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2730:	8d 81       	ldd	r24, Y+5	; 0x05
    2732:	9e 81       	ldd	r25, Y+6	; 0x06
    2734:	00 97       	sbiw	r24, 0x00	; 0
    2736:	69 f7       	brne	.-38     	; 0x2712 <HCLCD_Vid4Bits_Init+0x3ae>
    2738:	14 c0       	rjmp	.+40     	; 0x2762 <HCLCD_Vid4Bits_Init+0x3fe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    273a:	6f 81       	ldd	r22, Y+7	; 0x07
    273c:	78 85       	ldd	r23, Y+8	; 0x08
    273e:	89 85       	ldd	r24, Y+9	; 0x09
    2740:	9a 85       	ldd	r25, Y+10	; 0x0a
    2742:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2746:	dc 01       	movw	r26, r24
    2748:	cb 01       	movw	r24, r22
    274a:	9e 83       	std	Y+6, r25	; 0x06
    274c:	8d 83       	std	Y+5, r24	; 0x05
    274e:	8d 81       	ldd	r24, Y+5	; 0x05
    2750:	9e 81       	ldd	r25, Y+6	; 0x06
    2752:	9a 83       	std	Y+2, r25	; 0x02
    2754:	89 83       	std	Y+1, r24	; 0x01
    2756:	89 81       	ldd	r24, Y+1	; 0x01
    2758:	9a 81       	ldd	r25, Y+2	; 0x02
    275a:	01 97       	sbiw	r24, 0x01	; 1
    275c:	f1 f7       	brne	.-4      	; 0x275a <HCLCD_Vid4Bits_Init+0x3f6>
    275e:	9a 83       	std	Y+2, r25	; 0x02
    2760:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	/*send Entry Mode  set command*/
	HCLCD_VidWriteCommand_4Bits(HCLCD_ENTRY_MODE_SET>>4);
    2762:	80 e0       	ldi	r24, 0x00	; 0
    2764:	0e 94 12 11 	call	0x2224	; 0x2224 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(HCLCD_ENTRY_MODE_SET);
    2768:	86 e0       	ldi	r24, 0x06	; 6
    276a:	0e 94 12 11 	call	0x2224	; 0x2224 <HCLCD_VidWriteCommand_4Bits>
}
    276e:	e9 96       	adiw	r28, 0x39	; 57
    2770:	0f b6       	in	r0, 0x3f	; 63
    2772:	f8 94       	cli
    2774:	de bf       	out	0x3e, r29	; 62
    2776:	0f be       	out	0x3f, r0	; 63
    2778:	cd bf       	out	0x3d, r28	; 61
    277a:	cf 91       	pop	r28
    277c:	df 91       	pop	r29
    277e:	08 95       	ret

00002780 <HCLCD_VidWriteChar_4Bits>:
void HCLCD_VidWriteChar_4Bits(u8 Copy_u8Data)
{
    2780:	df 93       	push	r29
    2782:	cf 93       	push	r28
    2784:	cd b7       	in	r28, 0x3d	; 61
    2786:	de b7       	in	r29, 0x3e	; 62
    2788:	60 97       	sbiw	r28, 0x10	; 16
    278a:	0f b6       	in	r0, 0x3f	; 63
    278c:	f8 94       	cli
    278e:	de bf       	out	0x3e, r29	; 62
    2790:	0f be       	out	0x3f, r0	; 63
    2792:	cd bf       	out	0x3d, r28	; 61
    2794:	88 8b       	std	Y+16, r24	; 0x10
	u8 LOC_u8CopyData;
	/*select Data register--> Write One on Rs pin*/
	MDIO_Error_State_SetPinValue(RS,CONTROL_PORT,PIN_HIGH);
    2796:	81 e0       	ldi	r24, 0x01	; 1
    2798:	62 e0       	ldi	r22, 0x02	; 2
    279a:	41 e0       	ldi	r20, 0x01	; 1
    279c:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
	/*select Write mode--> Write zero on RW pin*/
	//MDIO_Error_State_SetPinValue(RW,CONTROL_PORT,PIN_LOW);
	/*Send Data*/
	LOC_u8CopyData=(Copy_u8Data&0x0F)<<HCLCD_PINSTART;
    27a0:	88 89       	ldd	r24, Y+16	; 0x10
    27a2:	8f 70       	andi	r24, 0x0F	; 15
    27a4:	88 0f       	add	r24, r24
    27a6:	88 0f       	add	r24, r24
    27a8:	88 0f       	add	r24, r24
    27aa:	8f 87       	std	Y+15, r24	; 0x0f
	MDIO_Error_State_SetNippleValue(HCLCD_PINSTART,DATA_PORT,LOC_u8CopyData);
    27ac:	83 e0       	ldi	r24, 0x03	; 3
    27ae:	62 e0       	ldi	r22, 0x02	; 2
    27b0:	4f 85       	ldd	r20, Y+15	; 0x0f
    27b2:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <MDIO_Error_State_SetNippleValue>
	/*Send Enable*/
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_HIGH);
    27b6:	82 e0       	ldi	r24, 0x02	; 2
    27b8:	62 e0       	ldi	r22, 0x02	; 2
    27ba:	41 e0       	ldi	r20, 0x01	; 1
    27bc:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
    27c0:	80 e0       	ldi	r24, 0x00	; 0
    27c2:	90 e0       	ldi	r25, 0x00	; 0
    27c4:	a0 e0       	ldi	r26, 0x00	; 0
    27c6:	b0 e4       	ldi	r27, 0x40	; 64
    27c8:	8b 87       	std	Y+11, r24	; 0x0b
    27ca:	9c 87       	std	Y+12, r25	; 0x0c
    27cc:	ad 87       	std	Y+13, r26	; 0x0d
    27ce:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    27d0:	6b 85       	ldd	r22, Y+11	; 0x0b
    27d2:	7c 85       	ldd	r23, Y+12	; 0x0c
    27d4:	8d 85       	ldd	r24, Y+13	; 0x0d
    27d6:	9e 85       	ldd	r25, Y+14	; 0x0e
    27d8:	20 e0       	ldi	r18, 0x00	; 0
    27da:	30 e0       	ldi	r19, 0x00	; 0
    27dc:	4a ef       	ldi	r20, 0xFA	; 250
    27de:	54 e4       	ldi	r21, 0x44	; 68
    27e0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    27e4:	dc 01       	movw	r26, r24
    27e6:	cb 01       	movw	r24, r22
    27e8:	8f 83       	std	Y+7, r24	; 0x07
    27ea:	98 87       	std	Y+8, r25	; 0x08
    27ec:	a9 87       	std	Y+9, r26	; 0x09
    27ee:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    27f0:	6f 81       	ldd	r22, Y+7	; 0x07
    27f2:	78 85       	ldd	r23, Y+8	; 0x08
    27f4:	89 85       	ldd	r24, Y+9	; 0x09
    27f6:	9a 85       	ldd	r25, Y+10	; 0x0a
    27f8:	20 e0       	ldi	r18, 0x00	; 0
    27fa:	30 e0       	ldi	r19, 0x00	; 0
    27fc:	40 e8       	ldi	r20, 0x80	; 128
    27fe:	5f e3       	ldi	r21, 0x3F	; 63
    2800:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2804:	88 23       	and	r24, r24
    2806:	2c f4       	brge	.+10     	; 0x2812 <HCLCD_VidWriteChar_4Bits+0x92>
		__ticks = 1;
    2808:	81 e0       	ldi	r24, 0x01	; 1
    280a:	90 e0       	ldi	r25, 0x00	; 0
    280c:	9e 83       	std	Y+6, r25	; 0x06
    280e:	8d 83       	std	Y+5, r24	; 0x05
    2810:	3f c0       	rjmp	.+126    	; 0x2890 <HCLCD_VidWriteChar_4Bits+0x110>
	else if (__tmp > 65535)
    2812:	6f 81       	ldd	r22, Y+7	; 0x07
    2814:	78 85       	ldd	r23, Y+8	; 0x08
    2816:	89 85       	ldd	r24, Y+9	; 0x09
    2818:	9a 85       	ldd	r25, Y+10	; 0x0a
    281a:	20 e0       	ldi	r18, 0x00	; 0
    281c:	3f ef       	ldi	r19, 0xFF	; 255
    281e:	4f e7       	ldi	r20, 0x7F	; 127
    2820:	57 e4       	ldi	r21, 0x47	; 71
    2822:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2826:	18 16       	cp	r1, r24
    2828:	4c f5       	brge	.+82     	; 0x287c <HCLCD_VidWriteChar_4Bits+0xfc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    282a:	6b 85       	ldd	r22, Y+11	; 0x0b
    282c:	7c 85       	ldd	r23, Y+12	; 0x0c
    282e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2830:	9e 85       	ldd	r25, Y+14	; 0x0e
    2832:	20 e0       	ldi	r18, 0x00	; 0
    2834:	30 e0       	ldi	r19, 0x00	; 0
    2836:	40 e2       	ldi	r20, 0x20	; 32
    2838:	51 e4       	ldi	r21, 0x41	; 65
    283a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    283e:	dc 01       	movw	r26, r24
    2840:	cb 01       	movw	r24, r22
    2842:	bc 01       	movw	r22, r24
    2844:	cd 01       	movw	r24, r26
    2846:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    284a:	dc 01       	movw	r26, r24
    284c:	cb 01       	movw	r24, r22
    284e:	9e 83       	std	Y+6, r25	; 0x06
    2850:	8d 83       	std	Y+5, r24	; 0x05
    2852:	0f c0       	rjmp	.+30     	; 0x2872 <HCLCD_VidWriteChar_4Bits+0xf2>
    2854:	88 ec       	ldi	r24, 0xC8	; 200
    2856:	90 e0       	ldi	r25, 0x00	; 0
    2858:	9c 83       	std	Y+4, r25	; 0x04
    285a:	8b 83       	std	Y+3, r24	; 0x03
    285c:	8b 81       	ldd	r24, Y+3	; 0x03
    285e:	9c 81       	ldd	r25, Y+4	; 0x04
    2860:	01 97       	sbiw	r24, 0x01	; 1
    2862:	f1 f7       	brne	.-4      	; 0x2860 <HCLCD_VidWriteChar_4Bits+0xe0>
    2864:	9c 83       	std	Y+4, r25	; 0x04
    2866:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2868:	8d 81       	ldd	r24, Y+5	; 0x05
    286a:	9e 81       	ldd	r25, Y+6	; 0x06
    286c:	01 97       	sbiw	r24, 0x01	; 1
    286e:	9e 83       	std	Y+6, r25	; 0x06
    2870:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2872:	8d 81       	ldd	r24, Y+5	; 0x05
    2874:	9e 81       	ldd	r25, Y+6	; 0x06
    2876:	00 97       	sbiw	r24, 0x00	; 0
    2878:	69 f7       	brne	.-38     	; 0x2854 <HCLCD_VidWriteChar_4Bits+0xd4>
    287a:	14 c0       	rjmp	.+40     	; 0x28a4 <HCLCD_VidWriteChar_4Bits+0x124>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    287c:	6f 81       	ldd	r22, Y+7	; 0x07
    287e:	78 85       	ldd	r23, Y+8	; 0x08
    2880:	89 85       	ldd	r24, Y+9	; 0x09
    2882:	9a 85       	ldd	r25, Y+10	; 0x0a
    2884:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2888:	dc 01       	movw	r26, r24
    288a:	cb 01       	movw	r24, r22
    288c:	9e 83       	std	Y+6, r25	; 0x06
    288e:	8d 83       	std	Y+5, r24	; 0x05
    2890:	8d 81       	ldd	r24, Y+5	; 0x05
    2892:	9e 81       	ldd	r25, Y+6	; 0x06
    2894:	9a 83       	std	Y+2, r25	; 0x02
    2896:	89 83       	std	Y+1, r24	; 0x01
    2898:	89 81       	ldd	r24, Y+1	; 0x01
    289a:	9a 81       	ldd	r25, Y+2	; 0x02
    289c:	01 97       	sbiw	r24, 0x01	; 1
    289e:	f1 f7       	brne	.-4      	; 0x289c <HCLCD_VidWriteChar_4Bits+0x11c>
    28a0:	9a 83       	std	Y+2, r25	; 0x02
    28a2:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MDIO_Error_State_SetPinValue(E,CONTROL_PORT,PIN_LOW);
    28a4:	82 e0       	ldi	r24, 0x02	; 2
    28a6:	62 e0       	ldi	r22, 0x02	; 2
    28a8:	40 e0       	ldi	r20, 0x00	; 0
    28aa:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
}
    28ae:	60 96       	adiw	r28, 0x10	; 16
    28b0:	0f b6       	in	r0, 0x3f	; 63
    28b2:	f8 94       	cli
    28b4:	de bf       	out	0x3e, r29	; 62
    28b6:	0f be       	out	0x3f, r0	; 63
    28b8:	cd bf       	out	0x3d, r28	; 61
    28ba:	cf 91       	pop	r28
    28bc:	df 91       	pop	r29
    28be:	08 95       	ret

000028c0 <HCLCD_VidSendChar_4Bits>:
void HCLCD_VidSendChar_4Bits(u8 Copy_u8Data)
{
    28c0:	df 93       	push	r29
    28c2:	cf 93       	push	r28
    28c4:	0f 92       	push	r0
    28c6:	cd b7       	in	r28, 0x3d	; 61
    28c8:	de b7       	in	r29, 0x3e	; 62
    28ca:	89 83       	std	Y+1, r24	; 0x01
	HCLCD_VidWriteChar_4Bits(Copy_u8Data>>4);
    28cc:	89 81       	ldd	r24, Y+1	; 0x01
    28ce:	82 95       	swap	r24
    28d0:	8f 70       	andi	r24, 0x0F	; 15
    28d2:	0e 94 c0 13 	call	0x2780	; 0x2780 <HCLCD_VidWriteChar_4Bits>
	HCLCD_VidWriteChar_4Bits(Copy_u8Data);
    28d6:	89 81       	ldd	r24, Y+1	; 0x01
    28d8:	0e 94 c0 13 	call	0x2780	; 0x2780 <HCLCD_VidWriteChar_4Bits>
}
    28dc:	0f 90       	pop	r0
    28de:	cf 91       	pop	r28
    28e0:	df 91       	pop	r29
    28e2:	08 95       	ret

000028e4 <HCLCD_VidWriteString_4Bits>:
void HCLCD_VidWriteString_4Bits(u8* PCopy_u8String)
{
    28e4:	df 93       	push	r29
    28e6:	cf 93       	push	r28
    28e8:	00 d0       	rcall	.+0      	; 0x28ea <HCLCD_VidWriteString_4Bits+0x6>
    28ea:	0f 92       	push	r0
    28ec:	cd b7       	in	r28, 0x3d	; 61
    28ee:	de b7       	in	r29, 0x3e	; 62
    28f0:	9b 83       	std	Y+3, r25	; 0x03
    28f2:	8a 83       	std	Y+2, r24	; 0x02
	u8 Loc_u8Count=0;
    28f4:	19 82       	std	Y+1, r1	; 0x01
    28f6:	0e c0       	rjmp	.+28     	; 0x2914 <HCLCD_VidWriteString_4Bits+0x30>
	while(PCopy_u8String[Loc_u8Count]!=NULL)
	{
		HCLCD_VidSendChar_4Bits(PCopy_u8String[Loc_u8Count]);
    28f8:	89 81       	ldd	r24, Y+1	; 0x01
    28fa:	28 2f       	mov	r18, r24
    28fc:	30 e0       	ldi	r19, 0x00	; 0
    28fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2900:	9b 81       	ldd	r25, Y+3	; 0x03
    2902:	fc 01       	movw	r30, r24
    2904:	e2 0f       	add	r30, r18
    2906:	f3 1f       	adc	r31, r19
    2908:	80 81       	ld	r24, Z
    290a:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>
		Loc_u8Count++;
    290e:	89 81       	ldd	r24, Y+1	; 0x01
    2910:	8f 5f       	subi	r24, 0xFF	; 255
    2912:	89 83       	std	Y+1, r24	; 0x01
	HCLCD_VidWriteChar_4Bits(Copy_u8Data);
}
void HCLCD_VidWriteString_4Bits(u8* PCopy_u8String)
{
	u8 Loc_u8Count=0;
	while(PCopy_u8String[Loc_u8Count]!=NULL)
    2914:	89 81       	ldd	r24, Y+1	; 0x01
    2916:	28 2f       	mov	r18, r24
    2918:	30 e0       	ldi	r19, 0x00	; 0
    291a:	8a 81       	ldd	r24, Y+2	; 0x02
    291c:	9b 81       	ldd	r25, Y+3	; 0x03
    291e:	fc 01       	movw	r30, r24
    2920:	e2 0f       	add	r30, r18
    2922:	f3 1f       	adc	r31, r19
    2924:	80 81       	ld	r24, Z
    2926:	88 23       	and	r24, r24
    2928:	39 f7       	brne	.-50     	; 0x28f8 <HCLCD_VidWriteString_4Bits+0x14>
	{
		HCLCD_VidSendChar_4Bits(PCopy_u8String[Loc_u8Count]);
		Loc_u8Count++;
	}
}
    292a:	0f 90       	pop	r0
    292c:	0f 90       	pop	r0
    292e:	0f 90       	pop	r0
    2930:	cf 91       	pop	r28
    2932:	df 91       	pop	r29
    2934:	08 95       	ret

00002936 <HCLCD_VidWriteNumber_4Bits>:
void HCLCD_VidWriteNumber_4Bits(u32 Copy_u8Number)
{
    2936:	0f 93       	push	r16
    2938:	1f 93       	push	r17
    293a:	df 93       	push	r29
    293c:	cf 93       	push	r28
    293e:	cd b7       	in	r28, 0x3d	; 61
    2940:	de b7       	in	r29, 0x3e	; 62
    2942:	60 97       	sbiw	r28, 0x10	; 16
    2944:	0f b6       	in	r0, 0x3f	; 63
    2946:	f8 94       	cli
    2948:	de bf       	out	0x3e, r29	; 62
    294a:	0f be       	out	0x3f, r0	; 63
    294c:	cd bf       	out	0x3d, r28	; 61
    294e:	6d 87       	std	Y+13, r22	; 0x0d
    2950:	7e 87       	std	Y+14, r23	; 0x0e
    2952:	8f 87       	std	Y+15, r24	; 0x0f
    2954:	98 8b       	std	Y+16, r25	; 0x10
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
    2956:	1a 82       	std	Y+2, r1	; 0x02
	if(Copy_u8Number>0)
    2958:	8d 85       	ldd	r24, Y+13	; 0x0d
    295a:	9e 85       	ldd	r25, Y+14	; 0x0e
    295c:	af 85       	ldd	r26, Y+15	; 0x0f
    295e:	b8 89       	ldd	r27, Y+16	; 0x10
    2960:	00 97       	sbiw	r24, 0x00	; 0
    2962:	a1 05       	cpc	r26, r1
    2964:	b1 05       	cpc	r27, r1
    2966:	09 f4       	brne	.+2      	; 0x296a <HCLCD_VidWriteNumber_4Bits+0x34>
    2968:	4f c0       	rjmp	.+158    	; 0x2a08 <HCLCD_VidWriteNumber_4Bits+0xd2>
    296a:	2d c0       	rjmp	.+90     	; 0x29c6 <HCLCD_VidWriteNumber_4Bits+0x90>
	{
		while(Copy_u8Number!=0)
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
    296c:	8a 81       	ldd	r24, Y+2	; 0x02
    296e:	08 2f       	mov	r16, r24
    2970:	10 e0       	ldi	r17, 0x00	; 0
    2972:	8d 85       	ldd	r24, Y+13	; 0x0d
    2974:	9e 85       	ldd	r25, Y+14	; 0x0e
    2976:	af 85       	ldd	r26, Y+15	; 0x0f
    2978:	b8 89       	ldd	r27, Y+16	; 0x10
    297a:	2a e0       	ldi	r18, 0x0A	; 10
    297c:	30 e0       	ldi	r19, 0x00	; 0
    297e:	40 e0       	ldi	r20, 0x00	; 0
    2980:	50 e0       	ldi	r21, 0x00	; 0
    2982:	bc 01       	movw	r22, r24
    2984:	cd 01       	movw	r24, r26
    2986:	0e 94 8a 2e 	call	0x5d14	; 0x5d14 <__udivmodsi4>
    298a:	dc 01       	movw	r26, r24
    298c:	cb 01       	movw	r24, r22
    298e:	28 2f       	mov	r18, r24
    2990:	ce 01       	movw	r24, r28
    2992:	03 96       	adiw	r24, 0x03	; 3
    2994:	fc 01       	movw	r30, r24
    2996:	e0 0f       	add	r30, r16
    2998:	f1 1f       	adc	r31, r17
    299a:	20 83       	st	Z, r18
			Copy_u8Number/=10;
    299c:	8d 85       	ldd	r24, Y+13	; 0x0d
    299e:	9e 85       	ldd	r25, Y+14	; 0x0e
    29a0:	af 85       	ldd	r26, Y+15	; 0x0f
    29a2:	b8 89       	ldd	r27, Y+16	; 0x10
    29a4:	2a e0       	ldi	r18, 0x0A	; 10
    29a6:	30 e0       	ldi	r19, 0x00	; 0
    29a8:	40 e0       	ldi	r20, 0x00	; 0
    29aa:	50 e0       	ldi	r21, 0x00	; 0
    29ac:	bc 01       	movw	r22, r24
    29ae:	cd 01       	movw	r24, r26
    29b0:	0e 94 8a 2e 	call	0x5d14	; 0x5d14 <__udivmodsi4>
    29b4:	da 01       	movw	r26, r20
    29b6:	c9 01       	movw	r24, r18
    29b8:	8d 87       	std	Y+13, r24	; 0x0d
    29ba:	9e 87       	std	Y+14, r25	; 0x0e
    29bc:	af 87       	std	Y+15, r26	; 0x0f
    29be:	b8 8b       	std	Y+16, r27	; 0x10
			LOC_Count++;
    29c0:	8a 81       	ldd	r24, Y+2	; 0x02
    29c2:	8f 5f       	subi	r24, 0xFF	; 255
    29c4:	8a 83       	std	Y+2, r24	; 0x02
{
	u8 ARR_Digits[10];
	u8 LOC_Count=0;
	if(Copy_u8Number>0)
	{
		while(Copy_u8Number!=0)
    29c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    29c8:	9e 85       	ldd	r25, Y+14	; 0x0e
    29ca:	af 85       	ldd	r26, Y+15	; 0x0f
    29cc:	b8 89       	ldd	r27, Y+16	; 0x10
    29ce:	00 97       	sbiw	r24, 0x00	; 0
    29d0:	a1 05       	cpc	r26, r1
    29d2:	b1 05       	cpc	r27, r1
    29d4:	59 f6       	brne	.-106    	; 0x296c <HCLCD_VidWriteNumber_4Bits+0x36>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    29d6:	8a 81       	ldd	r24, Y+2	; 0x02
    29d8:	81 50       	subi	r24, 0x01	; 1
    29da:	89 83       	std	Y+1, r24	; 0x01
    29dc:	11 c0       	rjmp	.+34     	; 0x2a00 <HCLCD_VidWriteNumber_4Bits+0xca>
		{
			HCLCD_VidSendChar_4Bits(ARR_Digits[i]+'0');
    29de:	89 81       	ldd	r24, Y+1	; 0x01
    29e0:	28 2f       	mov	r18, r24
    29e2:	33 27       	eor	r19, r19
    29e4:	27 fd       	sbrc	r18, 7
    29e6:	30 95       	com	r19
    29e8:	ce 01       	movw	r24, r28
    29ea:	03 96       	adiw	r24, 0x03	; 3
    29ec:	fc 01       	movw	r30, r24
    29ee:	e2 0f       	add	r30, r18
    29f0:	f3 1f       	adc	r31, r19
    29f2:	80 81       	ld	r24, Z
    29f4:	80 5d       	subi	r24, 0xD0	; 208
    29f6:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>
		{
			ARR_Digits[LOC_Count]=Copy_u8Number%10;
			Copy_u8Number/=10;
			LOC_Count++;
		}
		for(s8 i=LOC_Count-1;i>=0;i--)
    29fa:	89 81       	ldd	r24, Y+1	; 0x01
    29fc:	81 50       	subi	r24, 0x01	; 1
    29fe:	89 83       	std	Y+1, r24	; 0x01
    2a00:	89 81       	ldd	r24, Y+1	; 0x01
    2a02:	88 23       	and	r24, r24
    2a04:	64 f7       	brge	.-40     	; 0x29de <HCLCD_VidWriteNumber_4Bits+0xa8>
    2a06:	03 c0       	rjmp	.+6      	; 0x2a0e <HCLCD_VidWriteNumber_4Bits+0xd8>
			HCLCD_VidSendChar_4Bits(ARR_Digits[i]+'0');
		}
	}
	else
	{
		HCLCD_VidSendChar_4Bits('0');
    2a08:	80 e3       	ldi	r24, 0x30	; 48
    2a0a:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>
	}
}
    2a0e:	60 96       	adiw	r28, 0x10	; 16
    2a10:	0f b6       	in	r0, 0x3f	; 63
    2a12:	f8 94       	cli
    2a14:	de bf       	out	0x3e, r29	; 62
    2a16:	0f be       	out	0x3f, r0	; 63
    2a18:	cd bf       	out	0x3d, r28	; 61
    2a1a:	cf 91       	pop	r28
    2a1c:	df 91       	pop	r29
    2a1e:	1f 91       	pop	r17
    2a20:	0f 91       	pop	r16
    2a22:	08 95       	ret

00002a24 <HCLCD_VidSetPosition_4BitsMode>:
void HCLCD_VidSetPosition_4BitsMode(u8 Copy_u8LineNumber , u8 Copy_u8PositionNumber)
{
    2a24:	df 93       	push	r29
    2a26:	cf 93       	push	r28
    2a28:	00 d0       	rcall	.+0      	; 0x2a2a <HCLCD_VidSetPosition_4BitsMode+0x6>
    2a2a:	cd b7       	in	r28, 0x3d	; 61
    2a2c:	de b7       	in	r29, 0x3e	; 62
    2a2e:	89 83       	std	Y+1, r24	; 0x01
    2a30:	6a 83       	std	Y+2, r22	; 0x02
	if((Copy_u8LineNumber==HCLCD_LINE1)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    2a32:	89 81       	ldd	r24, Y+1	; 0x01
    2a34:	81 30       	cpi	r24, 0x01	; 1
    2a36:	b9 f4       	brne	.+46     	; 0x2a66 <HCLCD_VidSetPosition_4BitsMode+0x42>
    2a38:	8a 81       	ldd	r24, Y+2	; 0x02
    2a3a:	80 31       	cpi	r24, 0x10	; 16
    2a3c:	a0 f4       	brcc	.+40     	; 0x2a66 <HCLCD_VidSetPosition_4BitsMode+0x42>
	{
		HCLCD_VidWriteCommand_4Bits((LINE1_OFFSET_ADDRESS+Copy_u8PositionNumber)>>4);
    2a3e:	8a 81       	ldd	r24, Y+2	; 0x02
    2a40:	88 2f       	mov	r24, r24
    2a42:	90 e0       	ldi	r25, 0x00	; 0
    2a44:	80 58       	subi	r24, 0x80	; 128
    2a46:	9f 4f       	sbci	r25, 0xFF	; 255
    2a48:	95 95       	asr	r25
    2a4a:	87 95       	ror	r24
    2a4c:	95 95       	asr	r25
    2a4e:	87 95       	ror	r24
    2a50:	95 95       	asr	r25
    2a52:	87 95       	ror	r24
    2a54:	95 95       	asr	r25
    2a56:	87 95       	ror	r24
    2a58:	0e 94 12 11 	call	0x2224	; 0x2224 <HCLCD_VidWriteCommand_4Bits>
		HCLCD_VidWriteCommand_4Bits((LINE1_OFFSET_ADDRESS+Copy_u8PositionNumber));
    2a5c:	8a 81       	ldd	r24, Y+2	; 0x02
    2a5e:	80 58       	subi	r24, 0x80	; 128
    2a60:	0e 94 12 11 	call	0x2224	; 0x2224 <HCLCD_VidWriteCommand_4Bits>
    2a64:	19 c0       	rjmp	.+50     	; 0x2a98 <HCLCD_VidSetPosition_4BitsMode+0x74>
	}
	else if((Copy_u8LineNumber==HCLCD_LINE2)&&((Copy_u8PositionNumber>=0)&&(Copy_u8PositionNumber<16)))
    2a66:	89 81       	ldd	r24, Y+1	; 0x01
    2a68:	82 30       	cpi	r24, 0x02	; 2
    2a6a:	b1 f4       	brne	.+44     	; 0x2a98 <HCLCD_VidSetPosition_4BitsMode+0x74>
    2a6c:	8a 81       	ldd	r24, Y+2	; 0x02
    2a6e:	80 31       	cpi	r24, 0x10	; 16
    2a70:	98 f4       	brcc	.+38     	; 0x2a98 <HCLCD_VidSetPosition_4BitsMode+0x74>
	{
		HCLCD_VidWriteCommand_4Bits((LINE2_OFFSET_ADDRESS+Copy_u8PositionNumber)>>4);
    2a72:	8a 81       	ldd	r24, Y+2	; 0x02
    2a74:	88 2f       	mov	r24, r24
    2a76:	90 e0       	ldi	r25, 0x00	; 0
    2a78:	80 54       	subi	r24, 0x40	; 64
    2a7a:	9f 4f       	sbci	r25, 0xFF	; 255
    2a7c:	95 95       	asr	r25
    2a7e:	87 95       	ror	r24
    2a80:	95 95       	asr	r25
    2a82:	87 95       	ror	r24
    2a84:	95 95       	asr	r25
    2a86:	87 95       	ror	r24
    2a88:	95 95       	asr	r25
    2a8a:	87 95       	ror	r24
    2a8c:	0e 94 12 11 	call	0x2224	; 0x2224 <HCLCD_VidWriteCommand_4Bits>
		HCLCD_VidWriteCommand_4Bits((LINE2_OFFSET_ADDRESS+Copy_u8PositionNumber));
    2a90:	8a 81       	ldd	r24, Y+2	; 0x02
    2a92:	80 54       	subi	r24, 0x40	; 64
    2a94:	0e 94 12 11 	call	0x2224	; 0x2224 <HCLCD_VidWriteCommand_4Bits>
	}
	else
	{
		/*Do Nothing*/
	}
}
    2a98:	0f 90       	pop	r0
    2a9a:	0f 90       	pop	r0
    2a9c:	cf 91       	pop	r28
    2a9e:	df 91       	pop	r29
    2aa0:	08 95       	ret

00002aa2 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    2aa2:	df 93       	push	r29
    2aa4:	cf 93       	push	r28
    2aa6:	cd b7       	in	r28, 0x3d	; 61
    2aa8:	de b7       	in	r29, 0x3e	; 62
    2aaa:	27 97       	sbiw	r28, 0x07	; 7
    2aac:	0f b6       	in	r0, 0x3f	; 63
    2aae:	f8 94       	cli
    2ab0:	de bf       	out	0x3e, r29	; 62
    2ab2:	0f be       	out	0x3f, r0	; 63
    2ab4:	cd bf       	out	0x3d, r28	; 61
    2ab6:	9d 83       	std	Y+5, r25	; 0x05
    2ab8:	8c 83       	std	Y+4, r24	; 0x04
    2aba:	6e 83       	std	Y+6, r22	; 0x06
    2abc:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    2abe:	8a e1       	ldi	r24, 0x1A	; 26
    2ac0:	90 e0       	ldi	r25, 0x00	; 0
    2ac2:	0e 94 29 18 	call	0x3052	; 0x3052 <pvPortMalloc>
    2ac6:	9a 83       	std	Y+2, r25	; 0x02
    2ac8:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    2aca:	89 81       	ldd	r24, Y+1	; 0x01
    2acc:	9a 81       	ldd	r25, Y+2	; 0x02
    2ace:	00 97       	sbiw	r24, 0x00	; 0
    2ad0:	09 f4       	brne	.+2      	; 0x2ad4 <xCoRoutineCreate+0x32>
    2ad2:	6f c0       	rjmp	.+222    	; 0x2bb2 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    2ad4:	80 91 b2 00 	lds	r24, 0x00B2
    2ad8:	90 91 b3 00 	lds	r25, 0x00B3
    2adc:	00 97       	sbiw	r24, 0x00	; 0
    2ade:	41 f4       	brne	.+16     	; 0x2af0 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    2ae0:	89 81       	ldd	r24, Y+1	; 0x01
    2ae2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ae4:	90 93 b3 00 	sts	0x00B3, r25
    2ae8:	80 93 b2 00 	sts	0x00B2, r24
			prvInitialiseCoRoutineLists();
    2aec:	0e 94 b8 17 	call	0x2f70	; 0x2f70 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    2af0:	8e 81       	ldd	r24, Y+6	; 0x06
    2af2:	82 30       	cpi	r24, 0x02	; 2
    2af4:	10 f0       	brcs	.+4      	; 0x2afa <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    2af6:	81 e0       	ldi	r24, 0x01	; 1
    2af8:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    2afa:	e9 81       	ldd	r30, Y+1	; 0x01
    2afc:	fa 81       	ldd	r31, Y+2	; 0x02
    2afe:	11 8e       	std	Z+25, r1	; 0x19
    2b00:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2b02:	e9 81       	ldd	r30, Y+1	; 0x01
    2b04:	fa 81       	ldd	r31, Y+2	; 0x02
    2b06:	8e 81       	ldd	r24, Y+6	; 0x06
    2b08:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2b0a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b0c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b0e:	8f 81       	ldd	r24, Y+7	; 0x07
    2b10:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    2b12:	e9 81       	ldd	r30, Y+1	; 0x01
    2b14:	fa 81       	ldd	r31, Y+2	; 0x02
    2b16:	8c 81       	ldd	r24, Y+4	; 0x04
    2b18:	9d 81       	ldd	r25, Y+5	; 0x05
    2b1a:	91 83       	std	Z+1, r25	; 0x01
    2b1c:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    2b1e:	89 81       	ldd	r24, Y+1	; 0x01
    2b20:	9a 81       	ldd	r25, Y+2	; 0x02
    2b22:	02 96       	adiw	r24, 0x02	; 2
    2b24:	0e 94 bf 18 	call	0x317e	; 0x317e <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2b28:	89 81       	ldd	r24, Y+1	; 0x01
    2b2a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b2c:	0c 96       	adiw	r24, 0x0c	; 12
    2b2e:	0e 94 bf 18 	call	0x317e	; 0x317e <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2b32:	e9 81       	ldd	r30, Y+1	; 0x01
    2b34:	fa 81       	ldd	r31, Y+2	; 0x02
    2b36:	89 81       	ldd	r24, Y+1	; 0x01
    2b38:	9a 81       	ldd	r25, Y+2	; 0x02
    2b3a:	91 87       	std	Z+9, r25	; 0x09
    2b3c:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2b3e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b40:	fa 81       	ldd	r31, Y+2	; 0x02
    2b42:	89 81       	ldd	r24, Y+1	; 0x01
    2b44:	9a 81       	ldd	r25, Y+2	; 0x02
    2b46:	93 8b       	std	Z+19, r25	; 0x13
    2b48:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2b4a:	8e 81       	ldd	r24, Y+6	; 0x06
    2b4c:	28 2f       	mov	r18, r24
    2b4e:	30 e0       	ldi	r19, 0x00	; 0
    2b50:	88 e0       	ldi	r24, 0x08	; 8
    2b52:	90 e0       	ldi	r25, 0x00	; 0
    2b54:	82 1b       	sub	r24, r18
    2b56:	93 0b       	sbc	r25, r19
    2b58:	e9 81       	ldd	r30, Y+1	; 0x01
    2b5a:	fa 81       	ldd	r31, Y+2	; 0x02
    2b5c:	95 87       	std	Z+13, r25	; 0x0d
    2b5e:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2b60:	e9 81       	ldd	r30, Y+1	; 0x01
    2b62:	fa 81       	ldd	r31, Y+2	; 0x02
    2b64:	96 89       	ldd	r25, Z+22	; 0x16
    2b66:	80 91 b4 00 	lds	r24, 0x00B4
    2b6a:	89 17       	cp	r24, r25
    2b6c:	28 f4       	brcc	.+10     	; 0x2b78 <xCoRoutineCreate+0xd6>
    2b6e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b70:	fa 81       	ldd	r31, Y+2	; 0x02
    2b72:	86 89       	ldd	r24, Z+22	; 0x16
    2b74:	80 93 b4 00 	sts	0x00B4, r24
    2b78:	e9 81       	ldd	r30, Y+1	; 0x01
    2b7a:	fa 81       	ldd	r31, Y+2	; 0x02
    2b7c:	86 89       	ldd	r24, Z+22	; 0x16
    2b7e:	28 2f       	mov	r18, r24
    2b80:	30 e0       	ldi	r19, 0x00	; 0
    2b82:	c9 01       	movw	r24, r18
    2b84:	88 0f       	add	r24, r24
    2b86:	99 1f       	adc	r25, r25
    2b88:	88 0f       	add	r24, r24
    2b8a:	99 1f       	adc	r25, r25
    2b8c:	88 0f       	add	r24, r24
    2b8e:	99 1f       	adc	r25, r25
    2b90:	82 0f       	add	r24, r18
    2b92:	93 1f       	adc	r25, r19
    2b94:	ac 01       	movw	r20, r24
    2b96:	45 54       	subi	r20, 0x45	; 69
    2b98:	5f 4f       	sbci	r21, 0xFF	; 255
    2b9a:	89 81       	ldd	r24, Y+1	; 0x01
    2b9c:	9a 81       	ldd	r25, Y+2	; 0x02
    2b9e:	9c 01       	movw	r18, r24
    2ba0:	2e 5f       	subi	r18, 0xFE	; 254
    2ba2:	3f 4f       	sbci	r19, 0xFF	; 255
    2ba4:	ca 01       	movw	r24, r20
    2ba6:	b9 01       	movw	r22, r18
    2ba8:	0e 94 cf 18 	call	0x319e	; 0x319e <vListInsertEnd>

		xReturn = pdPASS;
    2bac:	81 e0       	ldi	r24, 0x01	; 1
    2bae:	8b 83       	std	Y+3, r24	; 0x03
    2bb0:	02 c0       	rjmp	.+4      	; 0x2bb6 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2bb2:	8f ef       	ldi	r24, 0xFF	; 255
    2bb4:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    2bb6:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2bb8:	27 96       	adiw	r28, 0x07	; 7
    2bba:	0f b6       	in	r0, 0x3f	; 63
    2bbc:	f8 94       	cli
    2bbe:	de bf       	out	0x3e, r29	; 62
    2bc0:	0f be       	out	0x3f, r0	; 63
    2bc2:	cd bf       	out	0x3d, r28	; 61
    2bc4:	cf 91       	pop	r28
    2bc6:	df 91       	pop	r29
    2bc8:	08 95       	ret

00002bca <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    2bca:	df 93       	push	r29
    2bcc:	cf 93       	push	r28
    2bce:	00 d0       	rcall	.+0      	; 0x2bd0 <vCoRoutineAddToDelayedList+0x6>
    2bd0:	00 d0       	rcall	.+0      	; 0x2bd2 <vCoRoutineAddToDelayedList+0x8>
    2bd2:	00 d0       	rcall	.+0      	; 0x2bd4 <vCoRoutineAddToDelayedList+0xa>
    2bd4:	cd b7       	in	r28, 0x3d	; 61
    2bd6:	de b7       	in	r29, 0x3e	; 62
    2bd8:	9c 83       	std	Y+4, r25	; 0x04
    2bda:	8b 83       	std	Y+3, r24	; 0x03
    2bdc:	7e 83       	std	Y+6, r23	; 0x06
    2bde:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    2be0:	20 91 b5 00 	lds	r18, 0x00B5
    2be4:	30 91 b6 00 	lds	r19, 0x00B6
    2be8:	8b 81       	ldd	r24, Y+3	; 0x03
    2bea:	9c 81       	ldd	r25, Y+4	; 0x04
    2bec:	82 0f       	add	r24, r18
    2bee:	93 1f       	adc	r25, r19
    2bf0:	9a 83       	std	Y+2, r25	; 0x02
    2bf2:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2bf4:	80 91 b2 00 	lds	r24, 0x00B2
    2bf8:	90 91 b3 00 	lds	r25, 0x00B3
    2bfc:	02 96       	adiw	r24, 0x02	; 2
    2bfe:	0e 94 87 19 	call	0x330e	; 0x330e <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    2c02:	e0 91 b2 00 	lds	r30, 0x00B2
    2c06:	f0 91 b3 00 	lds	r31, 0x00B3
    2c0a:	89 81       	ldd	r24, Y+1	; 0x01
    2c0c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c0e:	93 83       	std	Z+3, r25	; 0x03
    2c10:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    2c12:	20 91 b5 00 	lds	r18, 0x00B5
    2c16:	30 91 b6 00 	lds	r19, 0x00B6
    2c1a:	89 81       	ldd	r24, Y+1	; 0x01
    2c1c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c1e:	82 17       	cp	r24, r18
    2c20:	93 07       	cpc	r25, r19
    2c22:	70 f4       	brcc	.+28     	; 0x2c40 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2c24:	80 91 e1 00 	lds	r24, 0x00E1
    2c28:	90 91 e2 00 	lds	r25, 0x00E2
    2c2c:	20 91 b2 00 	lds	r18, 0x00B2
    2c30:	30 91 b3 00 	lds	r19, 0x00B3
    2c34:	2e 5f       	subi	r18, 0xFE	; 254
    2c36:	3f 4f       	sbci	r19, 0xFF	; 255
    2c38:	b9 01       	movw	r22, r18
    2c3a:	0e 94 1b 19 	call	0x3236	; 0x3236 <vListInsert>
    2c3e:	0d c0       	rjmp	.+26     	; 0x2c5a <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2c40:	80 91 df 00 	lds	r24, 0x00DF
    2c44:	90 91 e0 00 	lds	r25, 0x00E0
    2c48:	20 91 b2 00 	lds	r18, 0x00B2
    2c4c:	30 91 b3 00 	lds	r19, 0x00B3
    2c50:	2e 5f       	subi	r18, 0xFE	; 254
    2c52:	3f 4f       	sbci	r19, 0xFF	; 255
    2c54:	b9 01       	movw	r22, r18
    2c56:	0e 94 1b 19 	call	0x3236	; 0x3236 <vListInsert>
	}

	if( pxEventList )
    2c5a:	8d 81       	ldd	r24, Y+5	; 0x05
    2c5c:	9e 81       	ldd	r25, Y+6	; 0x06
    2c5e:	00 97       	sbiw	r24, 0x00	; 0
    2c60:	61 f0       	breq	.+24     	; 0x2c7a <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2c62:	80 91 b2 00 	lds	r24, 0x00B2
    2c66:	90 91 b3 00 	lds	r25, 0x00B3
    2c6a:	9c 01       	movw	r18, r24
    2c6c:	24 5f       	subi	r18, 0xF4	; 244
    2c6e:	3f 4f       	sbci	r19, 0xFF	; 255
    2c70:	8d 81       	ldd	r24, Y+5	; 0x05
    2c72:	9e 81       	ldd	r25, Y+6	; 0x06
    2c74:	b9 01       	movw	r22, r18
    2c76:	0e 94 1b 19 	call	0x3236	; 0x3236 <vListInsert>
	}
}
    2c7a:	26 96       	adiw	r28, 0x06	; 6
    2c7c:	0f b6       	in	r0, 0x3f	; 63
    2c7e:	f8 94       	cli
    2c80:	de bf       	out	0x3e, r29	; 62
    2c82:	0f be       	out	0x3f, r0	; 63
    2c84:	cd bf       	out	0x3d, r28	; 61
    2c86:	cf 91       	pop	r28
    2c88:	df 91       	pop	r29
    2c8a:	08 95       	ret

00002c8c <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    2c8c:	df 93       	push	r29
    2c8e:	cf 93       	push	r28
    2c90:	00 d0       	rcall	.+0      	; 0x2c92 <prvCheckPendingReadyList+0x6>
    2c92:	cd b7       	in	r28, 0x3d	; 61
    2c94:	de b7       	in	r29, 0x3e	; 62
    2c96:	3a c0       	rjmp	.+116    	; 0x2d0c <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2c98:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    2c9a:	e0 91 e8 00 	lds	r30, 0x00E8
    2c9e:	f0 91 e9 00 	lds	r31, 0x00E9
    2ca2:	86 81       	ldd	r24, Z+6	; 0x06
    2ca4:	97 81       	ldd	r25, Z+7	; 0x07
    2ca6:	9a 83       	std	Y+2, r25	; 0x02
    2ca8:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2caa:	89 81       	ldd	r24, Y+1	; 0x01
    2cac:	9a 81       	ldd	r25, Y+2	; 0x02
    2cae:	0c 96       	adiw	r24, 0x0c	; 12
    2cb0:	0e 94 87 19 	call	0x330e	; 0x330e <vListRemove>
		}
		portENABLE_INTERRUPTS();
    2cb4:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2cb6:	89 81       	ldd	r24, Y+1	; 0x01
    2cb8:	9a 81       	ldd	r25, Y+2	; 0x02
    2cba:	02 96       	adiw	r24, 0x02	; 2
    2cbc:	0e 94 87 19 	call	0x330e	; 0x330e <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2cc0:	e9 81       	ldd	r30, Y+1	; 0x01
    2cc2:	fa 81       	ldd	r31, Y+2	; 0x02
    2cc4:	96 89       	ldd	r25, Z+22	; 0x16
    2cc6:	80 91 b4 00 	lds	r24, 0x00B4
    2cca:	89 17       	cp	r24, r25
    2ccc:	28 f4       	brcc	.+10     	; 0x2cd8 <prvCheckPendingReadyList+0x4c>
    2cce:	e9 81       	ldd	r30, Y+1	; 0x01
    2cd0:	fa 81       	ldd	r31, Y+2	; 0x02
    2cd2:	86 89       	ldd	r24, Z+22	; 0x16
    2cd4:	80 93 b4 00 	sts	0x00B4, r24
    2cd8:	e9 81       	ldd	r30, Y+1	; 0x01
    2cda:	fa 81       	ldd	r31, Y+2	; 0x02
    2cdc:	86 89       	ldd	r24, Z+22	; 0x16
    2cde:	28 2f       	mov	r18, r24
    2ce0:	30 e0       	ldi	r19, 0x00	; 0
    2ce2:	c9 01       	movw	r24, r18
    2ce4:	88 0f       	add	r24, r24
    2ce6:	99 1f       	adc	r25, r25
    2ce8:	88 0f       	add	r24, r24
    2cea:	99 1f       	adc	r25, r25
    2cec:	88 0f       	add	r24, r24
    2cee:	99 1f       	adc	r25, r25
    2cf0:	82 0f       	add	r24, r18
    2cf2:	93 1f       	adc	r25, r19
    2cf4:	ac 01       	movw	r20, r24
    2cf6:	45 54       	subi	r20, 0x45	; 69
    2cf8:	5f 4f       	sbci	r21, 0xFF	; 255
    2cfa:	89 81       	ldd	r24, Y+1	; 0x01
    2cfc:	9a 81       	ldd	r25, Y+2	; 0x02
    2cfe:	9c 01       	movw	r18, r24
    2d00:	2e 5f       	subi	r18, 0xFE	; 254
    2d02:	3f 4f       	sbci	r19, 0xFF	; 255
    2d04:	ca 01       	movw	r24, r20
    2d06:	b9 01       	movw	r22, r18
    2d08:	0e 94 cf 18 	call	0x319e	; 0x319e <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2d0c:	80 91 e3 00 	lds	r24, 0x00E3
    2d10:	88 23       	and	r24, r24
    2d12:	09 f0       	breq	.+2      	; 0x2d16 <prvCheckPendingReadyList+0x8a>
    2d14:	c1 cf       	rjmp	.-126    	; 0x2c98 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    2d16:	0f 90       	pop	r0
    2d18:	0f 90       	pop	r0
    2d1a:	cf 91       	pop	r28
    2d1c:	df 91       	pop	r29
    2d1e:	08 95       	ret

00002d20 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    2d20:	df 93       	push	r29
    2d22:	cf 93       	push	r28
    2d24:	00 d0       	rcall	.+0      	; 0x2d26 <prvCheckDelayedList+0x6>
    2d26:	00 d0       	rcall	.+0      	; 0x2d28 <prvCheckDelayedList+0x8>
    2d28:	cd b7       	in	r28, 0x3d	; 61
    2d2a:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2d2c:	0e 94 14 24 	call	0x4828	; 0x4828 <xTaskGetTickCount>
    2d30:	20 91 b7 00 	lds	r18, 0x00B7
    2d34:	30 91 b8 00 	lds	r19, 0x00B8
    2d38:	82 1b       	sub	r24, r18
    2d3a:	93 0b       	sbc	r25, r19
    2d3c:	90 93 ba 00 	sts	0x00BA, r25
    2d40:	80 93 b9 00 	sts	0x00B9, r24
    2d44:	85 c0       	rjmp	.+266    	; 0x2e50 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2d46:	80 91 b5 00 	lds	r24, 0x00B5
    2d4a:	90 91 b6 00 	lds	r25, 0x00B6
    2d4e:	01 96       	adiw	r24, 0x01	; 1
    2d50:	90 93 b6 00 	sts	0x00B6, r25
    2d54:	80 93 b5 00 	sts	0x00B5, r24
		xPassedTicks--;
    2d58:	80 91 b9 00 	lds	r24, 0x00B9
    2d5c:	90 91 ba 00 	lds	r25, 0x00BA
    2d60:	01 97       	sbiw	r24, 0x01	; 1
    2d62:	90 93 ba 00 	sts	0x00BA, r25
    2d66:	80 93 b9 00 	sts	0x00B9, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2d6a:	80 91 b5 00 	lds	r24, 0x00B5
    2d6e:	90 91 b6 00 	lds	r25, 0x00B6
    2d72:	00 97       	sbiw	r24, 0x00	; 0
    2d74:	09 f0       	breq	.+2      	; 0x2d78 <prvCheckDelayedList+0x58>
    2d76:	64 c0       	rjmp	.+200    	; 0x2e40 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2d78:	80 91 df 00 	lds	r24, 0x00DF
    2d7c:	90 91 e0 00 	lds	r25, 0x00E0
    2d80:	9a 83       	std	Y+2, r25	; 0x02
    2d82:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2d84:	80 91 e1 00 	lds	r24, 0x00E1
    2d88:	90 91 e2 00 	lds	r25, 0x00E2
    2d8c:	90 93 e0 00 	sts	0x00E0, r25
    2d90:	80 93 df 00 	sts	0x00DF, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2d94:	89 81       	ldd	r24, Y+1	; 0x01
    2d96:	9a 81       	ldd	r25, Y+2	; 0x02
    2d98:	90 93 e2 00 	sts	0x00E2, r25
    2d9c:	80 93 e1 00 	sts	0x00E1, r24
    2da0:	4f c0       	rjmp	.+158    	; 0x2e40 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2da2:	e0 91 df 00 	lds	r30, 0x00DF
    2da6:	f0 91 e0 00 	lds	r31, 0x00E0
    2daa:	05 80       	ldd	r0, Z+5	; 0x05
    2dac:	f6 81       	ldd	r31, Z+6	; 0x06
    2dae:	e0 2d       	mov	r30, r0
    2db0:	86 81       	ldd	r24, Z+6	; 0x06
    2db2:	97 81       	ldd	r25, Z+7	; 0x07
    2db4:	9c 83       	std	Y+4, r25	; 0x04
    2db6:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2db8:	eb 81       	ldd	r30, Y+3	; 0x03
    2dba:	fc 81       	ldd	r31, Y+4	; 0x04
    2dbc:	22 81       	ldd	r18, Z+2	; 0x02
    2dbe:	33 81       	ldd	r19, Z+3	; 0x03
    2dc0:	80 91 b5 00 	lds	r24, 0x00B5
    2dc4:	90 91 b6 00 	lds	r25, 0x00B6
    2dc8:	82 17       	cp	r24, r18
    2dca:	93 07       	cpc	r25, r19
    2dcc:	08 f4       	brcc	.+2      	; 0x2dd0 <prvCheckDelayedList+0xb0>
    2dce:	40 c0       	rjmp	.+128    	; 0x2e50 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    2dd0:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    2dd2:	8b 81       	ldd	r24, Y+3	; 0x03
    2dd4:	9c 81       	ldd	r25, Y+4	; 0x04
    2dd6:	02 96       	adiw	r24, 0x02	; 2
    2dd8:	0e 94 87 19 	call	0x330e	; 0x330e <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    2ddc:	eb 81       	ldd	r30, Y+3	; 0x03
    2dde:	fc 81       	ldd	r31, Y+4	; 0x04
    2de0:	84 89       	ldd	r24, Z+20	; 0x14
    2de2:	95 89       	ldd	r25, Z+21	; 0x15
    2de4:	00 97       	sbiw	r24, 0x00	; 0
    2de6:	29 f0       	breq	.+10     	; 0x2df2 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    2de8:	8b 81       	ldd	r24, Y+3	; 0x03
    2dea:	9c 81       	ldd	r25, Y+4	; 0x04
    2dec:	0c 96       	adiw	r24, 0x0c	; 12
    2dee:	0e 94 87 19 	call	0x330e	; 0x330e <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2df2:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2df4:	eb 81       	ldd	r30, Y+3	; 0x03
    2df6:	fc 81       	ldd	r31, Y+4	; 0x04
    2df8:	96 89       	ldd	r25, Z+22	; 0x16
    2dfa:	80 91 b4 00 	lds	r24, 0x00B4
    2dfe:	89 17       	cp	r24, r25
    2e00:	28 f4       	brcc	.+10     	; 0x2e0c <prvCheckDelayedList+0xec>
    2e02:	eb 81       	ldd	r30, Y+3	; 0x03
    2e04:	fc 81       	ldd	r31, Y+4	; 0x04
    2e06:	86 89       	ldd	r24, Z+22	; 0x16
    2e08:	80 93 b4 00 	sts	0x00B4, r24
    2e0c:	eb 81       	ldd	r30, Y+3	; 0x03
    2e0e:	fc 81       	ldd	r31, Y+4	; 0x04
    2e10:	86 89       	ldd	r24, Z+22	; 0x16
    2e12:	28 2f       	mov	r18, r24
    2e14:	30 e0       	ldi	r19, 0x00	; 0
    2e16:	c9 01       	movw	r24, r18
    2e18:	88 0f       	add	r24, r24
    2e1a:	99 1f       	adc	r25, r25
    2e1c:	88 0f       	add	r24, r24
    2e1e:	99 1f       	adc	r25, r25
    2e20:	88 0f       	add	r24, r24
    2e22:	99 1f       	adc	r25, r25
    2e24:	82 0f       	add	r24, r18
    2e26:	93 1f       	adc	r25, r19
    2e28:	ac 01       	movw	r20, r24
    2e2a:	45 54       	subi	r20, 0x45	; 69
    2e2c:	5f 4f       	sbci	r21, 0xFF	; 255
    2e2e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e30:	9c 81       	ldd	r25, Y+4	; 0x04
    2e32:	9c 01       	movw	r18, r24
    2e34:	2e 5f       	subi	r18, 0xFE	; 254
    2e36:	3f 4f       	sbci	r19, 0xFF	; 255
    2e38:	ca 01       	movw	r24, r20
    2e3a:	b9 01       	movw	r22, r18
    2e3c:	0e 94 cf 18 	call	0x319e	; 0x319e <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2e40:	e0 91 df 00 	lds	r30, 0x00DF
    2e44:	f0 91 e0 00 	lds	r31, 0x00E0
    2e48:	80 81       	ld	r24, Z
    2e4a:	88 23       	and	r24, r24
    2e4c:	09 f0       	breq	.+2      	; 0x2e50 <prvCheckDelayedList+0x130>
    2e4e:	a9 cf       	rjmp	.-174    	; 0x2da2 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2e50:	80 91 b9 00 	lds	r24, 0x00B9
    2e54:	90 91 ba 00 	lds	r25, 0x00BA
    2e58:	00 97       	sbiw	r24, 0x00	; 0
    2e5a:	09 f0       	breq	.+2      	; 0x2e5e <prvCheckDelayedList+0x13e>
    2e5c:	74 cf       	rjmp	.-280    	; 0x2d46 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2e5e:	80 91 b5 00 	lds	r24, 0x00B5
    2e62:	90 91 b6 00 	lds	r25, 0x00B6
    2e66:	90 93 b8 00 	sts	0x00B8, r25
    2e6a:	80 93 b7 00 	sts	0x00B7, r24
}
    2e6e:	0f 90       	pop	r0
    2e70:	0f 90       	pop	r0
    2e72:	0f 90       	pop	r0
    2e74:	0f 90       	pop	r0
    2e76:	cf 91       	pop	r28
    2e78:	df 91       	pop	r29
    2e7a:	08 95       	ret

00002e7c <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2e7c:	df 93       	push	r29
    2e7e:	cf 93       	push	r28
    2e80:	00 d0       	rcall	.+0      	; 0x2e82 <vCoRoutineSchedule+0x6>
    2e82:	cd b7       	in	r28, 0x3d	; 61
    2e84:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    2e86:	0e 94 46 16 	call	0x2c8c	; 0x2c8c <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2e8a:	0e 94 90 16 	call	0x2d20	; 0x2d20 <prvCheckDelayedList>
    2e8e:	0a c0       	rjmp	.+20     	; 0x2ea4 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2e90:	80 91 b4 00 	lds	r24, 0x00B4
    2e94:	88 23       	and	r24, r24
    2e96:	09 f4       	brne	.+2      	; 0x2e9a <vCoRoutineSchedule+0x1e>
    2e98:	66 c0       	rjmp	.+204    	; 0x2f66 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    2e9a:	80 91 b4 00 	lds	r24, 0x00B4
    2e9e:	81 50       	subi	r24, 0x01	; 1
    2ea0:	80 93 b4 00 	sts	0x00B4, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2ea4:	80 91 b4 00 	lds	r24, 0x00B4
    2ea8:	28 2f       	mov	r18, r24
    2eaa:	30 e0       	ldi	r19, 0x00	; 0
    2eac:	c9 01       	movw	r24, r18
    2eae:	88 0f       	add	r24, r24
    2eb0:	99 1f       	adc	r25, r25
    2eb2:	88 0f       	add	r24, r24
    2eb4:	99 1f       	adc	r25, r25
    2eb6:	88 0f       	add	r24, r24
    2eb8:	99 1f       	adc	r25, r25
    2eba:	82 0f       	add	r24, r18
    2ebc:	93 1f       	adc	r25, r19
    2ebe:	fc 01       	movw	r30, r24
    2ec0:	e5 54       	subi	r30, 0x45	; 69
    2ec2:	ff 4f       	sbci	r31, 0xFF	; 255
    2ec4:	80 81       	ld	r24, Z
    2ec6:	88 23       	and	r24, r24
    2ec8:	19 f3       	breq	.-58     	; 0x2e90 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2eca:	80 91 b4 00 	lds	r24, 0x00B4
    2ece:	28 2f       	mov	r18, r24
    2ed0:	30 e0       	ldi	r19, 0x00	; 0
    2ed2:	c9 01       	movw	r24, r18
    2ed4:	88 0f       	add	r24, r24
    2ed6:	99 1f       	adc	r25, r25
    2ed8:	88 0f       	add	r24, r24
    2eda:	99 1f       	adc	r25, r25
    2edc:	88 0f       	add	r24, r24
    2ede:	99 1f       	adc	r25, r25
    2ee0:	82 0f       	add	r24, r18
    2ee2:	93 1f       	adc	r25, r19
    2ee4:	85 54       	subi	r24, 0x45	; 69
    2ee6:	9f 4f       	sbci	r25, 0xFF	; 255
    2ee8:	9a 83       	std	Y+2, r25	; 0x02
    2eea:	89 83       	std	Y+1, r24	; 0x01
    2eec:	e9 81       	ldd	r30, Y+1	; 0x01
    2eee:	fa 81       	ldd	r31, Y+2	; 0x02
    2ef0:	01 80       	ldd	r0, Z+1	; 0x01
    2ef2:	f2 81       	ldd	r31, Z+2	; 0x02
    2ef4:	e0 2d       	mov	r30, r0
    2ef6:	82 81       	ldd	r24, Z+2	; 0x02
    2ef8:	93 81       	ldd	r25, Z+3	; 0x03
    2efa:	e9 81       	ldd	r30, Y+1	; 0x01
    2efc:	fa 81       	ldd	r31, Y+2	; 0x02
    2efe:	92 83       	std	Z+2, r25	; 0x02
    2f00:	81 83       	std	Z+1, r24	; 0x01
    2f02:	e9 81       	ldd	r30, Y+1	; 0x01
    2f04:	fa 81       	ldd	r31, Y+2	; 0x02
    2f06:	21 81       	ldd	r18, Z+1	; 0x01
    2f08:	32 81       	ldd	r19, Z+2	; 0x02
    2f0a:	89 81       	ldd	r24, Y+1	; 0x01
    2f0c:	9a 81       	ldd	r25, Y+2	; 0x02
    2f0e:	03 96       	adiw	r24, 0x03	; 3
    2f10:	28 17       	cp	r18, r24
    2f12:	39 07       	cpc	r19, r25
    2f14:	59 f4       	brne	.+22     	; 0x2f2c <vCoRoutineSchedule+0xb0>
    2f16:	e9 81       	ldd	r30, Y+1	; 0x01
    2f18:	fa 81       	ldd	r31, Y+2	; 0x02
    2f1a:	01 80       	ldd	r0, Z+1	; 0x01
    2f1c:	f2 81       	ldd	r31, Z+2	; 0x02
    2f1e:	e0 2d       	mov	r30, r0
    2f20:	82 81       	ldd	r24, Z+2	; 0x02
    2f22:	93 81       	ldd	r25, Z+3	; 0x03
    2f24:	e9 81       	ldd	r30, Y+1	; 0x01
    2f26:	fa 81       	ldd	r31, Y+2	; 0x02
    2f28:	92 83       	std	Z+2, r25	; 0x02
    2f2a:	81 83       	std	Z+1, r24	; 0x01
    2f2c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f2e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f30:	01 80       	ldd	r0, Z+1	; 0x01
    2f32:	f2 81       	ldd	r31, Z+2	; 0x02
    2f34:	e0 2d       	mov	r30, r0
    2f36:	86 81       	ldd	r24, Z+6	; 0x06
    2f38:	97 81       	ldd	r25, Z+7	; 0x07
    2f3a:	90 93 b3 00 	sts	0x00B3, r25
    2f3e:	80 93 b2 00 	sts	0x00B2, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2f42:	e0 91 b2 00 	lds	r30, 0x00B2
    2f46:	f0 91 b3 00 	lds	r31, 0x00B3
    2f4a:	40 81       	ld	r20, Z
    2f4c:	51 81       	ldd	r21, Z+1	; 0x01
    2f4e:	80 91 b2 00 	lds	r24, 0x00B2
    2f52:	90 91 b3 00 	lds	r25, 0x00B3
    2f56:	e0 91 b2 00 	lds	r30, 0x00B2
    2f5a:	f0 91 b3 00 	lds	r31, 0x00B3
    2f5e:	27 89       	ldd	r18, Z+23	; 0x17
    2f60:	62 2f       	mov	r22, r18
    2f62:	fa 01       	movw	r30, r20
    2f64:	09 95       	icall

	return;
}
    2f66:	0f 90       	pop	r0
    2f68:	0f 90       	pop	r0
    2f6a:	cf 91       	pop	r28
    2f6c:	df 91       	pop	r29
    2f6e:	08 95       	ret

00002f70 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2f70:	df 93       	push	r29
    2f72:	cf 93       	push	r28
    2f74:	0f 92       	push	r0
    2f76:	cd b7       	in	r28, 0x3d	; 61
    2f78:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2f7a:	19 82       	std	Y+1, r1	; 0x01
    2f7c:	13 c0       	rjmp	.+38     	; 0x2fa4 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2f7e:	89 81       	ldd	r24, Y+1	; 0x01
    2f80:	28 2f       	mov	r18, r24
    2f82:	30 e0       	ldi	r19, 0x00	; 0
    2f84:	c9 01       	movw	r24, r18
    2f86:	88 0f       	add	r24, r24
    2f88:	99 1f       	adc	r25, r25
    2f8a:	88 0f       	add	r24, r24
    2f8c:	99 1f       	adc	r25, r25
    2f8e:	88 0f       	add	r24, r24
    2f90:	99 1f       	adc	r25, r25
    2f92:	82 0f       	add	r24, r18
    2f94:	93 1f       	adc	r25, r19
    2f96:	85 54       	subi	r24, 0x45	; 69
    2f98:	9f 4f       	sbci	r25, 0xFF	; 255
    2f9a:	0e 94 95 18 	call	0x312a	; 0x312a <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2f9e:	89 81       	ldd	r24, Y+1	; 0x01
    2fa0:	8f 5f       	subi	r24, 0xFF	; 255
    2fa2:	89 83       	std	Y+1, r24	; 0x01
    2fa4:	89 81       	ldd	r24, Y+1	; 0x01
    2fa6:	82 30       	cpi	r24, 0x02	; 2
    2fa8:	50 f3       	brcs	.-44     	; 0x2f7e <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2faa:	8d ec       	ldi	r24, 0xCD	; 205
    2fac:	90 e0       	ldi	r25, 0x00	; 0
    2fae:	0e 94 95 18 	call	0x312a	; 0x312a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2fb2:	86 ed       	ldi	r24, 0xD6	; 214
    2fb4:	90 e0       	ldi	r25, 0x00	; 0
    2fb6:	0e 94 95 18 	call	0x312a	; 0x312a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2fba:	83 ee       	ldi	r24, 0xE3	; 227
    2fbc:	90 e0       	ldi	r25, 0x00	; 0
    2fbe:	0e 94 95 18 	call	0x312a	; 0x312a <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2fc2:	8d ec       	ldi	r24, 0xCD	; 205
    2fc4:	90 e0       	ldi	r25, 0x00	; 0
    2fc6:	90 93 e0 00 	sts	0x00E0, r25
    2fca:	80 93 df 00 	sts	0x00DF, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2fce:	86 ed       	ldi	r24, 0xD6	; 214
    2fd0:	90 e0       	ldi	r25, 0x00	; 0
    2fd2:	90 93 e2 00 	sts	0x00E2, r25
    2fd6:	80 93 e1 00 	sts	0x00E1, r24
}
    2fda:	0f 90       	pop	r0
    2fdc:	cf 91       	pop	r28
    2fde:	df 91       	pop	r29
    2fe0:	08 95       	ret

00002fe2 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2fe2:	df 93       	push	r29
    2fe4:	cf 93       	push	r28
    2fe6:	00 d0       	rcall	.+0      	; 0x2fe8 <xCoRoutineRemoveFromEventList+0x6>
    2fe8:	00 d0       	rcall	.+0      	; 0x2fea <xCoRoutineRemoveFromEventList+0x8>
    2fea:	0f 92       	push	r0
    2fec:	cd b7       	in	r28, 0x3d	; 61
    2fee:	de b7       	in	r29, 0x3e	; 62
    2ff0:	9d 83       	std	Y+5, r25	; 0x05
    2ff2:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2ff4:	ec 81       	ldd	r30, Y+4	; 0x04
    2ff6:	fd 81       	ldd	r31, Y+5	; 0x05
    2ff8:	05 80       	ldd	r0, Z+5	; 0x05
    2ffa:	f6 81       	ldd	r31, Z+6	; 0x06
    2ffc:	e0 2d       	mov	r30, r0
    2ffe:	86 81       	ldd	r24, Z+6	; 0x06
    3000:	97 81       	ldd	r25, Z+7	; 0x07
    3002:	9b 83       	std	Y+3, r25	; 0x03
    3004:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    3006:	8a 81       	ldd	r24, Y+2	; 0x02
    3008:	9b 81       	ldd	r25, Y+3	; 0x03
    300a:	0c 96       	adiw	r24, 0x0c	; 12
    300c:	0e 94 87 19 	call	0x330e	; 0x330e <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    3010:	8a 81       	ldd	r24, Y+2	; 0x02
    3012:	9b 81       	ldd	r25, Y+3	; 0x03
    3014:	9c 01       	movw	r18, r24
    3016:	24 5f       	subi	r18, 0xF4	; 244
    3018:	3f 4f       	sbci	r19, 0xFF	; 255
    301a:	83 ee       	ldi	r24, 0xE3	; 227
    301c:	90 e0       	ldi	r25, 0x00	; 0
    301e:	b9 01       	movw	r22, r18
    3020:	0e 94 cf 18 	call	0x319e	; 0x319e <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    3024:	ea 81       	ldd	r30, Y+2	; 0x02
    3026:	fb 81       	ldd	r31, Y+3	; 0x03
    3028:	96 89       	ldd	r25, Z+22	; 0x16
    302a:	e0 91 b2 00 	lds	r30, 0x00B2
    302e:	f0 91 b3 00 	lds	r31, 0x00B3
    3032:	86 89       	ldd	r24, Z+22	; 0x16
    3034:	98 17       	cp	r25, r24
    3036:	18 f0       	brcs	.+6      	; 0x303e <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    3038:	81 e0       	ldi	r24, 0x01	; 1
    303a:	89 83       	std	Y+1, r24	; 0x01
    303c:	01 c0       	rjmp	.+2      	; 0x3040 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    303e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3040:	89 81       	ldd	r24, Y+1	; 0x01
}
    3042:	0f 90       	pop	r0
    3044:	0f 90       	pop	r0
    3046:	0f 90       	pop	r0
    3048:	0f 90       	pop	r0
    304a:	0f 90       	pop	r0
    304c:	cf 91       	pop	r28
    304e:	df 91       	pop	r29
    3050:	08 95       	ret

00003052 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    3052:	df 93       	push	r29
    3054:	cf 93       	push	r28
    3056:	00 d0       	rcall	.+0      	; 0x3058 <pvPortMalloc+0x6>
    3058:	00 d0       	rcall	.+0      	; 0x305a <pvPortMalloc+0x8>
    305a:	cd b7       	in	r28, 0x3d	; 61
    305c:	de b7       	in	r29, 0x3e	; 62
    305e:	9c 83       	std	Y+4, r25	; 0x04
    3060:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    3062:	1a 82       	std	Y+2, r1	; 0x02
    3064:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    3066:	0e 94 7e 23 	call	0x46fc	; 0x46fc <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    306a:	80 91 ec 00 	lds	r24, 0x00EC
    306e:	90 91 ed 00 	lds	r25, 0x00ED
    3072:	2b 81       	ldd	r18, Y+3	; 0x03
    3074:	3c 81       	ldd	r19, Y+4	; 0x04
    3076:	82 0f       	add	r24, r18
    3078:	93 1f       	adc	r25, r19
    307a:	26 e0       	ldi	r18, 0x06	; 6
    307c:	80 34       	cpi	r24, 0x40	; 64
    307e:	92 07       	cpc	r25, r18
    3080:	18 f5       	brcc	.+70     	; 0x30c8 <pvPortMalloc+0x76>
    3082:	20 91 ec 00 	lds	r18, 0x00EC
    3086:	30 91 ed 00 	lds	r19, 0x00ED
    308a:	8b 81       	ldd	r24, Y+3	; 0x03
    308c:	9c 81       	ldd	r25, Y+4	; 0x04
    308e:	28 0f       	add	r18, r24
    3090:	39 1f       	adc	r19, r25
    3092:	80 91 ec 00 	lds	r24, 0x00EC
    3096:	90 91 ed 00 	lds	r25, 0x00ED
    309a:	82 17       	cp	r24, r18
    309c:	93 07       	cpc	r25, r19
    309e:	a0 f4       	brcc	.+40     	; 0x30c8 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    30a0:	80 91 ec 00 	lds	r24, 0x00EC
    30a4:	90 91 ed 00 	lds	r25, 0x00ED
    30a8:	82 51       	subi	r24, 0x12	; 18
    30aa:	9f 4f       	sbci	r25, 0xFF	; 255
    30ac:	9a 83       	std	Y+2, r25	; 0x02
    30ae:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    30b0:	20 91 ec 00 	lds	r18, 0x00EC
    30b4:	30 91 ed 00 	lds	r19, 0x00ED
    30b8:	8b 81       	ldd	r24, Y+3	; 0x03
    30ba:	9c 81       	ldd	r25, Y+4	; 0x04
    30bc:	82 0f       	add	r24, r18
    30be:	93 1f       	adc	r25, r19
    30c0:	90 93 ed 00 	sts	0x00ED, r25
    30c4:	80 93 ec 00 	sts	0x00EC, r24
		}	
	}
	xTaskResumeAll();
    30c8:	0e 94 8a 23 	call	0x4714	; 0x4714 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    30cc:	89 81       	ldd	r24, Y+1	; 0x01
    30ce:	9a 81       	ldd	r25, Y+2	; 0x02
}
    30d0:	0f 90       	pop	r0
    30d2:	0f 90       	pop	r0
    30d4:	0f 90       	pop	r0
    30d6:	0f 90       	pop	r0
    30d8:	cf 91       	pop	r28
    30da:	df 91       	pop	r29
    30dc:	08 95       	ret

000030de <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    30de:	df 93       	push	r29
    30e0:	cf 93       	push	r28
    30e2:	00 d0       	rcall	.+0      	; 0x30e4 <vPortFree+0x6>
    30e4:	cd b7       	in	r28, 0x3d	; 61
    30e6:	de b7       	in	r29, 0x3e	; 62
    30e8:	9a 83       	std	Y+2, r25	; 0x02
    30ea:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    30ec:	0f 90       	pop	r0
    30ee:	0f 90       	pop	r0
    30f0:	cf 91       	pop	r28
    30f2:	df 91       	pop	r29
    30f4:	08 95       	ret

000030f6 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    30f6:	df 93       	push	r29
    30f8:	cf 93       	push	r28
    30fa:	cd b7       	in	r28, 0x3d	; 61
    30fc:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    30fe:	10 92 ed 00 	sts	0x00ED, r1
    3102:	10 92 ec 00 	sts	0x00EC, r1
}
    3106:	cf 91       	pop	r28
    3108:	df 91       	pop	r29
    310a:	08 95       	ret

0000310c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    310c:	df 93       	push	r29
    310e:	cf 93       	push	r28
    3110:	cd b7       	in	r28, 0x3d	; 61
    3112:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    3114:	20 91 ec 00 	lds	r18, 0x00EC
    3118:	30 91 ed 00 	lds	r19, 0x00ED
    311c:	80 e4       	ldi	r24, 0x40	; 64
    311e:	96 e0       	ldi	r25, 0x06	; 6
    3120:	82 1b       	sub	r24, r18
    3122:	93 0b       	sbc	r25, r19
}
    3124:	cf 91       	pop	r28
    3126:	df 91       	pop	r29
    3128:	08 95       	ret

0000312a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    312a:	df 93       	push	r29
    312c:	cf 93       	push	r28
    312e:	00 d0       	rcall	.+0      	; 0x3130 <vListInitialise+0x6>
    3130:	cd b7       	in	r28, 0x3d	; 61
    3132:	de b7       	in	r29, 0x3e	; 62
    3134:	9a 83       	std	Y+2, r25	; 0x02
    3136:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    3138:	89 81       	ldd	r24, Y+1	; 0x01
    313a:	9a 81       	ldd	r25, Y+2	; 0x02
    313c:	03 96       	adiw	r24, 0x03	; 3
    313e:	e9 81       	ldd	r30, Y+1	; 0x01
    3140:	fa 81       	ldd	r31, Y+2	; 0x02
    3142:	92 83       	std	Z+2, r25	; 0x02
    3144:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    3146:	e9 81       	ldd	r30, Y+1	; 0x01
    3148:	fa 81       	ldd	r31, Y+2	; 0x02
    314a:	8f ef       	ldi	r24, 0xFF	; 255
    314c:	9f ef       	ldi	r25, 0xFF	; 255
    314e:	94 83       	std	Z+4, r25	; 0x04
    3150:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    3152:	89 81       	ldd	r24, Y+1	; 0x01
    3154:	9a 81       	ldd	r25, Y+2	; 0x02
    3156:	03 96       	adiw	r24, 0x03	; 3
    3158:	e9 81       	ldd	r30, Y+1	; 0x01
    315a:	fa 81       	ldd	r31, Y+2	; 0x02
    315c:	96 83       	std	Z+6, r25	; 0x06
    315e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    3160:	89 81       	ldd	r24, Y+1	; 0x01
    3162:	9a 81       	ldd	r25, Y+2	; 0x02
    3164:	03 96       	adiw	r24, 0x03	; 3
    3166:	e9 81       	ldd	r30, Y+1	; 0x01
    3168:	fa 81       	ldd	r31, Y+2	; 0x02
    316a:	90 87       	std	Z+8, r25	; 0x08
    316c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    316e:	e9 81       	ldd	r30, Y+1	; 0x01
    3170:	fa 81       	ldd	r31, Y+2	; 0x02
    3172:	10 82       	st	Z, r1
}
    3174:	0f 90       	pop	r0
    3176:	0f 90       	pop	r0
    3178:	cf 91       	pop	r28
    317a:	df 91       	pop	r29
    317c:	08 95       	ret

0000317e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    317e:	df 93       	push	r29
    3180:	cf 93       	push	r28
    3182:	00 d0       	rcall	.+0      	; 0x3184 <vListInitialiseItem+0x6>
    3184:	cd b7       	in	r28, 0x3d	; 61
    3186:	de b7       	in	r29, 0x3e	; 62
    3188:	9a 83       	std	Y+2, r25	; 0x02
    318a:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    318c:	e9 81       	ldd	r30, Y+1	; 0x01
    318e:	fa 81       	ldd	r31, Y+2	; 0x02
    3190:	11 86       	std	Z+9, r1	; 0x09
    3192:	10 86       	std	Z+8, r1	; 0x08
}
    3194:	0f 90       	pop	r0
    3196:	0f 90       	pop	r0
    3198:	cf 91       	pop	r28
    319a:	df 91       	pop	r29
    319c:	08 95       	ret

0000319e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    319e:	df 93       	push	r29
    31a0:	cf 93       	push	r28
    31a2:	00 d0       	rcall	.+0      	; 0x31a4 <vListInsertEnd+0x6>
    31a4:	00 d0       	rcall	.+0      	; 0x31a6 <vListInsertEnd+0x8>
    31a6:	00 d0       	rcall	.+0      	; 0x31a8 <vListInsertEnd+0xa>
    31a8:	cd b7       	in	r28, 0x3d	; 61
    31aa:	de b7       	in	r29, 0x3e	; 62
    31ac:	9c 83       	std	Y+4, r25	; 0x04
    31ae:	8b 83       	std	Y+3, r24	; 0x03
    31b0:	7e 83       	std	Y+6, r23	; 0x06
    31b2:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    31b4:	eb 81       	ldd	r30, Y+3	; 0x03
    31b6:	fc 81       	ldd	r31, Y+4	; 0x04
    31b8:	81 81       	ldd	r24, Z+1	; 0x01
    31ba:	92 81       	ldd	r25, Z+2	; 0x02
    31bc:	9a 83       	std	Y+2, r25	; 0x02
    31be:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    31c0:	e9 81       	ldd	r30, Y+1	; 0x01
    31c2:	fa 81       	ldd	r31, Y+2	; 0x02
    31c4:	82 81       	ldd	r24, Z+2	; 0x02
    31c6:	93 81       	ldd	r25, Z+3	; 0x03
    31c8:	ed 81       	ldd	r30, Y+5	; 0x05
    31ca:	fe 81       	ldd	r31, Y+6	; 0x06
    31cc:	93 83       	std	Z+3, r25	; 0x03
    31ce:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    31d0:	eb 81       	ldd	r30, Y+3	; 0x03
    31d2:	fc 81       	ldd	r31, Y+4	; 0x04
    31d4:	81 81       	ldd	r24, Z+1	; 0x01
    31d6:	92 81       	ldd	r25, Z+2	; 0x02
    31d8:	ed 81       	ldd	r30, Y+5	; 0x05
    31da:	fe 81       	ldd	r31, Y+6	; 0x06
    31dc:	95 83       	std	Z+5, r25	; 0x05
    31de:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    31e0:	e9 81       	ldd	r30, Y+1	; 0x01
    31e2:	fa 81       	ldd	r31, Y+2	; 0x02
    31e4:	02 80       	ldd	r0, Z+2	; 0x02
    31e6:	f3 81       	ldd	r31, Z+3	; 0x03
    31e8:	e0 2d       	mov	r30, r0
    31ea:	8d 81       	ldd	r24, Y+5	; 0x05
    31ec:	9e 81       	ldd	r25, Y+6	; 0x06
    31ee:	95 83       	std	Z+5, r25	; 0x05
    31f0:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    31f2:	8d 81       	ldd	r24, Y+5	; 0x05
    31f4:	9e 81       	ldd	r25, Y+6	; 0x06
    31f6:	e9 81       	ldd	r30, Y+1	; 0x01
    31f8:	fa 81       	ldd	r31, Y+2	; 0x02
    31fa:	93 83       	std	Z+3, r25	; 0x03
    31fc:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    31fe:	8d 81       	ldd	r24, Y+5	; 0x05
    3200:	9e 81       	ldd	r25, Y+6	; 0x06
    3202:	eb 81       	ldd	r30, Y+3	; 0x03
    3204:	fc 81       	ldd	r31, Y+4	; 0x04
    3206:	92 83       	std	Z+2, r25	; 0x02
    3208:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    320a:	ed 81       	ldd	r30, Y+5	; 0x05
    320c:	fe 81       	ldd	r31, Y+6	; 0x06
    320e:	8b 81       	ldd	r24, Y+3	; 0x03
    3210:	9c 81       	ldd	r25, Y+4	; 0x04
    3212:	91 87       	std	Z+9, r25	; 0x09
    3214:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    3216:	eb 81       	ldd	r30, Y+3	; 0x03
    3218:	fc 81       	ldd	r31, Y+4	; 0x04
    321a:	80 81       	ld	r24, Z
    321c:	8f 5f       	subi	r24, 0xFF	; 255
    321e:	eb 81       	ldd	r30, Y+3	; 0x03
    3220:	fc 81       	ldd	r31, Y+4	; 0x04
    3222:	80 83       	st	Z, r24
}
    3224:	26 96       	adiw	r28, 0x06	; 6
    3226:	0f b6       	in	r0, 0x3f	; 63
    3228:	f8 94       	cli
    322a:	de bf       	out	0x3e, r29	; 62
    322c:	0f be       	out	0x3f, r0	; 63
    322e:	cd bf       	out	0x3d, r28	; 61
    3230:	cf 91       	pop	r28
    3232:	df 91       	pop	r29
    3234:	08 95       	ret

00003236 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    3236:	df 93       	push	r29
    3238:	cf 93       	push	r28
    323a:	cd b7       	in	r28, 0x3d	; 61
    323c:	de b7       	in	r29, 0x3e	; 62
    323e:	28 97       	sbiw	r28, 0x08	; 8
    3240:	0f b6       	in	r0, 0x3f	; 63
    3242:	f8 94       	cli
    3244:	de bf       	out	0x3e, r29	; 62
    3246:	0f be       	out	0x3f, r0	; 63
    3248:	cd bf       	out	0x3d, r28	; 61
    324a:	9e 83       	std	Y+6, r25	; 0x06
    324c:	8d 83       	std	Y+5, r24	; 0x05
    324e:	78 87       	std	Y+8, r23	; 0x08
    3250:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    3252:	ef 81       	ldd	r30, Y+7	; 0x07
    3254:	f8 85       	ldd	r31, Y+8	; 0x08
    3256:	80 81       	ld	r24, Z
    3258:	91 81       	ldd	r25, Z+1	; 0x01
    325a:	9a 83       	std	Y+2, r25	; 0x02
    325c:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    325e:	89 81       	ldd	r24, Y+1	; 0x01
    3260:	9a 81       	ldd	r25, Y+2	; 0x02
    3262:	2f ef       	ldi	r18, 0xFF	; 255
    3264:	8f 3f       	cpi	r24, 0xFF	; 255
    3266:	92 07       	cpc	r25, r18
    3268:	39 f4       	brne	.+14     	; 0x3278 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    326a:	ed 81       	ldd	r30, Y+5	; 0x05
    326c:	fe 81       	ldd	r31, Y+6	; 0x06
    326e:	87 81       	ldd	r24, Z+7	; 0x07
    3270:	90 85       	ldd	r25, Z+8	; 0x08
    3272:	9c 83       	std	Y+4, r25	; 0x04
    3274:	8b 83       	std	Y+3, r24	; 0x03
    3276:	18 c0       	rjmp	.+48     	; 0x32a8 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    3278:	8d 81       	ldd	r24, Y+5	; 0x05
    327a:	9e 81       	ldd	r25, Y+6	; 0x06
    327c:	03 96       	adiw	r24, 0x03	; 3
    327e:	9c 83       	std	Y+4, r25	; 0x04
    3280:	8b 83       	std	Y+3, r24	; 0x03
    3282:	06 c0       	rjmp	.+12     	; 0x3290 <vListInsert+0x5a>
    3284:	eb 81       	ldd	r30, Y+3	; 0x03
    3286:	fc 81       	ldd	r31, Y+4	; 0x04
    3288:	82 81       	ldd	r24, Z+2	; 0x02
    328a:	93 81       	ldd	r25, Z+3	; 0x03
    328c:	9c 83       	std	Y+4, r25	; 0x04
    328e:	8b 83       	std	Y+3, r24	; 0x03
    3290:	eb 81       	ldd	r30, Y+3	; 0x03
    3292:	fc 81       	ldd	r31, Y+4	; 0x04
    3294:	02 80       	ldd	r0, Z+2	; 0x02
    3296:	f3 81       	ldd	r31, Z+3	; 0x03
    3298:	e0 2d       	mov	r30, r0
    329a:	20 81       	ld	r18, Z
    329c:	31 81       	ldd	r19, Z+1	; 0x01
    329e:	89 81       	ldd	r24, Y+1	; 0x01
    32a0:	9a 81       	ldd	r25, Y+2	; 0x02
    32a2:	82 17       	cp	r24, r18
    32a4:	93 07       	cpc	r25, r19
    32a6:	70 f7       	brcc	.-36     	; 0x3284 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    32a8:	eb 81       	ldd	r30, Y+3	; 0x03
    32aa:	fc 81       	ldd	r31, Y+4	; 0x04
    32ac:	82 81       	ldd	r24, Z+2	; 0x02
    32ae:	93 81       	ldd	r25, Z+3	; 0x03
    32b0:	ef 81       	ldd	r30, Y+7	; 0x07
    32b2:	f8 85       	ldd	r31, Y+8	; 0x08
    32b4:	93 83       	std	Z+3, r25	; 0x03
    32b6:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    32b8:	ef 81       	ldd	r30, Y+7	; 0x07
    32ba:	f8 85       	ldd	r31, Y+8	; 0x08
    32bc:	02 80       	ldd	r0, Z+2	; 0x02
    32be:	f3 81       	ldd	r31, Z+3	; 0x03
    32c0:	e0 2d       	mov	r30, r0
    32c2:	8f 81       	ldd	r24, Y+7	; 0x07
    32c4:	98 85       	ldd	r25, Y+8	; 0x08
    32c6:	95 83       	std	Z+5, r25	; 0x05
    32c8:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    32ca:	ef 81       	ldd	r30, Y+7	; 0x07
    32cc:	f8 85       	ldd	r31, Y+8	; 0x08
    32ce:	8b 81       	ldd	r24, Y+3	; 0x03
    32d0:	9c 81       	ldd	r25, Y+4	; 0x04
    32d2:	95 83       	std	Z+5, r25	; 0x05
    32d4:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    32d6:	8f 81       	ldd	r24, Y+7	; 0x07
    32d8:	98 85       	ldd	r25, Y+8	; 0x08
    32da:	eb 81       	ldd	r30, Y+3	; 0x03
    32dc:	fc 81       	ldd	r31, Y+4	; 0x04
    32de:	93 83       	std	Z+3, r25	; 0x03
    32e0:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    32e2:	ef 81       	ldd	r30, Y+7	; 0x07
    32e4:	f8 85       	ldd	r31, Y+8	; 0x08
    32e6:	8d 81       	ldd	r24, Y+5	; 0x05
    32e8:	9e 81       	ldd	r25, Y+6	; 0x06
    32ea:	91 87       	std	Z+9, r25	; 0x09
    32ec:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    32ee:	ed 81       	ldd	r30, Y+5	; 0x05
    32f0:	fe 81       	ldd	r31, Y+6	; 0x06
    32f2:	80 81       	ld	r24, Z
    32f4:	8f 5f       	subi	r24, 0xFF	; 255
    32f6:	ed 81       	ldd	r30, Y+5	; 0x05
    32f8:	fe 81       	ldd	r31, Y+6	; 0x06
    32fa:	80 83       	st	Z, r24
}
    32fc:	28 96       	adiw	r28, 0x08	; 8
    32fe:	0f b6       	in	r0, 0x3f	; 63
    3300:	f8 94       	cli
    3302:	de bf       	out	0x3e, r29	; 62
    3304:	0f be       	out	0x3f, r0	; 63
    3306:	cd bf       	out	0x3d, r28	; 61
    3308:	cf 91       	pop	r28
    330a:	df 91       	pop	r29
    330c:	08 95       	ret

0000330e <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    330e:	df 93       	push	r29
    3310:	cf 93       	push	r28
    3312:	00 d0       	rcall	.+0      	; 0x3314 <vListRemove+0x6>
    3314:	00 d0       	rcall	.+0      	; 0x3316 <vListRemove+0x8>
    3316:	cd b7       	in	r28, 0x3d	; 61
    3318:	de b7       	in	r29, 0x3e	; 62
    331a:	9c 83       	std	Y+4, r25	; 0x04
    331c:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    331e:	eb 81       	ldd	r30, Y+3	; 0x03
    3320:	fc 81       	ldd	r31, Y+4	; 0x04
    3322:	a2 81       	ldd	r26, Z+2	; 0x02
    3324:	b3 81       	ldd	r27, Z+3	; 0x03
    3326:	eb 81       	ldd	r30, Y+3	; 0x03
    3328:	fc 81       	ldd	r31, Y+4	; 0x04
    332a:	84 81       	ldd	r24, Z+4	; 0x04
    332c:	95 81       	ldd	r25, Z+5	; 0x05
    332e:	15 96       	adiw	r26, 0x05	; 5
    3330:	9c 93       	st	X, r25
    3332:	8e 93       	st	-X, r24
    3334:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3336:	eb 81       	ldd	r30, Y+3	; 0x03
    3338:	fc 81       	ldd	r31, Y+4	; 0x04
    333a:	a4 81       	ldd	r26, Z+4	; 0x04
    333c:	b5 81       	ldd	r27, Z+5	; 0x05
    333e:	eb 81       	ldd	r30, Y+3	; 0x03
    3340:	fc 81       	ldd	r31, Y+4	; 0x04
    3342:	82 81       	ldd	r24, Z+2	; 0x02
    3344:	93 81       	ldd	r25, Z+3	; 0x03
    3346:	13 96       	adiw	r26, 0x03	; 3
    3348:	9c 93       	st	X, r25
    334a:	8e 93       	st	-X, r24
    334c:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    334e:	eb 81       	ldd	r30, Y+3	; 0x03
    3350:	fc 81       	ldd	r31, Y+4	; 0x04
    3352:	80 85       	ldd	r24, Z+8	; 0x08
    3354:	91 85       	ldd	r25, Z+9	; 0x09
    3356:	9a 83       	std	Y+2, r25	; 0x02
    3358:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    335a:	e9 81       	ldd	r30, Y+1	; 0x01
    335c:	fa 81       	ldd	r31, Y+2	; 0x02
    335e:	21 81       	ldd	r18, Z+1	; 0x01
    3360:	32 81       	ldd	r19, Z+2	; 0x02
    3362:	8b 81       	ldd	r24, Y+3	; 0x03
    3364:	9c 81       	ldd	r25, Y+4	; 0x04
    3366:	28 17       	cp	r18, r24
    3368:	39 07       	cpc	r19, r25
    336a:	41 f4       	brne	.+16     	; 0x337c <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    336c:	eb 81       	ldd	r30, Y+3	; 0x03
    336e:	fc 81       	ldd	r31, Y+4	; 0x04
    3370:	84 81       	ldd	r24, Z+4	; 0x04
    3372:	95 81       	ldd	r25, Z+5	; 0x05
    3374:	e9 81       	ldd	r30, Y+1	; 0x01
    3376:	fa 81       	ldd	r31, Y+2	; 0x02
    3378:	92 83       	std	Z+2, r25	; 0x02
    337a:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    337c:	eb 81       	ldd	r30, Y+3	; 0x03
    337e:	fc 81       	ldd	r31, Y+4	; 0x04
    3380:	11 86       	std	Z+9, r1	; 0x09
    3382:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    3384:	e9 81       	ldd	r30, Y+1	; 0x01
    3386:	fa 81       	ldd	r31, Y+2	; 0x02
    3388:	80 81       	ld	r24, Z
    338a:	81 50       	subi	r24, 0x01	; 1
    338c:	e9 81       	ldd	r30, Y+1	; 0x01
    338e:	fa 81       	ldd	r31, Y+2	; 0x02
    3390:	80 83       	st	Z, r24
}
    3392:	0f 90       	pop	r0
    3394:	0f 90       	pop	r0
    3396:	0f 90       	pop	r0
    3398:	0f 90       	pop	r0
    339a:	cf 91       	pop	r28
    339c:	df 91       	pop	r29
    339e:	08 95       	ret

000033a0 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    33a0:	df 93       	push	r29
    33a2:	cf 93       	push	r28
    33a4:	cd b7       	in	r28, 0x3d	; 61
    33a6:	de b7       	in	r29, 0x3e	; 62
    33a8:	28 97       	sbiw	r28, 0x08	; 8
    33aa:	0f b6       	in	r0, 0x3f	; 63
    33ac:	f8 94       	cli
    33ae:	de bf       	out	0x3e, r29	; 62
    33b0:	0f be       	out	0x3f, r0	; 63
    33b2:	cd bf       	out	0x3d, r28	; 61
    33b4:	9c 83       	std	Y+4, r25	; 0x04
    33b6:	8b 83       	std	Y+3, r24	; 0x03
    33b8:	7e 83       	std	Y+6, r23	; 0x06
    33ba:	6d 83       	std	Y+5, r22	; 0x05
    33bc:	58 87       	std	Y+8, r21	; 0x08
    33be:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    33c0:	eb 81       	ldd	r30, Y+3	; 0x03
    33c2:	fc 81       	ldd	r31, Y+4	; 0x04
    33c4:	81 e1       	ldi	r24, 0x11	; 17
    33c6:	80 83       	st	Z, r24
	pxTopOfStack--;
    33c8:	8b 81       	ldd	r24, Y+3	; 0x03
    33ca:	9c 81       	ldd	r25, Y+4	; 0x04
    33cc:	01 97       	sbiw	r24, 0x01	; 1
    33ce:	9c 83       	std	Y+4, r25	; 0x04
    33d0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    33d2:	eb 81       	ldd	r30, Y+3	; 0x03
    33d4:	fc 81       	ldd	r31, Y+4	; 0x04
    33d6:	82 e2       	ldi	r24, 0x22	; 34
    33d8:	80 83       	st	Z, r24
	pxTopOfStack--;
    33da:	8b 81       	ldd	r24, Y+3	; 0x03
    33dc:	9c 81       	ldd	r25, Y+4	; 0x04
    33de:	01 97       	sbiw	r24, 0x01	; 1
    33e0:	9c 83       	std	Y+4, r25	; 0x04
    33e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    33e4:	eb 81       	ldd	r30, Y+3	; 0x03
    33e6:	fc 81       	ldd	r31, Y+4	; 0x04
    33e8:	83 e3       	ldi	r24, 0x33	; 51
    33ea:	80 83       	st	Z, r24
	pxTopOfStack--;
    33ec:	8b 81       	ldd	r24, Y+3	; 0x03
    33ee:	9c 81       	ldd	r25, Y+4	; 0x04
    33f0:	01 97       	sbiw	r24, 0x01	; 1
    33f2:	9c 83       	std	Y+4, r25	; 0x04
    33f4:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    33f6:	8d 81       	ldd	r24, Y+5	; 0x05
    33f8:	9e 81       	ldd	r25, Y+6	; 0x06
    33fa:	9a 83       	std	Y+2, r25	; 0x02
    33fc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    33fe:	89 81       	ldd	r24, Y+1	; 0x01
    3400:	eb 81       	ldd	r30, Y+3	; 0x03
    3402:	fc 81       	ldd	r31, Y+4	; 0x04
    3404:	80 83       	st	Z, r24
	pxTopOfStack--;
    3406:	8b 81       	ldd	r24, Y+3	; 0x03
    3408:	9c 81       	ldd	r25, Y+4	; 0x04
    340a:	01 97       	sbiw	r24, 0x01	; 1
    340c:	9c 83       	std	Y+4, r25	; 0x04
    340e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3410:	89 81       	ldd	r24, Y+1	; 0x01
    3412:	9a 81       	ldd	r25, Y+2	; 0x02
    3414:	89 2f       	mov	r24, r25
    3416:	99 27       	eor	r25, r25
    3418:	9a 83       	std	Y+2, r25	; 0x02
    341a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    341c:	89 81       	ldd	r24, Y+1	; 0x01
    341e:	eb 81       	ldd	r30, Y+3	; 0x03
    3420:	fc 81       	ldd	r31, Y+4	; 0x04
    3422:	80 83       	st	Z, r24
	pxTopOfStack--;
    3424:	8b 81       	ldd	r24, Y+3	; 0x03
    3426:	9c 81       	ldd	r25, Y+4	; 0x04
    3428:	01 97       	sbiw	r24, 0x01	; 1
    342a:	9c 83       	std	Y+4, r25	; 0x04
    342c:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    342e:	eb 81       	ldd	r30, Y+3	; 0x03
    3430:	fc 81       	ldd	r31, Y+4	; 0x04
    3432:	10 82       	st	Z, r1
	pxTopOfStack--;
    3434:	8b 81       	ldd	r24, Y+3	; 0x03
    3436:	9c 81       	ldd	r25, Y+4	; 0x04
    3438:	01 97       	sbiw	r24, 0x01	; 1
    343a:	9c 83       	std	Y+4, r25	; 0x04
    343c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    343e:	eb 81       	ldd	r30, Y+3	; 0x03
    3440:	fc 81       	ldd	r31, Y+4	; 0x04
    3442:	80 e8       	ldi	r24, 0x80	; 128
    3444:	80 83       	st	Z, r24
	pxTopOfStack--;
    3446:	8b 81       	ldd	r24, Y+3	; 0x03
    3448:	9c 81       	ldd	r25, Y+4	; 0x04
    344a:	01 97       	sbiw	r24, 0x01	; 1
    344c:	9c 83       	std	Y+4, r25	; 0x04
    344e:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    3450:	eb 81       	ldd	r30, Y+3	; 0x03
    3452:	fc 81       	ldd	r31, Y+4	; 0x04
    3454:	10 82       	st	Z, r1
	pxTopOfStack--;
    3456:	8b 81       	ldd	r24, Y+3	; 0x03
    3458:	9c 81       	ldd	r25, Y+4	; 0x04
    345a:	01 97       	sbiw	r24, 0x01	; 1
    345c:	9c 83       	std	Y+4, r25	; 0x04
    345e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    3460:	eb 81       	ldd	r30, Y+3	; 0x03
    3462:	fc 81       	ldd	r31, Y+4	; 0x04
    3464:	82 e0       	ldi	r24, 0x02	; 2
    3466:	80 83       	st	Z, r24
	pxTopOfStack--;
    3468:	8b 81       	ldd	r24, Y+3	; 0x03
    346a:	9c 81       	ldd	r25, Y+4	; 0x04
    346c:	01 97       	sbiw	r24, 0x01	; 1
    346e:	9c 83       	std	Y+4, r25	; 0x04
    3470:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    3472:	eb 81       	ldd	r30, Y+3	; 0x03
    3474:	fc 81       	ldd	r31, Y+4	; 0x04
    3476:	83 e0       	ldi	r24, 0x03	; 3
    3478:	80 83       	st	Z, r24
	pxTopOfStack--;
    347a:	8b 81       	ldd	r24, Y+3	; 0x03
    347c:	9c 81       	ldd	r25, Y+4	; 0x04
    347e:	01 97       	sbiw	r24, 0x01	; 1
    3480:	9c 83       	std	Y+4, r25	; 0x04
    3482:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    3484:	eb 81       	ldd	r30, Y+3	; 0x03
    3486:	fc 81       	ldd	r31, Y+4	; 0x04
    3488:	84 e0       	ldi	r24, 0x04	; 4
    348a:	80 83       	st	Z, r24
	pxTopOfStack--;
    348c:	8b 81       	ldd	r24, Y+3	; 0x03
    348e:	9c 81       	ldd	r25, Y+4	; 0x04
    3490:	01 97       	sbiw	r24, 0x01	; 1
    3492:	9c 83       	std	Y+4, r25	; 0x04
    3494:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    3496:	eb 81       	ldd	r30, Y+3	; 0x03
    3498:	fc 81       	ldd	r31, Y+4	; 0x04
    349a:	85 e0       	ldi	r24, 0x05	; 5
    349c:	80 83       	st	Z, r24
	pxTopOfStack--;
    349e:	8b 81       	ldd	r24, Y+3	; 0x03
    34a0:	9c 81       	ldd	r25, Y+4	; 0x04
    34a2:	01 97       	sbiw	r24, 0x01	; 1
    34a4:	9c 83       	std	Y+4, r25	; 0x04
    34a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    34a8:	eb 81       	ldd	r30, Y+3	; 0x03
    34aa:	fc 81       	ldd	r31, Y+4	; 0x04
    34ac:	86 e0       	ldi	r24, 0x06	; 6
    34ae:	80 83       	st	Z, r24
	pxTopOfStack--;
    34b0:	8b 81       	ldd	r24, Y+3	; 0x03
    34b2:	9c 81       	ldd	r25, Y+4	; 0x04
    34b4:	01 97       	sbiw	r24, 0x01	; 1
    34b6:	9c 83       	std	Y+4, r25	; 0x04
    34b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    34ba:	eb 81       	ldd	r30, Y+3	; 0x03
    34bc:	fc 81       	ldd	r31, Y+4	; 0x04
    34be:	87 e0       	ldi	r24, 0x07	; 7
    34c0:	80 83       	st	Z, r24
	pxTopOfStack--;
    34c2:	8b 81       	ldd	r24, Y+3	; 0x03
    34c4:	9c 81       	ldd	r25, Y+4	; 0x04
    34c6:	01 97       	sbiw	r24, 0x01	; 1
    34c8:	9c 83       	std	Y+4, r25	; 0x04
    34ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    34cc:	eb 81       	ldd	r30, Y+3	; 0x03
    34ce:	fc 81       	ldd	r31, Y+4	; 0x04
    34d0:	88 e0       	ldi	r24, 0x08	; 8
    34d2:	80 83       	st	Z, r24
	pxTopOfStack--;
    34d4:	8b 81       	ldd	r24, Y+3	; 0x03
    34d6:	9c 81       	ldd	r25, Y+4	; 0x04
    34d8:	01 97       	sbiw	r24, 0x01	; 1
    34da:	9c 83       	std	Y+4, r25	; 0x04
    34dc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    34de:	eb 81       	ldd	r30, Y+3	; 0x03
    34e0:	fc 81       	ldd	r31, Y+4	; 0x04
    34e2:	89 e0       	ldi	r24, 0x09	; 9
    34e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    34e6:	8b 81       	ldd	r24, Y+3	; 0x03
    34e8:	9c 81       	ldd	r25, Y+4	; 0x04
    34ea:	01 97       	sbiw	r24, 0x01	; 1
    34ec:	9c 83       	std	Y+4, r25	; 0x04
    34ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    34f0:	eb 81       	ldd	r30, Y+3	; 0x03
    34f2:	fc 81       	ldd	r31, Y+4	; 0x04
    34f4:	80 e1       	ldi	r24, 0x10	; 16
    34f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    34f8:	8b 81       	ldd	r24, Y+3	; 0x03
    34fa:	9c 81       	ldd	r25, Y+4	; 0x04
    34fc:	01 97       	sbiw	r24, 0x01	; 1
    34fe:	9c 83       	std	Y+4, r25	; 0x04
    3500:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    3502:	eb 81       	ldd	r30, Y+3	; 0x03
    3504:	fc 81       	ldd	r31, Y+4	; 0x04
    3506:	81 e1       	ldi	r24, 0x11	; 17
    3508:	80 83       	st	Z, r24
	pxTopOfStack--;
    350a:	8b 81       	ldd	r24, Y+3	; 0x03
    350c:	9c 81       	ldd	r25, Y+4	; 0x04
    350e:	01 97       	sbiw	r24, 0x01	; 1
    3510:	9c 83       	std	Y+4, r25	; 0x04
    3512:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    3514:	eb 81       	ldd	r30, Y+3	; 0x03
    3516:	fc 81       	ldd	r31, Y+4	; 0x04
    3518:	82 e1       	ldi	r24, 0x12	; 18
    351a:	80 83       	st	Z, r24
	pxTopOfStack--;
    351c:	8b 81       	ldd	r24, Y+3	; 0x03
    351e:	9c 81       	ldd	r25, Y+4	; 0x04
    3520:	01 97       	sbiw	r24, 0x01	; 1
    3522:	9c 83       	std	Y+4, r25	; 0x04
    3524:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    3526:	eb 81       	ldd	r30, Y+3	; 0x03
    3528:	fc 81       	ldd	r31, Y+4	; 0x04
    352a:	83 e1       	ldi	r24, 0x13	; 19
    352c:	80 83       	st	Z, r24
	pxTopOfStack--;
    352e:	8b 81       	ldd	r24, Y+3	; 0x03
    3530:	9c 81       	ldd	r25, Y+4	; 0x04
    3532:	01 97       	sbiw	r24, 0x01	; 1
    3534:	9c 83       	std	Y+4, r25	; 0x04
    3536:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    3538:	eb 81       	ldd	r30, Y+3	; 0x03
    353a:	fc 81       	ldd	r31, Y+4	; 0x04
    353c:	84 e1       	ldi	r24, 0x14	; 20
    353e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3540:	8b 81       	ldd	r24, Y+3	; 0x03
    3542:	9c 81       	ldd	r25, Y+4	; 0x04
    3544:	01 97       	sbiw	r24, 0x01	; 1
    3546:	9c 83       	std	Y+4, r25	; 0x04
    3548:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    354a:	eb 81       	ldd	r30, Y+3	; 0x03
    354c:	fc 81       	ldd	r31, Y+4	; 0x04
    354e:	85 e1       	ldi	r24, 0x15	; 21
    3550:	80 83       	st	Z, r24
	pxTopOfStack--;
    3552:	8b 81       	ldd	r24, Y+3	; 0x03
    3554:	9c 81       	ldd	r25, Y+4	; 0x04
    3556:	01 97       	sbiw	r24, 0x01	; 1
    3558:	9c 83       	std	Y+4, r25	; 0x04
    355a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    355c:	eb 81       	ldd	r30, Y+3	; 0x03
    355e:	fc 81       	ldd	r31, Y+4	; 0x04
    3560:	86 e1       	ldi	r24, 0x16	; 22
    3562:	80 83       	st	Z, r24
	pxTopOfStack--;
    3564:	8b 81       	ldd	r24, Y+3	; 0x03
    3566:	9c 81       	ldd	r25, Y+4	; 0x04
    3568:	01 97       	sbiw	r24, 0x01	; 1
    356a:	9c 83       	std	Y+4, r25	; 0x04
    356c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    356e:	eb 81       	ldd	r30, Y+3	; 0x03
    3570:	fc 81       	ldd	r31, Y+4	; 0x04
    3572:	87 e1       	ldi	r24, 0x17	; 23
    3574:	80 83       	st	Z, r24
	pxTopOfStack--;
    3576:	8b 81       	ldd	r24, Y+3	; 0x03
    3578:	9c 81       	ldd	r25, Y+4	; 0x04
    357a:	01 97       	sbiw	r24, 0x01	; 1
    357c:	9c 83       	std	Y+4, r25	; 0x04
    357e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    3580:	eb 81       	ldd	r30, Y+3	; 0x03
    3582:	fc 81       	ldd	r31, Y+4	; 0x04
    3584:	88 e1       	ldi	r24, 0x18	; 24
    3586:	80 83       	st	Z, r24
	pxTopOfStack--;
    3588:	8b 81       	ldd	r24, Y+3	; 0x03
    358a:	9c 81       	ldd	r25, Y+4	; 0x04
    358c:	01 97       	sbiw	r24, 0x01	; 1
    358e:	9c 83       	std	Y+4, r25	; 0x04
    3590:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    3592:	eb 81       	ldd	r30, Y+3	; 0x03
    3594:	fc 81       	ldd	r31, Y+4	; 0x04
    3596:	89 e1       	ldi	r24, 0x19	; 25
    3598:	80 83       	st	Z, r24
	pxTopOfStack--;
    359a:	8b 81       	ldd	r24, Y+3	; 0x03
    359c:	9c 81       	ldd	r25, Y+4	; 0x04
    359e:	01 97       	sbiw	r24, 0x01	; 1
    35a0:	9c 83       	std	Y+4, r25	; 0x04
    35a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    35a4:	eb 81       	ldd	r30, Y+3	; 0x03
    35a6:	fc 81       	ldd	r31, Y+4	; 0x04
    35a8:	80 e2       	ldi	r24, 0x20	; 32
    35aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    35ac:	8b 81       	ldd	r24, Y+3	; 0x03
    35ae:	9c 81       	ldd	r25, Y+4	; 0x04
    35b0:	01 97       	sbiw	r24, 0x01	; 1
    35b2:	9c 83       	std	Y+4, r25	; 0x04
    35b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    35b6:	eb 81       	ldd	r30, Y+3	; 0x03
    35b8:	fc 81       	ldd	r31, Y+4	; 0x04
    35ba:	81 e2       	ldi	r24, 0x21	; 33
    35bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    35be:	8b 81       	ldd	r24, Y+3	; 0x03
    35c0:	9c 81       	ldd	r25, Y+4	; 0x04
    35c2:	01 97       	sbiw	r24, 0x01	; 1
    35c4:	9c 83       	std	Y+4, r25	; 0x04
    35c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    35c8:	eb 81       	ldd	r30, Y+3	; 0x03
    35ca:	fc 81       	ldd	r31, Y+4	; 0x04
    35cc:	82 e2       	ldi	r24, 0x22	; 34
    35ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    35d0:	8b 81       	ldd	r24, Y+3	; 0x03
    35d2:	9c 81       	ldd	r25, Y+4	; 0x04
    35d4:	01 97       	sbiw	r24, 0x01	; 1
    35d6:	9c 83       	std	Y+4, r25	; 0x04
    35d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    35da:	eb 81       	ldd	r30, Y+3	; 0x03
    35dc:	fc 81       	ldd	r31, Y+4	; 0x04
    35de:	83 e2       	ldi	r24, 0x23	; 35
    35e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    35e2:	8b 81       	ldd	r24, Y+3	; 0x03
    35e4:	9c 81       	ldd	r25, Y+4	; 0x04
    35e6:	01 97       	sbiw	r24, 0x01	; 1
    35e8:	9c 83       	std	Y+4, r25	; 0x04
    35ea:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    35ec:	8f 81       	ldd	r24, Y+7	; 0x07
    35ee:	98 85       	ldd	r25, Y+8	; 0x08
    35f0:	9a 83       	std	Y+2, r25	; 0x02
    35f2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    35f4:	89 81       	ldd	r24, Y+1	; 0x01
    35f6:	eb 81       	ldd	r30, Y+3	; 0x03
    35f8:	fc 81       	ldd	r31, Y+4	; 0x04
    35fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    35fc:	8b 81       	ldd	r24, Y+3	; 0x03
    35fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3600:	01 97       	sbiw	r24, 0x01	; 1
    3602:	9c 83       	std	Y+4, r25	; 0x04
    3604:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3606:	89 81       	ldd	r24, Y+1	; 0x01
    3608:	9a 81       	ldd	r25, Y+2	; 0x02
    360a:	89 2f       	mov	r24, r25
    360c:	99 27       	eor	r25, r25
    360e:	9a 83       	std	Y+2, r25	; 0x02
    3610:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3612:	89 81       	ldd	r24, Y+1	; 0x01
    3614:	eb 81       	ldd	r30, Y+3	; 0x03
    3616:	fc 81       	ldd	r31, Y+4	; 0x04
    3618:	80 83       	st	Z, r24
	pxTopOfStack--;
    361a:	8b 81       	ldd	r24, Y+3	; 0x03
    361c:	9c 81       	ldd	r25, Y+4	; 0x04
    361e:	01 97       	sbiw	r24, 0x01	; 1
    3620:	9c 83       	std	Y+4, r25	; 0x04
    3622:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    3624:	eb 81       	ldd	r30, Y+3	; 0x03
    3626:	fc 81       	ldd	r31, Y+4	; 0x04
    3628:	86 e2       	ldi	r24, 0x26	; 38
    362a:	80 83       	st	Z, r24
	pxTopOfStack--;
    362c:	8b 81       	ldd	r24, Y+3	; 0x03
    362e:	9c 81       	ldd	r25, Y+4	; 0x04
    3630:	01 97       	sbiw	r24, 0x01	; 1
    3632:	9c 83       	std	Y+4, r25	; 0x04
    3634:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    3636:	eb 81       	ldd	r30, Y+3	; 0x03
    3638:	fc 81       	ldd	r31, Y+4	; 0x04
    363a:	87 e2       	ldi	r24, 0x27	; 39
    363c:	80 83       	st	Z, r24
	pxTopOfStack--;
    363e:	8b 81       	ldd	r24, Y+3	; 0x03
    3640:	9c 81       	ldd	r25, Y+4	; 0x04
    3642:	01 97       	sbiw	r24, 0x01	; 1
    3644:	9c 83       	std	Y+4, r25	; 0x04
    3646:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    3648:	eb 81       	ldd	r30, Y+3	; 0x03
    364a:	fc 81       	ldd	r31, Y+4	; 0x04
    364c:	88 e2       	ldi	r24, 0x28	; 40
    364e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3650:	8b 81       	ldd	r24, Y+3	; 0x03
    3652:	9c 81       	ldd	r25, Y+4	; 0x04
    3654:	01 97       	sbiw	r24, 0x01	; 1
    3656:	9c 83       	std	Y+4, r25	; 0x04
    3658:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    365a:	eb 81       	ldd	r30, Y+3	; 0x03
    365c:	fc 81       	ldd	r31, Y+4	; 0x04
    365e:	89 e2       	ldi	r24, 0x29	; 41
    3660:	80 83       	st	Z, r24
	pxTopOfStack--;
    3662:	8b 81       	ldd	r24, Y+3	; 0x03
    3664:	9c 81       	ldd	r25, Y+4	; 0x04
    3666:	01 97       	sbiw	r24, 0x01	; 1
    3668:	9c 83       	std	Y+4, r25	; 0x04
    366a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    366c:	eb 81       	ldd	r30, Y+3	; 0x03
    366e:	fc 81       	ldd	r31, Y+4	; 0x04
    3670:	80 e3       	ldi	r24, 0x30	; 48
    3672:	80 83       	st	Z, r24
	pxTopOfStack--;
    3674:	8b 81       	ldd	r24, Y+3	; 0x03
    3676:	9c 81       	ldd	r25, Y+4	; 0x04
    3678:	01 97       	sbiw	r24, 0x01	; 1
    367a:	9c 83       	std	Y+4, r25	; 0x04
    367c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    367e:	eb 81       	ldd	r30, Y+3	; 0x03
    3680:	fc 81       	ldd	r31, Y+4	; 0x04
    3682:	81 e3       	ldi	r24, 0x31	; 49
    3684:	80 83       	st	Z, r24
	pxTopOfStack--;
    3686:	8b 81       	ldd	r24, Y+3	; 0x03
    3688:	9c 81       	ldd	r25, Y+4	; 0x04
    368a:	01 97       	sbiw	r24, 0x01	; 1
    368c:	9c 83       	std	Y+4, r25	; 0x04
    368e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3690:	8b 81       	ldd	r24, Y+3	; 0x03
    3692:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3694:	28 96       	adiw	r28, 0x08	; 8
    3696:	0f b6       	in	r0, 0x3f	; 63
    3698:	f8 94       	cli
    369a:	de bf       	out	0x3e, r29	; 62
    369c:	0f be       	out	0x3f, r0	; 63
    369e:	cd bf       	out	0x3d, r28	; 61
    36a0:	cf 91       	pop	r28
    36a2:	df 91       	pop	r29
    36a4:	08 95       	ret

000036a6 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    36a6:	df 93       	push	r29
    36a8:	cf 93       	push	r28
    36aa:	cd b7       	in	r28, 0x3d	; 61
    36ac:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    36ae:	0e 94 43 1c 	call	0x3886	; 0x3886 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    36b2:	a0 91 2e 07 	lds	r26, 0x072E
    36b6:	b0 91 2f 07 	lds	r27, 0x072F
    36ba:	cd 91       	ld	r28, X+
    36bc:	cd bf       	out	0x3d, r28	; 61
    36be:	dd 91       	ld	r29, X+
    36c0:	de bf       	out	0x3e, r29	; 62
    36c2:	ff 91       	pop	r31
    36c4:	ef 91       	pop	r30
    36c6:	df 91       	pop	r29
    36c8:	cf 91       	pop	r28
    36ca:	bf 91       	pop	r27
    36cc:	af 91       	pop	r26
    36ce:	9f 91       	pop	r25
    36d0:	8f 91       	pop	r24
    36d2:	7f 91       	pop	r23
    36d4:	6f 91       	pop	r22
    36d6:	5f 91       	pop	r21
    36d8:	4f 91       	pop	r20
    36da:	3f 91       	pop	r19
    36dc:	2f 91       	pop	r18
    36de:	1f 91       	pop	r17
    36e0:	0f 91       	pop	r16
    36e2:	ff 90       	pop	r15
    36e4:	ef 90       	pop	r14
    36e6:	df 90       	pop	r13
    36e8:	cf 90       	pop	r12
    36ea:	bf 90       	pop	r11
    36ec:	af 90       	pop	r10
    36ee:	9f 90       	pop	r9
    36f0:	8f 90       	pop	r8
    36f2:	7f 90       	pop	r7
    36f4:	6f 90       	pop	r6
    36f6:	5f 90       	pop	r5
    36f8:	4f 90       	pop	r4
    36fa:	3f 90       	pop	r3
    36fc:	2f 90       	pop	r2
    36fe:	1f 90       	pop	r1
    3700:	0f 90       	pop	r0
    3702:	0f be       	out	0x3f, r0	; 63
    3704:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3706:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    3708:	81 e0       	ldi	r24, 0x01	; 1
}
    370a:	cf 91       	pop	r28
    370c:	df 91       	pop	r29
    370e:	08 95       	ret

00003710 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3710:	df 93       	push	r29
    3712:	cf 93       	push	r28
    3714:	cd b7       	in	r28, 0x3d	; 61
    3716:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    3718:	cf 91       	pop	r28
    371a:	df 91       	pop	r29
    371c:	08 95       	ret

0000371e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    371e:	0f 92       	push	r0
    3720:	0f b6       	in	r0, 0x3f	; 63
    3722:	f8 94       	cli
    3724:	0f 92       	push	r0
    3726:	1f 92       	push	r1
    3728:	11 24       	eor	r1, r1
    372a:	2f 92       	push	r2
    372c:	3f 92       	push	r3
    372e:	4f 92       	push	r4
    3730:	5f 92       	push	r5
    3732:	6f 92       	push	r6
    3734:	7f 92       	push	r7
    3736:	8f 92       	push	r8
    3738:	9f 92       	push	r9
    373a:	af 92       	push	r10
    373c:	bf 92       	push	r11
    373e:	cf 92       	push	r12
    3740:	df 92       	push	r13
    3742:	ef 92       	push	r14
    3744:	ff 92       	push	r15
    3746:	0f 93       	push	r16
    3748:	1f 93       	push	r17
    374a:	2f 93       	push	r18
    374c:	3f 93       	push	r19
    374e:	4f 93       	push	r20
    3750:	5f 93       	push	r21
    3752:	6f 93       	push	r22
    3754:	7f 93       	push	r23
    3756:	8f 93       	push	r24
    3758:	9f 93       	push	r25
    375a:	af 93       	push	r26
    375c:	bf 93       	push	r27
    375e:	cf 93       	push	r28
    3760:	df 93       	push	r29
    3762:	ef 93       	push	r30
    3764:	ff 93       	push	r31
    3766:	a0 91 2e 07 	lds	r26, 0x072E
    376a:	b0 91 2f 07 	lds	r27, 0x072F
    376e:	0d b6       	in	r0, 0x3d	; 61
    3770:	0d 92       	st	X+, r0
    3772:	0e b6       	in	r0, 0x3e	; 62
    3774:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3776:	0e 94 1e 25 	call	0x4a3c	; 0x4a3c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    377a:	a0 91 2e 07 	lds	r26, 0x072E
    377e:	b0 91 2f 07 	lds	r27, 0x072F
    3782:	cd 91       	ld	r28, X+
    3784:	cd bf       	out	0x3d, r28	; 61
    3786:	dd 91       	ld	r29, X+
    3788:	de bf       	out	0x3e, r29	; 62
    378a:	ff 91       	pop	r31
    378c:	ef 91       	pop	r30
    378e:	df 91       	pop	r29
    3790:	cf 91       	pop	r28
    3792:	bf 91       	pop	r27
    3794:	af 91       	pop	r26
    3796:	9f 91       	pop	r25
    3798:	8f 91       	pop	r24
    379a:	7f 91       	pop	r23
    379c:	6f 91       	pop	r22
    379e:	5f 91       	pop	r21
    37a0:	4f 91       	pop	r20
    37a2:	3f 91       	pop	r19
    37a4:	2f 91       	pop	r18
    37a6:	1f 91       	pop	r17
    37a8:	0f 91       	pop	r16
    37aa:	ff 90       	pop	r15
    37ac:	ef 90       	pop	r14
    37ae:	df 90       	pop	r13
    37b0:	cf 90       	pop	r12
    37b2:	bf 90       	pop	r11
    37b4:	af 90       	pop	r10
    37b6:	9f 90       	pop	r9
    37b8:	8f 90       	pop	r8
    37ba:	7f 90       	pop	r7
    37bc:	6f 90       	pop	r6
    37be:	5f 90       	pop	r5
    37c0:	4f 90       	pop	r4
    37c2:	3f 90       	pop	r3
    37c4:	2f 90       	pop	r2
    37c6:	1f 90       	pop	r1
    37c8:	0f 90       	pop	r0
    37ca:	0f be       	out	0x3f, r0	; 63
    37cc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    37ce:	08 95       	ret

000037d0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    37d0:	0f 92       	push	r0
    37d2:	0f b6       	in	r0, 0x3f	; 63
    37d4:	f8 94       	cli
    37d6:	0f 92       	push	r0
    37d8:	1f 92       	push	r1
    37da:	11 24       	eor	r1, r1
    37dc:	2f 92       	push	r2
    37de:	3f 92       	push	r3
    37e0:	4f 92       	push	r4
    37e2:	5f 92       	push	r5
    37e4:	6f 92       	push	r6
    37e6:	7f 92       	push	r7
    37e8:	8f 92       	push	r8
    37ea:	9f 92       	push	r9
    37ec:	af 92       	push	r10
    37ee:	bf 92       	push	r11
    37f0:	cf 92       	push	r12
    37f2:	df 92       	push	r13
    37f4:	ef 92       	push	r14
    37f6:	ff 92       	push	r15
    37f8:	0f 93       	push	r16
    37fa:	1f 93       	push	r17
    37fc:	2f 93       	push	r18
    37fe:	3f 93       	push	r19
    3800:	4f 93       	push	r20
    3802:	5f 93       	push	r21
    3804:	6f 93       	push	r22
    3806:	7f 93       	push	r23
    3808:	8f 93       	push	r24
    380a:	9f 93       	push	r25
    380c:	af 93       	push	r26
    380e:	bf 93       	push	r27
    3810:	cf 93       	push	r28
    3812:	df 93       	push	r29
    3814:	ef 93       	push	r30
    3816:	ff 93       	push	r31
    3818:	a0 91 2e 07 	lds	r26, 0x072E
    381c:	b0 91 2f 07 	lds	r27, 0x072F
    3820:	0d b6       	in	r0, 0x3d	; 61
    3822:	0d 92       	st	X+, r0
    3824:	0e b6       	in	r0, 0x3e	; 62
    3826:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    3828:	0e 94 49 24 	call	0x4892	; 0x4892 <vTaskIncrementTick>
	vTaskSwitchContext();
    382c:	0e 94 1e 25 	call	0x4a3c	; 0x4a3c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3830:	a0 91 2e 07 	lds	r26, 0x072E
    3834:	b0 91 2f 07 	lds	r27, 0x072F
    3838:	cd 91       	ld	r28, X+
    383a:	cd bf       	out	0x3d, r28	; 61
    383c:	dd 91       	ld	r29, X+
    383e:	de bf       	out	0x3e, r29	; 62
    3840:	ff 91       	pop	r31
    3842:	ef 91       	pop	r30
    3844:	df 91       	pop	r29
    3846:	cf 91       	pop	r28
    3848:	bf 91       	pop	r27
    384a:	af 91       	pop	r26
    384c:	9f 91       	pop	r25
    384e:	8f 91       	pop	r24
    3850:	7f 91       	pop	r23
    3852:	6f 91       	pop	r22
    3854:	5f 91       	pop	r21
    3856:	4f 91       	pop	r20
    3858:	3f 91       	pop	r19
    385a:	2f 91       	pop	r18
    385c:	1f 91       	pop	r17
    385e:	0f 91       	pop	r16
    3860:	ff 90       	pop	r15
    3862:	ef 90       	pop	r14
    3864:	df 90       	pop	r13
    3866:	cf 90       	pop	r12
    3868:	bf 90       	pop	r11
    386a:	af 90       	pop	r10
    386c:	9f 90       	pop	r9
    386e:	8f 90       	pop	r8
    3870:	7f 90       	pop	r7
    3872:	6f 90       	pop	r6
    3874:	5f 90       	pop	r5
    3876:	4f 90       	pop	r4
    3878:	3f 90       	pop	r3
    387a:	2f 90       	pop	r2
    387c:	1f 90       	pop	r1
    387e:	0f 90       	pop	r0
    3880:	0f be       	out	0x3f, r0	; 63
    3882:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3884:	08 95       	ret

00003886 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    3886:	df 93       	push	r29
    3888:	cf 93       	push	r28
    388a:	00 d0       	rcall	.+0      	; 0x388c <prvSetupTimerInterrupt+0x6>
    388c:	00 d0       	rcall	.+0      	; 0x388e <prvSetupTimerInterrupt+0x8>
    388e:	00 d0       	rcall	.+0      	; 0x3890 <prvSetupTimerInterrupt+0xa>
    3890:	cd b7       	in	r28, 0x3d	; 61
    3892:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3894:	80 e4       	ldi	r24, 0x40	; 64
    3896:	9f e1       	ldi	r25, 0x1F	; 31
    3898:	a0 e0       	ldi	r26, 0x00	; 0
    389a:	b0 e0       	ldi	r27, 0x00	; 0
    389c:	8b 83       	std	Y+3, r24	; 0x03
    389e:	9c 83       	std	Y+4, r25	; 0x04
    38a0:	ad 83       	std	Y+5, r26	; 0x05
    38a2:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    38a4:	8b 81       	ldd	r24, Y+3	; 0x03
    38a6:	9c 81       	ldd	r25, Y+4	; 0x04
    38a8:	ad 81       	ldd	r26, Y+5	; 0x05
    38aa:	be 81       	ldd	r27, Y+6	; 0x06
    38ac:	68 94       	set
    38ae:	15 f8       	bld	r1, 5
    38b0:	b6 95       	lsr	r27
    38b2:	a7 95       	ror	r26
    38b4:	97 95       	ror	r25
    38b6:	87 95       	ror	r24
    38b8:	16 94       	lsr	r1
    38ba:	d1 f7       	brne	.-12     	; 0x38b0 <prvSetupTimerInterrupt+0x2a>
    38bc:	8b 83       	std	Y+3, r24	; 0x03
    38be:	9c 83       	std	Y+4, r25	; 0x04
    38c0:	ad 83       	std	Y+5, r26	; 0x05
    38c2:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    38c4:	8b 81       	ldd	r24, Y+3	; 0x03
    38c6:	9c 81       	ldd	r25, Y+4	; 0x04
    38c8:	ad 81       	ldd	r26, Y+5	; 0x05
    38ca:	be 81       	ldd	r27, Y+6	; 0x06
    38cc:	01 97       	sbiw	r24, 0x01	; 1
    38ce:	a1 09       	sbc	r26, r1
    38d0:	b1 09       	sbc	r27, r1
    38d2:	8b 83       	std	Y+3, r24	; 0x03
    38d4:	9c 83       	std	Y+4, r25	; 0x04
    38d6:	ad 83       	std	Y+5, r26	; 0x05
    38d8:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    38da:	8b 81       	ldd	r24, Y+3	; 0x03
    38dc:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    38de:	8b 81       	ldd	r24, Y+3	; 0x03
    38e0:	9c 81       	ldd	r25, Y+4	; 0x04
    38e2:	ad 81       	ldd	r26, Y+5	; 0x05
    38e4:	be 81       	ldd	r27, Y+6	; 0x06
    38e6:	89 2f       	mov	r24, r25
    38e8:	9a 2f       	mov	r25, r26
    38ea:	ab 2f       	mov	r26, r27
    38ec:	bb 27       	eor	r27, r27
    38ee:	8b 83       	std	Y+3, r24	; 0x03
    38f0:	9c 83       	std	Y+4, r25	; 0x04
    38f2:	ad 83       	std	Y+5, r26	; 0x05
    38f4:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    38f6:	8b 81       	ldd	r24, Y+3	; 0x03
    38f8:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    38fa:	eb e4       	ldi	r30, 0x4B	; 75
    38fc:	f0 e0       	ldi	r31, 0x00	; 0
    38fe:	8a 81       	ldd	r24, Y+2	; 0x02
    3900:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    3902:	ea e4       	ldi	r30, 0x4A	; 74
    3904:	f0 e0       	ldi	r31, 0x00	; 0
    3906:	89 81       	ldd	r24, Y+1	; 0x01
    3908:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    390a:	8b e0       	ldi	r24, 0x0B	; 11
    390c:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    390e:	ee e4       	ldi	r30, 0x4E	; 78
    3910:	f0 e0       	ldi	r31, 0x00	; 0
    3912:	89 81       	ldd	r24, Y+1	; 0x01
    3914:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    3916:	e9 e5       	ldi	r30, 0x59	; 89
    3918:	f0 e0       	ldi	r31, 0x00	; 0
    391a:	80 81       	ld	r24, Z
    391c:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    391e:	89 81       	ldd	r24, Y+1	; 0x01
    3920:	80 61       	ori	r24, 0x10	; 16
    3922:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    3924:	e9 e5       	ldi	r30, 0x59	; 89
    3926:	f0 e0       	ldi	r31, 0x00	; 0
    3928:	89 81       	ldd	r24, Y+1	; 0x01
    392a:	80 83       	st	Z, r24
}
    392c:	26 96       	adiw	r28, 0x06	; 6
    392e:	0f b6       	in	r0, 0x3f	; 63
    3930:	f8 94       	cli
    3932:	de bf       	out	0x3e, r29	; 62
    3934:	0f be       	out	0x3f, r0	; 63
    3936:	cd bf       	out	0x3d, r28	; 61
    3938:	cf 91       	pop	r28
    393a:	df 91       	pop	r29
    393c:	08 95       	ret

0000393e <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    393e:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <vPortYieldFromTick>
		asm volatile ( "reti" );
    3942:	18 95       	reti

00003944 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    3944:	df 93       	push	r29
    3946:	cf 93       	push	r28
    3948:	cd b7       	in	r28, 0x3d	; 61
    394a:	de b7       	in	r29, 0x3e	; 62
    394c:	28 97       	sbiw	r28, 0x08	; 8
    394e:	0f b6       	in	r0, 0x3f	; 63
    3950:	f8 94       	cli
    3952:	de bf       	out	0x3e, r29	; 62
    3954:	0f be       	out	0x3f, r0	; 63
    3956:	cd bf       	out	0x3d, r28	; 61
    3958:	8f 83       	std	Y+7, r24	; 0x07
    395a:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    395c:	1a 82       	std	Y+2, r1	; 0x02
    395e:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    3960:	8f 81       	ldd	r24, Y+7	; 0x07
    3962:	88 23       	and	r24, r24
    3964:	09 f4       	brne	.+2      	; 0x3968 <xQueueCreate+0x24>
    3966:	8c c0       	rjmp	.+280    	; 0x3a80 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    3968:	8f e1       	ldi	r24, 0x1F	; 31
    396a:	90 e0       	ldi	r25, 0x00	; 0
    396c:	0e 94 29 18 	call	0x3052	; 0x3052 <pvPortMalloc>
    3970:	9e 83       	std	Y+6, r25	; 0x06
    3972:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    3974:	8d 81       	ldd	r24, Y+5	; 0x05
    3976:	9e 81       	ldd	r25, Y+6	; 0x06
    3978:	00 97       	sbiw	r24, 0x00	; 0
    397a:	09 f4       	brne	.+2      	; 0x397e <xQueueCreate+0x3a>
    397c:	81 c0       	rjmp	.+258    	; 0x3a80 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    397e:	8f 81       	ldd	r24, Y+7	; 0x07
    3980:	28 2f       	mov	r18, r24
    3982:	30 e0       	ldi	r19, 0x00	; 0
    3984:	88 85       	ldd	r24, Y+8	; 0x08
    3986:	88 2f       	mov	r24, r24
    3988:	90 e0       	ldi	r25, 0x00	; 0
    398a:	ac 01       	movw	r20, r24
    398c:	24 9f       	mul	r18, r20
    398e:	c0 01       	movw	r24, r0
    3990:	25 9f       	mul	r18, r21
    3992:	90 0d       	add	r25, r0
    3994:	34 9f       	mul	r19, r20
    3996:	90 0d       	add	r25, r0
    3998:	11 24       	eor	r1, r1
    399a:	01 96       	adiw	r24, 0x01	; 1
    399c:	9c 83       	std	Y+4, r25	; 0x04
    399e:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    39a0:	8b 81       	ldd	r24, Y+3	; 0x03
    39a2:	9c 81       	ldd	r25, Y+4	; 0x04
    39a4:	0e 94 29 18 	call	0x3052	; 0x3052 <pvPortMalloc>
    39a8:	ed 81       	ldd	r30, Y+5	; 0x05
    39aa:	fe 81       	ldd	r31, Y+6	; 0x06
    39ac:	91 83       	std	Z+1, r25	; 0x01
    39ae:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    39b0:	ed 81       	ldd	r30, Y+5	; 0x05
    39b2:	fe 81       	ldd	r31, Y+6	; 0x06
    39b4:	80 81       	ld	r24, Z
    39b6:	91 81       	ldd	r25, Z+1	; 0x01
    39b8:	00 97       	sbiw	r24, 0x00	; 0
    39ba:	09 f4       	brne	.+2      	; 0x39be <xQueueCreate+0x7a>
    39bc:	5d c0       	rjmp	.+186    	; 0x3a78 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    39be:	ed 81       	ldd	r30, Y+5	; 0x05
    39c0:	fe 81       	ldd	r31, Y+6	; 0x06
    39c2:	40 81       	ld	r20, Z
    39c4:	51 81       	ldd	r21, Z+1	; 0x01
    39c6:	8f 81       	ldd	r24, Y+7	; 0x07
    39c8:	28 2f       	mov	r18, r24
    39ca:	30 e0       	ldi	r19, 0x00	; 0
    39cc:	88 85       	ldd	r24, Y+8	; 0x08
    39ce:	88 2f       	mov	r24, r24
    39d0:	90 e0       	ldi	r25, 0x00	; 0
    39d2:	bc 01       	movw	r22, r24
    39d4:	26 9f       	mul	r18, r22
    39d6:	c0 01       	movw	r24, r0
    39d8:	27 9f       	mul	r18, r23
    39da:	90 0d       	add	r25, r0
    39dc:	36 9f       	mul	r19, r22
    39de:	90 0d       	add	r25, r0
    39e0:	11 24       	eor	r1, r1
    39e2:	84 0f       	add	r24, r20
    39e4:	95 1f       	adc	r25, r21
    39e6:	ed 81       	ldd	r30, Y+5	; 0x05
    39e8:	fe 81       	ldd	r31, Y+6	; 0x06
    39ea:	93 83       	std	Z+3, r25	; 0x03
    39ec:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    39ee:	ed 81       	ldd	r30, Y+5	; 0x05
    39f0:	fe 81       	ldd	r31, Y+6	; 0x06
    39f2:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    39f4:	ed 81       	ldd	r30, Y+5	; 0x05
    39f6:	fe 81       	ldd	r31, Y+6	; 0x06
    39f8:	80 81       	ld	r24, Z
    39fa:	91 81       	ldd	r25, Z+1	; 0x01
    39fc:	ed 81       	ldd	r30, Y+5	; 0x05
    39fe:	fe 81       	ldd	r31, Y+6	; 0x06
    3a00:	95 83       	std	Z+5, r25	; 0x05
    3a02:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    3a04:	ed 81       	ldd	r30, Y+5	; 0x05
    3a06:	fe 81       	ldd	r31, Y+6	; 0x06
    3a08:	40 81       	ld	r20, Z
    3a0a:	51 81       	ldd	r21, Z+1	; 0x01
    3a0c:	8f 81       	ldd	r24, Y+7	; 0x07
    3a0e:	88 2f       	mov	r24, r24
    3a10:	90 e0       	ldi	r25, 0x00	; 0
    3a12:	9c 01       	movw	r18, r24
    3a14:	21 50       	subi	r18, 0x01	; 1
    3a16:	30 40       	sbci	r19, 0x00	; 0
    3a18:	88 85       	ldd	r24, Y+8	; 0x08
    3a1a:	88 2f       	mov	r24, r24
    3a1c:	90 e0       	ldi	r25, 0x00	; 0
    3a1e:	bc 01       	movw	r22, r24
    3a20:	26 9f       	mul	r18, r22
    3a22:	c0 01       	movw	r24, r0
    3a24:	27 9f       	mul	r18, r23
    3a26:	90 0d       	add	r25, r0
    3a28:	36 9f       	mul	r19, r22
    3a2a:	90 0d       	add	r25, r0
    3a2c:	11 24       	eor	r1, r1
    3a2e:	84 0f       	add	r24, r20
    3a30:	95 1f       	adc	r25, r21
    3a32:	ed 81       	ldd	r30, Y+5	; 0x05
    3a34:	fe 81       	ldd	r31, Y+6	; 0x06
    3a36:	97 83       	std	Z+7, r25	; 0x07
    3a38:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    3a3a:	ed 81       	ldd	r30, Y+5	; 0x05
    3a3c:	fe 81       	ldd	r31, Y+6	; 0x06
    3a3e:	8f 81       	ldd	r24, Y+7	; 0x07
    3a40:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    3a42:	ed 81       	ldd	r30, Y+5	; 0x05
    3a44:	fe 81       	ldd	r31, Y+6	; 0x06
    3a46:	88 85       	ldd	r24, Y+8	; 0x08
    3a48:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    3a4a:	ed 81       	ldd	r30, Y+5	; 0x05
    3a4c:	fe 81       	ldd	r31, Y+6	; 0x06
    3a4e:	8f ef       	ldi	r24, 0xFF	; 255
    3a50:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    3a52:	ed 81       	ldd	r30, Y+5	; 0x05
    3a54:	fe 81       	ldd	r31, Y+6	; 0x06
    3a56:	8f ef       	ldi	r24, 0xFF	; 255
    3a58:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    3a5a:	8d 81       	ldd	r24, Y+5	; 0x05
    3a5c:	9e 81       	ldd	r25, Y+6	; 0x06
    3a5e:	08 96       	adiw	r24, 0x08	; 8
    3a60:	0e 94 95 18 	call	0x312a	; 0x312a <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    3a64:	8d 81       	ldd	r24, Y+5	; 0x05
    3a66:	9e 81       	ldd	r25, Y+6	; 0x06
    3a68:	41 96       	adiw	r24, 0x11	; 17
    3a6a:	0e 94 95 18 	call	0x312a	; 0x312a <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    3a6e:	8d 81       	ldd	r24, Y+5	; 0x05
    3a70:	9e 81       	ldd	r25, Y+6	; 0x06
    3a72:	9a 83       	std	Y+2, r25	; 0x02
    3a74:	89 83       	std	Y+1, r24	; 0x01
    3a76:	04 c0       	rjmp	.+8      	; 0x3a80 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    3a78:	8d 81       	ldd	r24, Y+5	; 0x05
    3a7a:	9e 81       	ldd	r25, Y+6	; 0x06
    3a7c:	0e 94 6f 18 	call	0x30de	; 0x30de <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    3a80:	89 81       	ldd	r24, Y+1	; 0x01
    3a82:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3a84:	28 96       	adiw	r28, 0x08	; 8
    3a86:	0f b6       	in	r0, 0x3f	; 63
    3a88:	f8 94       	cli
    3a8a:	de bf       	out	0x3e, r29	; 62
    3a8c:	0f be       	out	0x3f, r0	; 63
    3a8e:	cd bf       	out	0x3d, r28	; 61
    3a90:	cf 91       	pop	r28
    3a92:	df 91       	pop	r29
    3a94:	08 95       	ret

00003a96 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
    3a96:	df 93       	push	r29
    3a98:	cf 93       	push	r28
    3a9a:	00 d0       	rcall	.+0      	; 0x3a9c <xQueueCreateCountingSemaphore+0x6>
    3a9c:	00 d0       	rcall	.+0      	; 0x3a9e <xQueueCreateCountingSemaphore+0x8>
    3a9e:	cd b7       	in	r28, 0x3d	; 61
    3aa0:	de b7       	in	r29, 0x3e	; 62
    3aa2:	8b 83       	std	Y+3, r24	; 0x03
    3aa4:	6c 83       	std	Y+4, r22	; 0x04
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
    3aa6:	8b 81       	ldd	r24, Y+3	; 0x03
    3aa8:	60 e0       	ldi	r22, 0x00	; 0
    3aaa:	0e 94 a2 1c 	call	0x3944	; 0x3944 <xQueueCreate>
    3aae:	9a 83       	std	Y+2, r25	; 0x02
    3ab0:	89 83       	std	Y+1, r24	; 0x01

		if( pxHandle != NULL )
    3ab2:	89 81       	ldd	r24, Y+1	; 0x01
    3ab4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ab6:	00 97       	sbiw	r24, 0x00	; 0
    3ab8:	21 f0       	breq	.+8      	; 0x3ac2 <xQueueCreateCountingSemaphore+0x2c>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
    3aba:	e9 81       	ldd	r30, Y+1	; 0x01
    3abc:	fa 81       	ldd	r31, Y+2	; 0x02
    3abe:	8c 81       	ldd	r24, Y+4	; 0x04
    3ac0:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
    3ac2:	89 81       	ldd	r24, Y+1	; 0x01
    3ac4:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    3ac6:	0f 90       	pop	r0
    3ac8:	0f 90       	pop	r0
    3aca:	0f 90       	pop	r0
    3acc:	0f 90       	pop	r0
    3ace:	cf 91       	pop	r28
    3ad0:	df 91       	pop	r29
    3ad2:	08 95       	ret

00003ad4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    3ad4:	df 93       	push	r29
    3ad6:	cf 93       	push	r28
    3ad8:	cd b7       	in	r28, 0x3d	; 61
    3ada:	de b7       	in	r29, 0x3e	; 62
    3adc:	2c 97       	sbiw	r28, 0x0c	; 12
    3ade:	0f b6       	in	r0, 0x3f	; 63
    3ae0:	f8 94       	cli
    3ae2:	de bf       	out	0x3e, r29	; 62
    3ae4:	0f be       	out	0x3f, r0	; 63
    3ae6:	cd bf       	out	0x3d, r28	; 61
    3ae8:	9e 83       	std	Y+6, r25	; 0x06
    3aea:	8d 83       	std	Y+5, r24	; 0x05
    3aec:	78 87       	std	Y+8, r23	; 0x08
    3aee:	6f 83       	std	Y+7, r22	; 0x07
    3af0:	5a 87       	std	Y+10, r21	; 0x0a
    3af2:	49 87       	std	Y+9, r20	; 0x09
    3af4:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    3af6:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3af8:	0f b6       	in	r0, 0x3f	; 63
    3afa:	f8 94       	cli
    3afc:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3afe:	ed 81       	ldd	r30, Y+5	; 0x05
    3b00:	fe 81       	ldd	r31, Y+6	; 0x06
    3b02:	92 8d       	ldd	r25, Z+26	; 0x1a
    3b04:	ed 81       	ldd	r30, Y+5	; 0x05
    3b06:	fe 81       	ldd	r31, Y+6	; 0x06
    3b08:	83 8d       	ldd	r24, Z+27	; 0x1b
    3b0a:	98 17       	cp	r25, r24
    3b0c:	d8 f4       	brcc	.+54     	; 0x3b44 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3b0e:	8d 81       	ldd	r24, Y+5	; 0x05
    3b10:	9e 81       	ldd	r25, Y+6	; 0x06
    3b12:	2f 81       	ldd	r18, Y+7	; 0x07
    3b14:	38 85       	ldd	r19, Y+8	; 0x08
    3b16:	b9 01       	movw	r22, r18
    3b18:	4b 85       	ldd	r20, Y+11	; 0x0b
    3b1a:	0e 94 a5 1f 	call	0x3f4a	; 0x3f4a <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3b1e:	ed 81       	ldd	r30, Y+5	; 0x05
    3b20:	fe 81       	ldd	r31, Y+6	; 0x06
    3b22:	81 89       	ldd	r24, Z+17	; 0x11
    3b24:	88 23       	and	r24, r24
    3b26:	49 f0       	breq	.+18     	; 0x3b3a <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    3b28:	8d 81       	ldd	r24, Y+5	; 0x05
    3b2a:	9e 81       	ldd	r25, Y+6	; 0x06
    3b2c:	41 96       	adiw	r24, 0x11	; 17
    3b2e:	0e 94 ba 25 	call	0x4b74	; 0x4b74 <xTaskRemoveFromEventList>
    3b32:	81 30       	cpi	r24, 0x01	; 1
    3b34:	11 f4       	brne	.+4      	; 0x3b3a <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    3b36:	0e 94 8f 1b 	call	0x371e	; 0x371e <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    3b3a:	0f 90       	pop	r0
    3b3c:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    3b3e:	81 e0       	ldi	r24, 0x01	; 1
    3b40:	8c 87       	std	Y+12, r24	; 0x0c
    3b42:	5c c0       	rjmp	.+184    	; 0x3bfc <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3b44:	89 85       	ldd	r24, Y+9	; 0x09
    3b46:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b48:	00 97       	sbiw	r24, 0x00	; 0
    3b4a:	21 f4       	brne	.+8      	; 0x3b54 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3b4c:	0f 90       	pop	r0
    3b4e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3b50:	1c 86       	std	Y+12, r1	; 0x0c
    3b52:	54 c0       	rjmp	.+168    	; 0x3bfc <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    3b54:	89 81       	ldd	r24, Y+1	; 0x01
    3b56:	88 23       	and	r24, r24
    3b58:	31 f4       	brne	.+12     	; 0x3b66 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3b5a:	ce 01       	movw	r24, r28
    3b5c:	02 96       	adiw	r24, 0x02	; 2
    3b5e:	0e 94 22 26 	call	0x4c44	; 0x4c44 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3b62:	81 e0       	ldi	r24, 0x01	; 1
    3b64:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    3b66:	0f 90       	pop	r0
    3b68:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3b6a:	0e 94 7e 23 	call	0x46fc	; 0x46fc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3b6e:	0f b6       	in	r0, 0x3f	; 63
    3b70:	f8 94       	cli
    3b72:	0f 92       	push	r0
    3b74:	ed 81       	ldd	r30, Y+5	; 0x05
    3b76:	fe 81       	ldd	r31, Y+6	; 0x06
    3b78:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b7a:	8f 3f       	cpi	r24, 0xFF	; 255
    3b7c:	19 f4       	brne	.+6      	; 0x3b84 <xQueueGenericSend+0xb0>
    3b7e:	ed 81       	ldd	r30, Y+5	; 0x05
    3b80:	fe 81       	ldd	r31, Y+6	; 0x06
    3b82:	15 8e       	std	Z+29, r1	; 0x1d
    3b84:	ed 81       	ldd	r30, Y+5	; 0x05
    3b86:	fe 81       	ldd	r31, Y+6	; 0x06
    3b88:	86 8d       	ldd	r24, Z+30	; 0x1e
    3b8a:	8f 3f       	cpi	r24, 0xFF	; 255
    3b8c:	19 f4       	brne	.+6      	; 0x3b94 <xQueueGenericSend+0xc0>
    3b8e:	ed 81       	ldd	r30, Y+5	; 0x05
    3b90:	fe 81       	ldd	r31, Y+6	; 0x06
    3b92:	16 8e       	std	Z+30, r1	; 0x1e
    3b94:	0f 90       	pop	r0
    3b96:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3b98:	ce 01       	movw	r24, r28
    3b9a:	02 96       	adiw	r24, 0x02	; 2
    3b9c:	9e 01       	movw	r18, r28
    3b9e:	27 5f       	subi	r18, 0xF7	; 247
    3ba0:	3f 4f       	sbci	r19, 0xFF	; 255
    3ba2:	b9 01       	movw	r22, r18
    3ba4:	0e 94 3b 26 	call	0x4c76	; 0x4c76 <xTaskCheckForTimeOut>
    3ba8:	88 23       	and	r24, r24
    3baa:	09 f5       	brne	.+66     	; 0x3bee <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3bac:	8d 81       	ldd	r24, Y+5	; 0x05
    3bae:	9e 81       	ldd	r25, Y+6	; 0x06
    3bb0:	0e 94 09 21 	call	0x4212	; 0x4212 <prvIsQueueFull>
    3bb4:	88 23       	and	r24, r24
    3bb6:	a1 f0       	breq	.+40     	; 0x3be0 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3bb8:	8d 81       	ldd	r24, Y+5	; 0x05
    3bba:	9e 81       	ldd	r25, Y+6	; 0x06
    3bbc:	08 96       	adiw	r24, 0x08	; 8
    3bbe:	29 85       	ldd	r18, Y+9	; 0x09
    3bc0:	3a 85       	ldd	r19, Y+10	; 0x0a
    3bc2:	b9 01       	movw	r22, r18
    3bc4:	0e 94 84 25 	call	0x4b08	; 0x4b08 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    3bc8:	8d 81       	ldd	r24, Y+5	; 0x05
    3bca:	9e 81       	ldd	r25, Y+6	; 0x06
    3bcc:	0e 94 82 20 	call	0x4104	; 0x4104 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3bd0:	0e 94 8a 23 	call	0x4714	; 0x4714 <xTaskResumeAll>
    3bd4:	88 23       	and	r24, r24
    3bd6:	09 f0       	breq	.+2      	; 0x3bda <xQueueGenericSend+0x106>
    3bd8:	8f cf       	rjmp	.-226    	; 0x3af8 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    3bda:	0e 94 8f 1b 	call	0x371e	; 0x371e <vPortYield>
    3bde:	8c cf       	rjmp	.-232    	; 0x3af8 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3be0:	8d 81       	ldd	r24, Y+5	; 0x05
    3be2:	9e 81       	ldd	r25, Y+6	; 0x06
    3be4:	0e 94 82 20 	call	0x4104	; 0x4104 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3be8:	0e 94 8a 23 	call	0x4714	; 0x4714 <xTaskResumeAll>
    3bec:	85 cf       	rjmp	.-246    	; 0x3af8 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3bee:	8d 81       	ldd	r24, Y+5	; 0x05
    3bf0:	9e 81       	ldd	r25, Y+6	; 0x06
    3bf2:	0e 94 82 20 	call	0x4104	; 0x4104 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3bf6:	0e 94 8a 23 	call	0x4714	; 0x4714 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    3bfa:	1c 86       	std	Y+12, r1	; 0x0c
    3bfc:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    3bfe:	2c 96       	adiw	r28, 0x0c	; 12
    3c00:	0f b6       	in	r0, 0x3f	; 63
    3c02:	f8 94       	cli
    3c04:	de bf       	out	0x3e, r29	; 62
    3c06:	0f be       	out	0x3f, r0	; 63
    3c08:	cd bf       	out	0x3d, r28	; 61
    3c0a:	cf 91       	pop	r28
    3c0c:	df 91       	pop	r29
    3c0e:	08 95       	ret

00003c10 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    3c10:	df 93       	push	r29
    3c12:	cf 93       	push	r28
    3c14:	cd b7       	in	r28, 0x3d	; 61
    3c16:	de b7       	in	r29, 0x3e	; 62
    3c18:	29 97       	sbiw	r28, 0x09	; 9
    3c1a:	0f b6       	in	r0, 0x3f	; 63
    3c1c:	f8 94       	cli
    3c1e:	de bf       	out	0x3e, r29	; 62
    3c20:	0f be       	out	0x3f, r0	; 63
    3c22:	cd bf       	out	0x3d, r28	; 61
    3c24:	9c 83       	std	Y+4, r25	; 0x04
    3c26:	8b 83       	std	Y+3, r24	; 0x03
    3c28:	7e 83       	std	Y+6, r23	; 0x06
    3c2a:	6d 83       	std	Y+5, r22	; 0x05
    3c2c:	58 87       	std	Y+8, r21	; 0x08
    3c2e:	4f 83       	std	Y+7, r20	; 0x07
    3c30:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3c32:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3c34:	eb 81       	ldd	r30, Y+3	; 0x03
    3c36:	fc 81       	ldd	r31, Y+4	; 0x04
    3c38:	92 8d       	ldd	r25, Z+26	; 0x1a
    3c3a:	eb 81       	ldd	r30, Y+3	; 0x03
    3c3c:	fc 81       	ldd	r31, Y+4	; 0x04
    3c3e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3c40:	98 17       	cp	r25, r24
    3c42:	40 f5       	brcc	.+80     	; 0x3c94 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3c44:	8b 81       	ldd	r24, Y+3	; 0x03
    3c46:	9c 81       	ldd	r25, Y+4	; 0x04
    3c48:	2d 81       	ldd	r18, Y+5	; 0x05
    3c4a:	3e 81       	ldd	r19, Y+6	; 0x06
    3c4c:	b9 01       	movw	r22, r18
    3c4e:	49 85       	ldd	r20, Y+9	; 0x09
    3c50:	0e 94 a5 1f 	call	0x3f4a	; 0x3f4a <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3c54:	eb 81       	ldd	r30, Y+3	; 0x03
    3c56:	fc 81       	ldd	r31, Y+4	; 0x04
    3c58:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c5a:	8f 3f       	cpi	r24, 0xFF	; 255
    3c5c:	89 f4       	brne	.+34     	; 0x3c80 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3c5e:	eb 81       	ldd	r30, Y+3	; 0x03
    3c60:	fc 81       	ldd	r31, Y+4	; 0x04
    3c62:	81 89       	ldd	r24, Z+17	; 0x11
    3c64:	88 23       	and	r24, r24
    3c66:	99 f0       	breq	.+38     	; 0x3c8e <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3c68:	8b 81       	ldd	r24, Y+3	; 0x03
    3c6a:	9c 81       	ldd	r25, Y+4	; 0x04
    3c6c:	41 96       	adiw	r24, 0x11	; 17
    3c6e:	0e 94 ba 25 	call	0x4b74	; 0x4b74 <xTaskRemoveFromEventList>
    3c72:	88 23       	and	r24, r24
    3c74:	61 f0       	breq	.+24     	; 0x3c8e <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    3c76:	ef 81       	ldd	r30, Y+7	; 0x07
    3c78:	f8 85       	ldd	r31, Y+8	; 0x08
    3c7a:	81 e0       	ldi	r24, 0x01	; 1
    3c7c:	80 83       	st	Z, r24
    3c7e:	07 c0       	rjmp	.+14     	; 0x3c8e <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3c80:	eb 81       	ldd	r30, Y+3	; 0x03
    3c82:	fc 81       	ldd	r31, Y+4	; 0x04
    3c84:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c86:	8f 5f       	subi	r24, 0xFF	; 255
    3c88:	eb 81       	ldd	r30, Y+3	; 0x03
    3c8a:	fc 81       	ldd	r31, Y+4	; 0x04
    3c8c:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3c8e:	81 e0       	ldi	r24, 0x01	; 1
    3c90:	8a 83       	std	Y+2, r24	; 0x02
    3c92:	01 c0       	rjmp	.+2      	; 0x3c96 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3c94:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3c96:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3c98:	29 96       	adiw	r28, 0x09	; 9
    3c9a:	0f b6       	in	r0, 0x3f	; 63
    3c9c:	f8 94       	cli
    3c9e:	de bf       	out	0x3e, r29	; 62
    3ca0:	0f be       	out	0x3f, r0	; 63
    3ca2:	cd bf       	out	0x3d, r28	; 61
    3ca4:	cf 91       	pop	r28
    3ca6:	df 91       	pop	r29
    3ca8:	08 95       	ret

00003caa <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    3caa:	df 93       	push	r29
    3cac:	cf 93       	push	r28
    3cae:	cd b7       	in	r28, 0x3d	; 61
    3cb0:	de b7       	in	r29, 0x3e	; 62
    3cb2:	2e 97       	sbiw	r28, 0x0e	; 14
    3cb4:	0f b6       	in	r0, 0x3f	; 63
    3cb6:	f8 94       	cli
    3cb8:	de bf       	out	0x3e, r29	; 62
    3cba:	0f be       	out	0x3f, r0	; 63
    3cbc:	cd bf       	out	0x3d, r28	; 61
    3cbe:	98 87       	std	Y+8, r25	; 0x08
    3cc0:	8f 83       	std	Y+7, r24	; 0x07
    3cc2:	7a 87       	std	Y+10, r23	; 0x0a
    3cc4:	69 87       	std	Y+9, r22	; 0x09
    3cc6:	5c 87       	std	Y+12, r21	; 0x0c
    3cc8:	4b 87       	std	Y+11, r20	; 0x0b
    3cca:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    3ccc:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    3cce:	0f b6       	in	r0, 0x3f	; 63
    3cd0:	f8 94       	cli
    3cd2:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3cd4:	ef 81       	ldd	r30, Y+7	; 0x07
    3cd6:	f8 85       	ldd	r31, Y+8	; 0x08
    3cd8:	82 8d       	ldd	r24, Z+26	; 0x1a
    3cda:	88 23       	and	r24, r24
    3cdc:	09 f4       	brne	.+2      	; 0x3ce0 <xQueueGenericReceive+0x36>
    3cde:	3f c0       	rjmp	.+126    	; 0x3d5e <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    3ce0:	ef 81       	ldd	r30, Y+7	; 0x07
    3ce2:	f8 85       	ldd	r31, Y+8	; 0x08
    3ce4:	86 81       	ldd	r24, Z+6	; 0x06
    3ce6:	97 81       	ldd	r25, Z+7	; 0x07
    3ce8:	9a 83       	std	Y+2, r25	; 0x02
    3cea:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3cec:	8f 81       	ldd	r24, Y+7	; 0x07
    3cee:	98 85       	ldd	r25, Y+8	; 0x08
    3cf0:	29 85       	ldd	r18, Y+9	; 0x09
    3cf2:	3a 85       	ldd	r19, Y+10	; 0x0a
    3cf4:	b9 01       	movw	r22, r18
    3cf6:	0e 94 3a 20 	call	0x4074	; 0x4074 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    3cfa:	8d 85       	ldd	r24, Y+13	; 0x0d
    3cfc:	88 23       	and	r24, r24
    3cfe:	b1 f4       	brne	.+44     	; 0x3d2c <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    3d00:	ef 81       	ldd	r30, Y+7	; 0x07
    3d02:	f8 85       	ldd	r31, Y+8	; 0x08
    3d04:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d06:	81 50       	subi	r24, 0x01	; 1
    3d08:	ef 81       	ldd	r30, Y+7	; 0x07
    3d0a:	f8 85       	ldd	r31, Y+8	; 0x08
    3d0c:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3d0e:	ef 81       	ldd	r30, Y+7	; 0x07
    3d10:	f8 85       	ldd	r31, Y+8	; 0x08
    3d12:	80 85       	ldd	r24, Z+8	; 0x08
    3d14:	88 23       	and	r24, r24
    3d16:	f1 f0       	breq	.+60     	; 0x3d54 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    3d18:	8f 81       	ldd	r24, Y+7	; 0x07
    3d1a:	98 85       	ldd	r25, Y+8	; 0x08
    3d1c:	08 96       	adiw	r24, 0x08	; 8
    3d1e:	0e 94 ba 25 	call	0x4b74	; 0x4b74 <xTaskRemoveFromEventList>
    3d22:	81 30       	cpi	r24, 0x01	; 1
    3d24:	b9 f4       	brne	.+46     	; 0x3d54 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    3d26:	0e 94 8f 1b 	call	0x371e	; 0x371e <vPortYield>
    3d2a:	14 c0       	rjmp	.+40     	; 0x3d54 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    3d2c:	ef 81       	ldd	r30, Y+7	; 0x07
    3d2e:	f8 85       	ldd	r31, Y+8	; 0x08
    3d30:	89 81       	ldd	r24, Y+1	; 0x01
    3d32:	9a 81       	ldd	r25, Y+2	; 0x02
    3d34:	97 83       	std	Z+7, r25	; 0x07
    3d36:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3d38:	ef 81       	ldd	r30, Y+7	; 0x07
    3d3a:	f8 85       	ldd	r31, Y+8	; 0x08
    3d3c:	81 89       	ldd	r24, Z+17	; 0x11
    3d3e:	88 23       	and	r24, r24
    3d40:	49 f0       	breq	.+18     	; 0x3d54 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3d42:	8f 81       	ldd	r24, Y+7	; 0x07
    3d44:	98 85       	ldd	r25, Y+8	; 0x08
    3d46:	41 96       	adiw	r24, 0x11	; 17
    3d48:	0e 94 ba 25 	call	0x4b74	; 0x4b74 <xTaskRemoveFromEventList>
    3d4c:	88 23       	and	r24, r24
    3d4e:	11 f0       	breq	.+4      	; 0x3d54 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    3d50:	0e 94 8f 1b 	call	0x371e	; 0x371e <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    3d54:	0f 90       	pop	r0
    3d56:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3d58:	81 e0       	ldi	r24, 0x01	; 1
    3d5a:	8e 87       	std	Y+14, r24	; 0x0e
    3d5c:	5c c0       	rjmp	.+184    	; 0x3e16 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3d5e:	8b 85       	ldd	r24, Y+11	; 0x0b
    3d60:	9c 85       	ldd	r25, Y+12	; 0x0c
    3d62:	00 97       	sbiw	r24, 0x00	; 0
    3d64:	21 f4       	brne	.+8      	; 0x3d6e <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3d66:	0f 90       	pop	r0
    3d68:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3d6a:	1e 86       	std	Y+14, r1	; 0x0e
    3d6c:	54 c0       	rjmp	.+168    	; 0x3e16 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    3d6e:	8b 81       	ldd	r24, Y+3	; 0x03
    3d70:	88 23       	and	r24, r24
    3d72:	31 f4       	brne	.+12     	; 0x3d80 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3d74:	ce 01       	movw	r24, r28
    3d76:	04 96       	adiw	r24, 0x04	; 4
    3d78:	0e 94 22 26 	call	0x4c44	; 0x4c44 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3d7c:	81 e0       	ldi	r24, 0x01	; 1
    3d7e:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    3d80:	0f 90       	pop	r0
    3d82:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3d84:	0e 94 7e 23 	call	0x46fc	; 0x46fc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3d88:	0f b6       	in	r0, 0x3f	; 63
    3d8a:	f8 94       	cli
    3d8c:	0f 92       	push	r0
    3d8e:	ef 81       	ldd	r30, Y+7	; 0x07
    3d90:	f8 85       	ldd	r31, Y+8	; 0x08
    3d92:	85 8d       	ldd	r24, Z+29	; 0x1d
    3d94:	8f 3f       	cpi	r24, 0xFF	; 255
    3d96:	19 f4       	brne	.+6      	; 0x3d9e <xQueueGenericReceive+0xf4>
    3d98:	ef 81       	ldd	r30, Y+7	; 0x07
    3d9a:	f8 85       	ldd	r31, Y+8	; 0x08
    3d9c:	15 8e       	std	Z+29, r1	; 0x1d
    3d9e:	ef 81       	ldd	r30, Y+7	; 0x07
    3da0:	f8 85       	ldd	r31, Y+8	; 0x08
    3da2:	86 8d       	ldd	r24, Z+30	; 0x1e
    3da4:	8f 3f       	cpi	r24, 0xFF	; 255
    3da6:	19 f4       	brne	.+6      	; 0x3dae <xQueueGenericReceive+0x104>
    3da8:	ef 81       	ldd	r30, Y+7	; 0x07
    3daa:	f8 85       	ldd	r31, Y+8	; 0x08
    3dac:	16 8e       	std	Z+30, r1	; 0x1e
    3dae:	0f 90       	pop	r0
    3db0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3db2:	ce 01       	movw	r24, r28
    3db4:	04 96       	adiw	r24, 0x04	; 4
    3db6:	9e 01       	movw	r18, r28
    3db8:	25 5f       	subi	r18, 0xF5	; 245
    3dba:	3f 4f       	sbci	r19, 0xFF	; 255
    3dbc:	b9 01       	movw	r22, r18
    3dbe:	0e 94 3b 26 	call	0x4c76	; 0x4c76 <xTaskCheckForTimeOut>
    3dc2:	88 23       	and	r24, r24
    3dc4:	09 f5       	brne	.+66     	; 0x3e08 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3dc6:	8f 81       	ldd	r24, Y+7	; 0x07
    3dc8:	98 85       	ldd	r25, Y+8	; 0x08
    3dca:	0e 94 d6 20 	call	0x41ac	; 0x41ac <prvIsQueueEmpty>
    3dce:	88 23       	and	r24, r24
    3dd0:	a1 f0       	breq	.+40     	; 0x3dfa <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3dd2:	8f 81       	ldd	r24, Y+7	; 0x07
    3dd4:	98 85       	ldd	r25, Y+8	; 0x08
    3dd6:	41 96       	adiw	r24, 0x11	; 17
    3dd8:	2b 85       	ldd	r18, Y+11	; 0x0b
    3dda:	3c 85       	ldd	r19, Y+12	; 0x0c
    3ddc:	b9 01       	movw	r22, r18
    3dde:	0e 94 84 25 	call	0x4b08	; 0x4b08 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3de2:	8f 81       	ldd	r24, Y+7	; 0x07
    3de4:	98 85       	ldd	r25, Y+8	; 0x08
    3de6:	0e 94 82 20 	call	0x4104	; 0x4104 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3dea:	0e 94 8a 23 	call	0x4714	; 0x4714 <xTaskResumeAll>
    3dee:	88 23       	and	r24, r24
    3df0:	09 f0       	breq	.+2      	; 0x3df4 <xQueueGenericReceive+0x14a>
    3df2:	6d cf       	rjmp	.-294    	; 0x3cce <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    3df4:	0e 94 8f 1b 	call	0x371e	; 0x371e <vPortYield>
    3df8:	6a cf       	rjmp	.-300    	; 0x3cce <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3dfa:	8f 81       	ldd	r24, Y+7	; 0x07
    3dfc:	98 85       	ldd	r25, Y+8	; 0x08
    3dfe:	0e 94 82 20 	call	0x4104	; 0x4104 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3e02:	0e 94 8a 23 	call	0x4714	; 0x4714 <xTaskResumeAll>
    3e06:	63 cf       	rjmp	.-314    	; 0x3cce <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    3e08:	8f 81       	ldd	r24, Y+7	; 0x07
    3e0a:	98 85       	ldd	r25, Y+8	; 0x08
    3e0c:	0e 94 82 20 	call	0x4104	; 0x4104 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3e10:	0e 94 8a 23 	call	0x4714	; 0x4714 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    3e14:	1e 86       	std	Y+14, r1	; 0x0e
    3e16:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    3e18:	2e 96       	adiw	r28, 0x0e	; 14
    3e1a:	0f b6       	in	r0, 0x3f	; 63
    3e1c:	f8 94       	cli
    3e1e:	de bf       	out	0x3e, r29	; 62
    3e20:	0f be       	out	0x3f, r0	; 63
    3e22:	cd bf       	out	0x3d, r28	; 61
    3e24:	cf 91       	pop	r28
    3e26:	df 91       	pop	r29
    3e28:	08 95       	ret

00003e2a <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    3e2a:	df 93       	push	r29
    3e2c:	cf 93       	push	r28
    3e2e:	cd b7       	in	r28, 0x3d	; 61
    3e30:	de b7       	in	r29, 0x3e	; 62
    3e32:	28 97       	sbiw	r28, 0x08	; 8
    3e34:	0f b6       	in	r0, 0x3f	; 63
    3e36:	f8 94       	cli
    3e38:	de bf       	out	0x3e, r29	; 62
    3e3a:	0f be       	out	0x3f, r0	; 63
    3e3c:	cd bf       	out	0x3d, r28	; 61
    3e3e:	9c 83       	std	Y+4, r25	; 0x04
    3e40:	8b 83       	std	Y+3, r24	; 0x03
    3e42:	7e 83       	std	Y+6, r23	; 0x06
    3e44:	6d 83       	std	Y+5, r22	; 0x05
    3e46:	58 87       	std	Y+8, r21	; 0x08
    3e48:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3e4a:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3e4c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e4e:	fc 81       	ldd	r31, Y+4	; 0x04
    3e50:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e52:	88 23       	and	r24, r24
    3e54:	71 f1       	breq	.+92     	; 0x3eb2 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3e56:	8b 81       	ldd	r24, Y+3	; 0x03
    3e58:	9c 81       	ldd	r25, Y+4	; 0x04
    3e5a:	2d 81       	ldd	r18, Y+5	; 0x05
    3e5c:	3e 81       	ldd	r19, Y+6	; 0x06
    3e5e:	b9 01       	movw	r22, r18
    3e60:	0e 94 3a 20 	call	0x4074	; 0x4074 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    3e64:	eb 81       	ldd	r30, Y+3	; 0x03
    3e66:	fc 81       	ldd	r31, Y+4	; 0x04
    3e68:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e6a:	81 50       	subi	r24, 0x01	; 1
    3e6c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e6e:	fc 81       	ldd	r31, Y+4	; 0x04
    3e70:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    3e72:	eb 81       	ldd	r30, Y+3	; 0x03
    3e74:	fc 81       	ldd	r31, Y+4	; 0x04
    3e76:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e78:	8f 3f       	cpi	r24, 0xFF	; 255
    3e7a:	89 f4       	brne	.+34     	; 0x3e9e <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3e7c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e7e:	fc 81       	ldd	r31, Y+4	; 0x04
    3e80:	80 85       	ldd	r24, Z+8	; 0x08
    3e82:	88 23       	and	r24, r24
    3e84:	99 f0       	breq	.+38     	; 0x3eac <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3e86:	8b 81       	ldd	r24, Y+3	; 0x03
    3e88:	9c 81       	ldd	r25, Y+4	; 0x04
    3e8a:	08 96       	adiw	r24, 0x08	; 8
    3e8c:	0e 94 ba 25 	call	0x4b74	; 0x4b74 <xTaskRemoveFromEventList>
    3e90:	88 23       	and	r24, r24
    3e92:	61 f0       	breq	.+24     	; 0x3eac <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    3e94:	ef 81       	ldd	r30, Y+7	; 0x07
    3e96:	f8 85       	ldd	r31, Y+8	; 0x08
    3e98:	81 e0       	ldi	r24, 0x01	; 1
    3e9a:	80 83       	st	Z, r24
    3e9c:	07 c0       	rjmp	.+14     	; 0x3eac <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    3e9e:	eb 81       	ldd	r30, Y+3	; 0x03
    3ea0:	fc 81       	ldd	r31, Y+4	; 0x04
    3ea2:	85 8d       	ldd	r24, Z+29	; 0x1d
    3ea4:	8f 5f       	subi	r24, 0xFF	; 255
    3ea6:	eb 81       	ldd	r30, Y+3	; 0x03
    3ea8:	fc 81       	ldd	r31, Y+4	; 0x04
    3eaa:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    3eac:	81 e0       	ldi	r24, 0x01	; 1
    3eae:	8a 83       	std	Y+2, r24	; 0x02
    3eb0:	01 c0       	rjmp	.+2      	; 0x3eb4 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    3eb2:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3eb4:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3eb6:	28 96       	adiw	r28, 0x08	; 8
    3eb8:	0f b6       	in	r0, 0x3f	; 63
    3eba:	f8 94       	cli
    3ebc:	de bf       	out	0x3e, r29	; 62
    3ebe:	0f be       	out	0x3f, r0	; 63
    3ec0:	cd bf       	out	0x3d, r28	; 61
    3ec2:	cf 91       	pop	r28
    3ec4:	df 91       	pop	r29
    3ec6:	08 95       	ret

00003ec8 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    3ec8:	df 93       	push	r29
    3eca:	cf 93       	push	r28
    3ecc:	00 d0       	rcall	.+0      	; 0x3ece <uxQueueMessagesWaiting+0x6>
    3ece:	0f 92       	push	r0
    3ed0:	cd b7       	in	r28, 0x3d	; 61
    3ed2:	de b7       	in	r29, 0x3e	; 62
    3ed4:	9b 83       	std	Y+3, r25	; 0x03
    3ed6:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3ed8:	0f b6       	in	r0, 0x3f	; 63
    3eda:	f8 94       	cli
    3edc:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    3ede:	ea 81       	ldd	r30, Y+2	; 0x02
    3ee0:	fb 81       	ldd	r31, Y+3	; 0x03
    3ee2:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ee4:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3ee6:	0f 90       	pop	r0
    3ee8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3eea:	89 81       	ldd	r24, Y+1	; 0x01
}
    3eec:	0f 90       	pop	r0
    3eee:	0f 90       	pop	r0
    3ef0:	0f 90       	pop	r0
    3ef2:	cf 91       	pop	r28
    3ef4:	df 91       	pop	r29
    3ef6:	08 95       	ret

00003ef8 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    3ef8:	df 93       	push	r29
    3efa:	cf 93       	push	r28
    3efc:	00 d0       	rcall	.+0      	; 0x3efe <uxQueueMessagesWaitingFromISR+0x6>
    3efe:	0f 92       	push	r0
    3f00:	cd b7       	in	r28, 0x3d	; 61
    3f02:	de b7       	in	r29, 0x3e	; 62
    3f04:	9b 83       	std	Y+3, r25	; 0x03
    3f06:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    3f08:	ea 81       	ldd	r30, Y+2	; 0x02
    3f0a:	fb 81       	ldd	r31, Y+3	; 0x03
    3f0c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f0e:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    3f10:	89 81       	ldd	r24, Y+1	; 0x01
}
    3f12:	0f 90       	pop	r0
    3f14:	0f 90       	pop	r0
    3f16:	0f 90       	pop	r0
    3f18:	cf 91       	pop	r28
    3f1a:	df 91       	pop	r29
    3f1c:	08 95       	ret

00003f1e <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    3f1e:	df 93       	push	r29
    3f20:	cf 93       	push	r28
    3f22:	00 d0       	rcall	.+0      	; 0x3f24 <vQueueDelete+0x6>
    3f24:	cd b7       	in	r28, 0x3d	; 61
    3f26:	de b7       	in	r29, 0x3e	; 62
    3f28:	9a 83       	std	Y+2, r25	; 0x02
    3f2a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    3f2c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f2e:	fa 81       	ldd	r31, Y+2	; 0x02
    3f30:	80 81       	ld	r24, Z
    3f32:	91 81       	ldd	r25, Z+1	; 0x01
    3f34:	0e 94 6f 18 	call	0x30de	; 0x30de <vPortFree>
	vPortFree( pxQueue );
    3f38:	89 81       	ldd	r24, Y+1	; 0x01
    3f3a:	9a 81       	ldd	r25, Y+2	; 0x02
    3f3c:	0e 94 6f 18 	call	0x30de	; 0x30de <vPortFree>
}
    3f40:	0f 90       	pop	r0
    3f42:	0f 90       	pop	r0
    3f44:	cf 91       	pop	r28
    3f46:	df 91       	pop	r29
    3f48:	08 95       	ret

00003f4a <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    3f4a:	df 93       	push	r29
    3f4c:	cf 93       	push	r28
    3f4e:	00 d0       	rcall	.+0      	; 0x3f50 <prvCopyDataToQueue+0x6>
    3f50:	00 d0       	rcall	.+0      	; 0x3f52 <prvCopyDataToQueue+0x8>
    3f52:	0f 92       	push	r0
    3f54:	cd b7       	in	r28, 0x3d	; 61
    3f56:	de b7       	in	r29, 0x3e	; 62
    3f58:	9a 83       	std	Y+2, r25	; 0x02
    3f5a:	89 83       	std	Y+1, r24	; 0x01
    3f5c:	7c 83       	std	Y+4, r23	; 0x04
    3f5e:	6b 83       	std	Y+3, r22	; 0x03
    3f60:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    3f62:	e9 81       	ldd	r30, Y+1	; 0x01
    3f64:	fa 81       	ldd	r31, Y+2	; 0x02
    3f66:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f68:	88 23       	and	r24, r24
    3f6a:	09 f4       	brne	.+2      	; 0x3f6e <prvCopyDataToQueue+0x24>
    3f6c:	74 c0       	rjmp	.+232    	; 0x4056 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    3f6e:	8d 81       	ldd	r24, Y+5	; 0x05
    3f70:	88 23       	and	r24, r24
    3f72:	99 f5       	brne	.+102    	; 0x3fda <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3f74:	e9 81       	ldd	r30, Y+1	; 0x01
    3f76:	fa 81       	ldd	r31, Y+2	; 0x02
    3f78:	64 81       	ldd	r22, Z+4	; 0x04
    3f7a:	75 81       	ldd	r23, Z+5	; 0x05
    3f7c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f7e:	fa 81       	ldd	r31, Y+2	; 0x02
    3f80:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f82:	48 2f       	mov	r20, r24
    3f84:	50 e0       	ldi	r21, 0x00	; 0
    3f86:	2b 81       	ldd	r18, Y+3	; 0x03
    3f88:	3c 81       	ldd	r19, Y+4	; 0x04
    3f8a:	cb 01       	movw	r24, r22
    3f8c:	b9 01       	movw	r22, r18
    3f8e:	0e 94 e3 2e 	call	0x5dc6	; 0x5dc6 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    3f92:	e9 81       	ldd	r30, Y+1	; 0x01
    3f94:	fa 81       	ldd	r31, Y+2	; 0x02
    3f96:	24 81       	ldd	r18, Z+4	; 0x04
    3f98:	35 81       	ldd	r19, Z+5	; 0x05
    3f9a:	e9 81       	ldd	r30, Y+1	; 0x01
    3f9c:	fa 81       	ldd	r31, Y+2	; 0x02
    3f9e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3fa0:	88 2f       	mov	r24, r24
    3fa2:	90 e0       	ldi	r25, 0x00	; 0
    3fa4:	82 0f       	add	r24, r18
    3fa6:	93 1f       	adc	r25, r19
    3fa8:	e9 81       	ldd	r30, Y+1	; 0x01
    3faa:	fa 81       	ldd	r31, Y+2	; 0x02
    3fac:	95 83       	std	Z+5, r25	; 0x05
    3fae:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    3fb0:	e9 81       	ldd	r30, Y+1	; 0x01
    3fb2:	fa 81       	ldd	r31, Y+2	; 0x02
    3fb4:	24 81       	ldd	r18, Z+4	; 0x04
    3fb6:	35 81       	ldd	r19, Z+5	; 0x05
    3fb8:	e9 81       	ldd	r30, Y+1	; 0x01
    3fba:	fa 81       	ldd	r31, Y+2	; 0x02
    3fbc:	82 81       	ldd	r24, Z+2	; 0x02
    3fbe:	93 81       	ldd	r25, Z+3	; 0x03
    3fc0:	28 17       	cp	r18, r24
    3fc2:	39 07       	cpc	r19, r25
    3fc4:	08 f4       	brcc	.+2      	; 0x3fc8 <prvCopyDataToQueue+0x7e>
    3fc6:	47 c0       	rjmp	.+142    	; 0x4056 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3fc8:	e9 81       	ldd	r30, Y+1	; 0x01
    3fca:	fa 81       	ldd	r31, Y+2	; 0x02
    3fcc:	80 81       	ld	r24, Z
    3fce:	91 81       	ldd	r25, Z+1	; 0x01
    3fd0:	e9 81       	ldd	r30, Y+1	; 0x01
    3fd2:	fa 81       	ldd	r31, Y+2	; 0x02
    3fd4:	95 83       	std	Z+5, r25	; 0x05
    3fd6:	84 83       	std	Z+4, r24	; 0x04
    3fd8:	3e c0       	rjmp	.+124    	; 0x4056 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3fda:	e9 81       	ldd	r30, Y+1	; 0x01
    3fdc:	fa 81       	ldd	r31, Y+2	; 0x02
    3fde:	66 81       	ldd	r22, Z+6	; 0x06
    3fe0:	77 81       	ldd	r23, Z+7	; 0x07
    3fe2:	e9 81       	ldd	r30, Y+1	; 0x01
    3fe4:	fa 81       	ldd	r31, Y+2	; 0x02
    3fe6:	84 8d       	ldd	r24, Z+28	; 0x1c
    3fe8:	48 2f       	mov	r20, r24
    3fea:	50 e0       	ldi	r21, 0x00	; 0
    3fec:	2b 81       	ldd	r18, Y+3	; 0x03
    3fee:	3c 81       	ldd	r19, Y+4	; 0x04
    3ff0:	cb 01       	movw	r24, r22
    3ff2:	b9 01       	movw	r22, r18
    3ff4:	0e 94 e3 2e 	call	0x5dc6	; 0x5dc6 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    3ff8:	e9 81       	ldd	r30, Y+1	; 0x01
    3ffa:	fa 81       	ldd	r31, Y+2	; 0x02
    3ffc:	26 81       	ldd	r18, Z+6	; 0x06
    3ffe:	37 81       	ldd	r19, Z+7	; 0x07
    4000:	e9 81       	ldd	r30, Y+1	; 0x01
    4002:	fa 81       	ldd	r31, Y+2	; 0x02
    4004:	84 8d       	ldd	r24, Z+28	; 0x1c
    4006:	88 2f       	mov	r24, r24
    4008:	90 e0       	ldi	r25, 0x00	; 0
    400a:	90 95       	com	r25
    400c:	81 95       	neg	r24
    400e:	9f 4f       	sbci	r25, 0xFF	; 255
    4010:	82 0f       	add	r24, r18
    4012:	93 1f       	adc	r25, r19
    4014:	e9 81       	ldd	r30, Y+1	; 0x01
    4016:	fa 81       	ldd	r31, Y+2	; 0x02
    4018:	97 83       	std	Z+7, r25	; 0x07
    401a:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    401c:	e9 81       	ldd	r30, Y+1	; 0x01
    401e:	fa 81       	ldd	r31, Y+2	; 0x02
    4020:	26 81       	ldd	r18, Z+6	; 0x06
    4022:	37 81       	ldd	r19, Z+7	; 0x07
    4024:	e9 81       	ldd	r30, Y+1	; 0x01
    4026:	fa 81       	ldd	r31, Y+2	; 0x02
    4028:	80 81       	ld	r24, Z
    402a:	91 81       	ldd	r25, Z+1	; 0x01
    402c:	28 17       	cp	r18, r24
    402e:	39 07       	cpc	r19, r25
    4030:	90 f4       	brcc	.+36     	; 0x4056 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    4032:	e9 81       	ldd	r30, Y+1	; 0x01
    4034:	fa 81       	ldd	r31, Y+2	; 0x02
    4036:	22 81       	ldd	r18, Z+2	; 0x02
    4038:	33 81       	ldd	r19, Z+3	; 0x03
    403a:	e9 81       	ldd	r30, Y+1	; 0x01
    403c:	fa 81       	ldd	r31, Y+2	; 0x02
    403e:	84 8d       	ldd	r24, Z+28	; 0x1c
    4040:	88 2f       	mov	r24, r24
    4042:	90 e0       	ldi	r25, 0x00	; 0
    4044:	90 95       	com	r25
    4046:	81 95       	neg	r24
    4048:	9f 4f       	sbci	r25, 0xFF	; 255
    404a:	82 0f       	add	r24, r18
    404c:	93 1f       	adc	r25, r19
    404e:	e9 81       	ldd	r30, Y+1	; 0x01
    4050:	fa 81       	ldd	r31, Y+2	; 0x02
    4052:	97 83       	std	Z+7, r25	; 0x07
    4054:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    4056:	e9 81       	ldd	r30, Y+1	; 0x01
    4058:	fa 81       	ldd	r31, Y+2	; 0x02
    405a:	82 8d       	ldd	r24, Z+26	; 0x1a
    405c:	8f 5f       	subi	r24, 0xFF	; 255
    405e:	e9 81       	ldd	r30, Y+1	; 0x01
    4060:	fa 81       	ldd	r31, Y+2	; 0x02
    4062:	82 8f       	std	Z+26, r24	; 0x1a
}
    4064:	0f 90       	pop	r0
    4066:	0f 90       	pop	r0
    4068:	0f 90       	pop	r0
    406a:	0f 90       	pop	r0
    406c:	0f 90       	pop	r0
    406e:	cf 91       	pop	r28
    4070:	df 91       	pop	r29
    4072:	08 95       	ret

00004074 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    4074:	df 93       	push	r29
    4076:	cf 93       	push	r28
    4078:	00 d0       	rcall	.+0      	; 0x407a <prvCopyDataFromQueue+0x6>
    407a:	00 d0       	rcall	.+0      	; 0x407c <prvCopyDataFromQueue+0x8>
    407c:	cd b7       	in	r28, 0x3d	; 61
    407e:	de b7       	in	r29, 0x3e	; 62
    4080:	9a 83       	std	Y+2, r25	; 0x02
    4082:	89 83       	std	Y+1, r24	; 0x01
    4084:	7c 83       	std	Y+4, r23	; 0x04
    4086:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    4088:	e9 81       	ldd	r30, Y+1	; 0x01
    408a:	fa 81       	ldd	r31, Y+2	; 0x02
    408c:	80 81       	ld	r24, Z
    408e:	91 81       	ldd	r25, Z+1	; 0x01
    4090:	00 97       	sbiw	r24, 0x00	; 0
    4092:	89 f1       	breq	.+98     	; 0x40f6 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    4094:	e9 81       	ldd	r30, Y+1	; 0x01
    4096:	fa 81       	ldd	r31, Y+2	; 0x02
    4098:	26 81       	ldd	r18, Z+6	; 0x06
    409a:	37 81       	ldd	r19, Z+7	; 0x07
    409c:	e9 81       	ldd	r30, Y+1	; 0x01
    409e:	fa 81       	ldd	r31, Y+2	; 0x02
    40a0:	84 8d       	ldd	r24, Z+28	; 0x1c
    40a2:	88 2f       	mov	r24, r24
    40a4:	90 e0       	ldi	r25, 0x00	; 0
    40a6:	82 0f       	add	r24, r18
    40a8:	93 1f       	adc	r25, r19
    40aa:	e9 81       	ldd	r30, Y+1	; 0x01
    40ac:	fa 81       	ldd	r31, Y+2	; 0x02
    40ae:	97 83       	std	Z+7, r25	; 0x07
    40b0:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    40b2:	e9 81       	ldd	r30, Y+1	; 0x01
    40b4:	fa 81       	ldd	r31, Y+2	; 0x02
    40b6:	26 81       	ldd	r18, Z+6	; 0x06
    40b8:	37 81       	ldd	r19, Z+7	; 0x07
    40ba:	e9 81       	ldd	r30, Y+1	; 0x01
    40bc:	fa 81       	ldd	r31, Y+2	; 0x02
    40be:	82 81       	ldd	r24, Z+2	; 0x02
    40c0:	93 81       	ldd	r25, Z+3	; 0x03
    40c2:	28 17       	cp	r18, r24
    40c4:	39 07       	cpc	r19, r25
    40c6:	40 f0       	brcs	.+16     	; 0x40d8 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    40c8:	e9 81       	ldd	r30, Y+1	; 0x01
    40ca:	fa 81       	ldd	r31, Y+2	; 0x02
    40cc:	80 81       	ld	r24, Z
    40ce:	91 81       	ldd	r25, Z+1	; 0x01
    40d0:	e9 81       	ldd	r30, Y+1	; 0x01
    40d2:	fa 81       	ldd	r31, Y+2	; 0x02
    40d4:	97 83       	std	Z+7, r25	; 0x07
    40d6:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    40d8:	e9 81       	ldd	r30, Y+1	; 0x01
    40da:	fa 81       	ldd	r31, Y+2	; 0x02
    40dc:	46 81       	ldd	r20, Z+6	; 0x06
    40de:	57 81       	ldd	r21, Z+7	; 0x07
    40e0:	e9 81       	ldd	r30, Y+1	; 0x01
    40e2:	fa 81       	ldd	r31, Y+2	; 0x02
    40e4:	84 8d       	ldd	r24, Z+28	; 0x1c
    40e6:	28 2f       	mov	r18, r24
    40e8:	30 e0       	ldi	r19, 0x00	; 0
    40ea:	8b 81       	ldd	r24, Y+3	; 0x03
    40ec:	9c 81       	ldd	r25, Y+4	; 0x04
    40ee:	ba 01       	movw	r22, r20
    40f0:	a9 01       	movw	r20, r18
    40f2:	0e 94 e3 2e 	call	0x5dc6	; 0x5dc6 <memcpy>
	}
}
    40f6:	0f 90       	pop	r0
    40f8:	0f 90       	pop	r0
    40fa:	0f 90       	pop	r0
    40fc:	0f 90       	pop	r0
    40fe:	cf 91       	pop	r28
    4100:	df 91       	pop	r29
    4102:	08 95       	ret

00004104 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    4104:	df 93       	push	r29
    4106:	cf 93       	push	r28
    4108:	00 d0       	rcall	.+0      	; 0x410a <prvUnlockQueue+0x6>
    410a:	cd b7       	in	r28, 0x3d	; 61
    410c:	de b7       	in	r29, 0x3e	; 62
    410e:	9a 83       	std	Y+2, r25	; 0x02
    4110:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    4112:	0f b6       	in	r0, 0x3f	; 63
    4114:	f8 94       	cli
    4116:	0f 92       	push	r0
    4118:	15 c0       	rjmp	.+42     	; 0x4144 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    411a:	e9 81       	ldd	r30, Y+1	; 0x01
    411c:	fa 81       	ldd	r31, Y+2	; 0x02
    411e:	81 89       	ldd	r24, Z+17	; 0x11
    4120:	88 23       	and	r24, r24
    4122:	a9 f0       	breq	.+42     	; 0x414e <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4124:	89 81       	ldd	r24, Y+1	; 0x01
    4126:	9a 81       	ldd	r25, Y+2	; 0x02
    4128:	41 96       	adiw	r24, 0x11	; 17
    412a:	0e 94 ba 25 	call	0x4b74	; 0x4b74 <xTaskRemoveFromEventList>
    412e:	88 23       	and	r24, r24
    4130:	11 f0       	breq	.+4      	; 0x4136 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    4132:	0e 94 98 26 	call	0x4d30	; 0x4d30 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    4136:	e9 81       	ldd	r30, Y+1	; 0x01
    4138:	fa 81       	ldd	r31, Y+2	; 0x02
    413a:	86 8d       	ldd	r24, Z+30	; 0x1e
    413c:	81 50       	subi	r24, 0x01	; 1
    413e:	e9 81       	ldd	r30, Y+1	; 0x01
    4140:	fa 81       	ldd	r31, Y+2	; 0x02
    4142:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    4144:	e9 81       	ldd	r30, Y+1	; 0x01
    4146:	fa 81       	ldd	r31, Y+2	; 0x02
    4148:	86 8d       	ldd	r24, Z+30	; 0x1e
    414a:	18 16       	cp	r1, r24
    414c:	34 f3       	brlt	.-52     	; 0x411a <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    414e:	e9 81       	ldd	r30, Y+1	; 0x01
    4150:	fa 81       	ldd	r31, Y+2	; 0x02
    4152:	8f ef       	ldi	r24, 0xFF	; 255
    4154:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    4156:	0f 90       	pop	r0
    4158:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    415a:	0f b6       	in	r0, 0x3f	; 63
    415c:	f8 94       	cli
    415e:	0f 92       	push	r0
    4160:	15 c0       	rjmp	.+42     	; 0x418c <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4162:	e9 81       	ldd	r30, Y+1	; 0x01
    4164:	fa 81       	ldd	r31, Y+2	; 0x02
    4166:	80 85       	ldd	r24, Z+8	; 0x08
    4168:	88 23       	and	r24, r24
    416a:	a9 f0       	breq	.+42     	; 0x4196 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    416c:	89 81       	ldd	r24, Y+1	; 0x01
    416e:	9a 81       	ldd	r25, Y+2	; 0x02
    4170:	08 96       	adiw	r24, 0x08	; 8
    4172:	0e 94 ba 25 	call	0x4b74	; 0x4b74 <xTaskRemoveFromEventList>
    4176:	88 23       	and	r24, r24
    4178:	11 f0       	breq	.+4      	; 0x417e <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    417a:	0e 94 98 26 	call	0x4d30	; 0x4d30 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    417e:	e9 81       	ldd	r30, Y+1	; 0x01
    4180:	fa 81       	ldd	r31, Y+2	; 0x02
    4182:	85 8d       	ldd	r24, Z+29	; 0x1d
    4184:	81 50       	subi	r24, 0x01	; 1
    4186:	e9 81       	ldd	r30, Y+1	; 0x01
    4188:	fa 81       	ldd	r31, Y+2	; 0x02
    418a:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    418c:	e9 81       	ldd	r30, Y+1	; 0x01
    418e:	fa 81       	ldd	r31, Y+2	; 0x02
    4190:	85 8d       	ldd	r24, Z+29	; 0x1d
    4192:	18 16       	cp	r1, r24
    4194:	34 f3       	brlt	.-52     	; 0x4162 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    4196:	e9 81       	ldd	r30, Y+1	; 0x01
    4198:	fa 81       	ldd	r31, Y+2	; 0x02
    419a:	8f ef       	ldi	r24, 0xFF	; 255
    419c:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    419e:	0f 90       	pop	r0
    41a0:	0f be       	out	0x3f, r0	; 63
}
    41a2:	0f 90       	pop	r0
    41a4:	0f 90       	pop	r0
    41a6:	cf 91       	pop	r28
    41a8:	df 91       	pop	r29
    41aa:	08 95       	ret

000041ac <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    41ac:	df 93       	push	r29
    41ae:	cf 93       	push	r28
    41b0:	00 d0       	rcall	.+0      	; 0x41b2 <prvIsQueueEmpty+0x6>
    41b2:	0f 92       	push	r0
    41b4:	cd b7       	in	r28, 0x3d	; 61
    41b6:	de b7       	in	r29, 0x3e	; 62
    41b8:	9b 83       	std	Y+3, r25	; 0x03
    41ba:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    41bc:	0f b6       	in	r0, 0x3f	; 63
    41be:	f8 94       	cli
    41c0:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    41c2:	ea 81       	ldd	r30, Y+2	; 0x02
    41c4:	fb 81       	ldd	r31, Y+3	; 0x03
    41c6:	82 8d       	ldd	r24, Z+26	; 0x1a
    41c8:	19 82       	std	Y+1, r1	; 0x01
    41ca:	88 23       	and	r24, r24
    41cc:	11 f4       	brne	.+4      	; 0x41d2 <prvIsQueueEmpty+0x26>
    41ce:	81 e0       	ldi	r24, 0x01	; 1
    41d0:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    41d2:	0f 90       	pop	r0
    41d4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    41d6:	89 81       	ldd	r24, Y+1	; 0x01
}
    41d8:	0f 90       	pop	r0
    41da:	0f 90       	pop	r0
    41dc:	0f 90       	pop	r0
    41de:	cf 91       	pop	r28
    41e0:	df 91       	pop	r29
    41e2:	08 95       	ret

000041e4 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    41e4:	df 93       	push	r29
    41e6:	cf 93       	push	r28
    41e8:	00 d0       	rcall	.+0      	; 0x41ea <xQueueIsQueueEmptyFromISR+0x6>
    41ea:	0f 92       	push	r0
    41ec:	cd b7       	in	r28, 0x3d	; 61
    41ee:	de b7       	in	r29, 0x3e	; 62
    41f0:	9b 83       	std	Y+3, r25	; 0x03
    41f2:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    41f4:	ea 81       	ldd	r30, Y+2	; 0x02
    41f6:	fb 81       	ldd	r31, Y+3	; 0x03
    41f8:	82 8d       	ldd	r24, Z+26	; 0x1a
    41fa:	19 82       	std	Y+1, r1	; 0x01
    41fc:	88 23       	and	r24, r24
    41fe:	11 f4       	brne	.+4      	; 0x4204 <xQueueIsQueueEmptyFromISR+0x20>
    4200:	81 e0       	ldi	r24, 0x01	; 1
    4202:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    4204:	89 81       	ldd	r24, Y+1	; 0x01
}
    4206:	0f 90       	pop	r0
    4208:	0f 90       	pop	r0
    420a:	0f 90       	pop	r0
    420c:	cf 91       	pop	r28
    420e:	df 91       	pop	r29
    4210:	08 95       	ret

00004212 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    4212:	df 93       	push	r29
    4214:	cf 93       	push	r28
    4216:	00 d0       	rcall	.+0      	; 0x4218 <prvIsQueueFull+0x6>
    4218:	0f 92       	push	r0
    421a:	cd b7       	in	r28, 0x3d	; 61
    421c:	de b7       	in	r29, 0x3e	; 62
    421e:	9b 83       	std	Y+3, r25	; 0x03
    4220:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    4222:	0f b6       	in	r0, 0x3f	; 63
    4224:	f8 94       	cli
    4226:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    4228:	ea 81       	ldd	r30, Y+2	; 0x02
    422a:	fb 81       	ldd	r31, Y+3	; 0x03
    422c:	92 8d       	ldd	r25, Z+26	; 0x1a
    422e:	ea 81       	ldd	r30, Y+2	; 0x02
    4230:	fb 81       	ldd	r31, Y+3	; 0x03
    4232:	83 8d       	ldd	r24, Z+27	; 0x1b
    4234:	19 82       	std	Y+1, r1	; 0x01
    4236:	98 17       	cp	r25, r24
    4238:	11 f4       	brne	.+4      	; 0x423e <prvIsQueueFull+0x2c>
    423a:	81 e0       	ldi	r24, 0x01	; 1
    423c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    423e:	0f 90       	pop	r0
    4240:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4242:	89 81       	ldd	r24, Y+1	; 0x01
}
    4244:	0f 90       	pop	r0
    4246:	0f 90       	pop	r0
    4248:	0f 90       	pop	r0
    424a:	cf 91       	pop	r28
    424c:	df 91       	pop	r29
    424e:	08 95       	ret

00004250 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    4250:	df 93       	push	r29
    4252:	cf 93       	push	r28
    4254:	00 d0       	rcall	.+0      	; 0x4256 <xQueueIsQueueFullFromISR+0x6>
    4256:	0f 92       	push	r0
    4258:	cd b7       	in	r28, 0x3d	; 61
    425a:	de b7       	in	r29, 0x3e	; 62
    425c:	9b 83       	std	Y+3, r25	; 0x03
    425e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    4260:	ea 81       	ldd	r30, Y+2	; 0x02
    4262:	fb 81       	ldd	r31, Y+3	; 0x03
    4264:	92 8d       	ldd	r25, Z+26	; 0x1a
    4266:	ea 81       	ldd	r30, Y+2	; 0x02
    4268:	fb 81       	ldd	r31, Y+3	; 0x03
    426a:	83 8d       	ldd	r24, Z+27	; 0x1b
    426c:	19 82       	std	Y+1, r1	; 0x01
    426e:	98 17       	cp	r25, r24
    4270:	11 f4       	brne	.+4      	; 0x4276 <xQueueIsQueueFullFromISR+0x26>
    4272:	81 e0       	ldi	r24, 0x01	; 1
    4274:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    4276:	89 81       	ldd	r24, Y+1	; 0x01
}
    4278:	0f 90       	pop	r0
    427a:	0f 90       	pop	r0
    427c:	0f 90       	pop	r0
    427e:	cf 91       	pop	r28
    4280:	df 91       	pop	r29
    4282:	08 95       	ret

00004284 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    4284:	af 92       	push	r10
    4286:	bf 92       	push	r11
    4288:	cf 92       	push	r12
    428a:	df 92       	push	r13
    428c:	ef 92       	push	r14
    428e:	ff 92       	push	r15
    4290:	0f 93       	push	r16
    4292:	1f 93       	push	r17
    4294:	df 93       	push	r29
    4296:	cf 93       	push	r28
    4298:	cd b7       	in	r28, 0x3d	; 61
    429a:	de b7       	in	r29, 0x3e	; 62
    429c:	64 97       	sbiw	r28, 0x14	; 20
    429e:	0f b6       	in	r0, 0x3f	; 63
    42a0:	f8 94       	cli
    42a2:	de bf       	out	0x3e, r29	; 62
    42a4:	0f be       	out	0x3f, r0	; 63
    42a6:	cd bf       	out	0x3d, r28	; 61
    42a8:	9f 83       	std	Y+7, r25	; 0x07
    42aa:	8e 83       	std	Y+6, r24	; 0x06
    42ac:	79 87       	std	Y+9, r23	; 0x09
    42ae:	68 87       	std	Y+8, r22	; 0x08
    42b0:	5b 87       	std	Y+11, r21	; 0x0b
    42b2:	4a 87       	std	Y+10, r20	; 0x0a
    42b4:	3d 87       	std	Y+13, r19	; 0x0d
    42b6:	2c 87       	std	Y+12, r18	; 0x0c
    42b8:	0e 87       	std	Y+14, r16	; 0x0e
    42ba:	f8 8a       	std	Y+16, r15	; 0x10
    42bc:	ef 86       	std	Y+15, r14	; 0x0f
    42be:	da 8a       	std	Y+18, r13	; 0x12
    42c0:	c9 8a       	std	Y+17, r12	; 0x11
    42c2:	bc 8a       	std	Y+20, r11	; 0x14
    42c4:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    42c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    42c8:	9b 85       	ldd	r25, Y+11	; 0x0b
    42ca:	29 89       	ldd	r18, Y+17	; 0x11
    42cc:	3a 89       	ldd	r19, Y+18	; 0x12
    42ce:	b9 01       	movw	r22, r18
    42d0:	0e 94 c7 27 	call	0x4f8e	; 0x4f8e <prvAllocateTCBAndStack>
    42d4:	9c 83       	std	Y+4, r25	; 0x04
    42d6:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    42d8:	8b 81       	ldd	r24, Y+3	; 0x03
    42da:	9c 81       	ldd	r25, Y+4	; 0x04
    42dc:	00 97       	sbiw	r24, 0x00	; 0
    42de:	09 f4       	brne	.+2      	; 0x42e2 <xTaskGenericCreate+0x5e>
    42e0:	99 c0       	rjmp	.+306    	; 0x4414 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    42e2:	eb 81       	ldd	r30, Y+3	; 0x03
    42e4:	fc 81       	ldd	r31, Y+4	; 0x04
    42e6:	27 89       	ldd	r18, Z+23	; 0x17
    42e8:	30 8d       	ldd	r19, Z+24	; 0x18
    42ea:	8a 85       	ldd	r24, Y+10	; 0x0a
    42ec:	9b 85       	ldd	r25, Y+11	; 0x0b
    42ee:	01 97       	sbiw	r24, 0x01	; 1
    42f0:	82 0f       	add	r24, r18
    42f2:	93 1f       	adc	r25, r19
    42f4:	9a 83       	std	Y+2, r25	; 0x02
    42f6:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    42f8:	8b 81       	ldd	r24, Y+3	; 0x03
    42fa:	9c 81       	ldd	r25, Y+4	; 0x04
    42fc:	28 85       	ldd	r18, Y+8	; 0x08
    42fe:	39 85       	ldd	r19, Y+9	; 0x09
    4300:	eb 89       	ldd	r30, Y+19	; 0x13
    4302:	fc 89       	ldd	r31, Y+20	; 0x14
    4304:	aa 85       	ldd	r26, Y+10	; 0x0a
    4306:	bb 85       	ldd	r27, Y+11	; 0x0b
    4308:	b9 01       	movw	r22, r18
    430a:	4e 85       	ldd	r20, Y+14	; 0x0e
    430c:	9f 01       	movw	r18, r30
    430e:	8d 01       	movw	r16, r26
    4310:	0e 94 ac 26 	call	0x4d58	; 0x4d58 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    4314:	89 81       	ldd	r24, Y+1	; 0x01
    4316:	9a 81       	ldd	r25, Y+2	; 0x02
    4318:	2e 81       	ldd	r18, Y+6	; 0x06
    431a:	3f 81       	ldd	r19, Y+7	; 0x07
    431c:	4c 85       	ldd	r20, Y+12	; 0x0c
    431e:	5d 85       	ldd	r21, Y+13	; 0x0d
    4320:	b9 01       	movw	r22, r18
    4322:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <pxPortInitialiseStack>
    4326:	eb 81       	ldd	r30, Y+3	; 0x03
    4328:	fc 81       	ldd	r31, Y+4	; 0x04
    432a:	91 83       	std	Z+1, r25	; 0x01
    432c:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    432e:	8f 85       	ldd	r24, Y+15	; 0x0f
    4330:	98 89       	ldd	r25, Y+16	; 0x10
    4332:	00 97       	sbiw	r24, 0x00	; 0
    4334:	31 f0       	breq	.+12     	; 0x4342 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    4336:	ef 85       	ldd	r30, Y+15	; 0x0f
    4338:	f8 89       	ldd	r31, Y+16	; 0x10
    433a:	8b 81       	ldd	r24, Y+3	; 0x03
    433c:	9c 81       	ldd	r25, Y+4	; 0x04
    433e:	91 83       	std	Z+1, r25	; 0x01
    4340:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    4342:	0f b6       	in	r0, 0x3f	; 63
    4344:	f8 94       	cli
    4346:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    4348:	80 91 31 07 	lds	r24, 0x0731
    434c:	8f 5f       	subi	r24, 0xFF	; 255
    434e:	80 93 31 07 	sts	0x0731, r24
			if( pxCurrentTCB == NULL )
    4352:	80 91 2e 07 	lds	r24, 0x072E
    4356:	90 91 2f 07 	lds	r25, 0x072F
    435a:	00 97       	sbiw	r24, 0x00	; 0
    435c:	69 f4       	brne	.+26     	; 0x4378 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    435e:	8b 81       	ldd	r24, Y+3	; 0x03
    4360:	9c 81       	ldd	r25, Y+4	; 0x04
    4362:	90 93 2f 07 	sts	0x072F, r25
    4366:	80 93 2e 07 	sts	0x072E, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    436a:	80 91 31 07 	lds	r24, 0x0731
    436e:	81 30       	cpi	r24, 0x01	; 1
    4370:	a9 f4       	brne	.+42     	; 0x439c <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    4372:	0e 94 03 27 	call	0x4e06	; 0x4e06 <prvInitialiseTaskLists>
    4376:	12 c0       	rjmp	.+36     	; 0x439c <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    4378:	80 91 36 07 	lds	r24, 0x0736
    437c:	88 23       	and	r24, r24
    437e:	71 f4       	brne	.+28     	; 0x439c <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    4380:	e0 91 2e 07 	lds	r30, 0x072E
    4384:	f0 91 2f 07 	lds	r31, 0x072F
    4388:	96 89       	ldd	r25, Z+22	; 0x16
    438a:	8e 85       	ldd	r24, Y+14	; 0x0e
    438c:	89 17       	cp	r24, r25
    438e:	30 f0       	brcs	.+12     	; 0x439c <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    4390:	8b 81       	ldd	r24, Y+3	; 0x03
    4392:	9c 81       	ldd	r25, Y+4	; 0x04
    4394:	90 93 2f 07 	sts	0x072F, r25
    4398:	80 93 2e 07 	sts	0x072E, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    439c:	eb 81       	ldd	r30, Y+3	; 0x03
    439e:	fc 81       	ldd	r31, Y+4	; 0x04
    43a0:	96 89       	ldd	r25, Z+22	; 0x16
    43a2:	80 91 34 07 	lds	r24, 0x0734
    43a6:	89 17       	cp	r24, r25
    43a8:	28 f4       	brcc	.+10     	; 0x43b4 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    43aa:	eb 81       	ldd	r30, Y+3	; 0x03
    43ac:	fc 81       	ldd	r31, Y+4	; 0x04
    43ae:	86 89       	ldd	r24, Z+22	; 0x16
    43b0:	80 93 34 07 	sts	0x0734, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    43b4:	80 91 3b 07 	lds	r24, 0x073B
    43b8:	8f 5f       	subi	r24, 0xFF	; 255
    43ba:	80 93 3b 07 	sts	0x073B, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    43be:	eb 81       	ldd	r30, Y+3	; 0x03
    43c0:	fc 81       	ldd	r31, Y+4	; 0x04
    43c2:	96 89       	ldd	r25, Z+22	; 0x16
    43c4:	80 91 35 07 	lds	r24, 0x0735
    43c8:	89 17       	cp	r24, r25
    43ca:	28 f4       	brcc	.+10     	; 0x43d6 <xTaskGenericCreate+0x152>
    43cc:	eb 81       	ldd	r30, Y+3	; 0x03
    43ce:	fc 81       	ldd	r31, Y+4	; 0x04
    43d0:	86 89       	ldd	r24, Z+22	; 0x16
    43d2:	80 93 35 07 	sts	0x0735, r24
    43d6:	eb 81       	ldd	r30, Y+3	; 0x03
    43d8:	fc 81       	ldd	r31, Y+4	; 0x04
    43da:	86 89       	ldd	r24, Z+22	; 0x16
    43dc:	28 2f       	mov	r18, r24
    43de:	30 e0       	ldi	r19, 0x00	; 0
    43e0:	c9 01       	movw	r24, r18
    43e2:	88 0f       	add	r24, r24
    43e4:	99 1f       	adc	r25, r25
    43e6:	88 0f       	add	r24, r24
    43e8:	99 1f       	adc	r25, r25
    43ea:	88 0f       	add	r24, r24
    43ec:	99 1f       	adc	r25, r25
    43ee:	82 0f       	add	r24, r18
    43f0:	93 1f       	adc	r25, r19
    43f2:	ac 01       	movw	r20, r24
    43f4:	44 5c       	subi	r20, 0xC4	; 196
    43f6:	58 4f       	sbci	r21, 0xF8	; 248
    43f8:	8b 81       	ldd	r24, Y+3	; 0x03
    43fa:	9c 81       	ldd	r25, Y+4	; 0x04
    43fc:	9c 01       	movw	r18, r24
    43fe:	2e 5f       	subi	r18, 0xFE	; 254
    4400:	3f 4f       	sbci	r19, 0xFF	; 255
    4402:	ca 01       	movw	r24, r20
    4404:	b9 01       	movw	r22, r18
    4406:	0e 94 cf 18 	call	0x319e	; 0x319e <vListInsertEnd>

			xReturn = pdPASS;
    440a:	81 e0       	ldi	r24, 0x01	; 1
    440c:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    440e:	0f 90       	pop	r0
    4410:	0f be       	out	0x3f, r0	; 63
    4412:	02 c0       	rjmp	.+4      	; 0x4418 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4414:	8f ef       	ldi	r24, 0xFF	; 255
    4416:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    4418:	8d 81       	ldd	r24, Y+5	; 0x05
    441a:	81 30       	cpi	r24, 0x01	; 1
    441c:	71 f4       	brne	.+28     	; 0x443a <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    441e:	80 91 36 07 	lds	r24, 0x0736
    4422:	88 23       	and	r24, r24
    4424:	51 f0       	breq	.+20     	; 0x443a <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    4426:	e0 91 2e 07 	lds	r30, 0x072E
    442a:	f0 91 2f 07 	lds	r31, 0x072F
    442e:	96 89       	ldd	r25, Z+22	; 0x16
    4430:	8e 85       	ldd	r24, Y+14	; 0x0e
    4432:	98 17       	cp	r25, r24
    4434:	10 f4       	brcc	.+4      	; 0x443a <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    4436:	0e 94 8f 1b 	call	0x371e	; 0x371e <vPortYield>
			}
		}
	}

	return xReturn;
    443a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    443c:	64 96       	adiw	r28, 0x14	; 20
    443e:	0f b6       	in	r0, 0x3f	; 63
    4440:	f8 94       	cli
    4442:	de bf       	out	0x3e, r29	; 62
    4444:	0f be       	out	0x3f, r0	; 63
    4446:	cd bf       	out	0x3d, r28	; 61
    4448:	cf 91       	pop	r28
    444a:	df 91       	pop	r29
    444c:	1f 91       	pop	r17
    444e:	0f 91       	pop	r16
    4450:	ff 90       	pop	r15
    4452:	ef 90       	pop	r14
    4454:	df 90       	pop	r13
    4456:	cf 90       	pop	r12
    4458:	bf 90       	pop	r11
    445a:	af 90       	pop	r10
    445c:	08 95       	ret

0000445e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    445e:	df 93       	push	r29
    4460:	cf 93       	push	r28
    4462:	00 d0       	rcall	.+0      	; 0x4464 <vTaskDelete+0x6>
    4464:	00 d0       	rcall	.+0      	; 0x4466 <vTaskDelete+0x8>
    4466:	00 d0       	rcall	.+0      	; 0x4468 <vTaskDelete+0xa>
    4468:	cd b7       	in	r28, 0x3d	; 61
    446a:	de b7       	in	r29, 0x3e	; 62
    446c:	9c 83       	std	Y+4, r25	; 0x04
    446e:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    4470:	0f b6       	in	r0, 0x3f	; 63
    4472:	f8 94       	cli
    4474:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    4476:	20 91 2e 07 	lds	r18, 0x072E
    447a:	30 91 2f 07 	lds	r19, 0x072F
    447e:	8b 81       	ldd	r24, Y+3	; 0x03
    4480:	9c 81       	ldd	r25, Y+4	; 0x04
    4482:	82 17       	cp	r24, r18
    4484:	93 07       	cpc	r25, r19
    4486:	11 f4       	brne	.+4      	; 0x448c <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    4488:	1c 82       	std	Y+4, r1	; 0x04
    448a:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    448c:	8b 81       	ldd	r24, Y+3	; 0x03
    448e:	9c 81       	ldd	r25, Y+4	; 0x04
    4490:	00 97       	sbiw	r24, 0x00	; 0
    4492:	39 f4       	brne	.+14     	; 0x44a2 <vTaskDelete+0x44>
    4494:	80 91 2e 07 	lds	r24, 0x072E
    4498:	90 91 2f 07 	lds	r25, 0x072F
    449c:	9e 83       	std	Y+6, r25	; 0x06
    449e:	8d 83       	std	Y+5, r24	; 0x05
    44a0:	04 c0       	rjmp	.+8      	; 0x44aa <vTaskDelete+0x4c>
    44a2:	8b 81       	ldd	r24, Y+3	; 0x03
    44a4:	9c 81       	ldd	r25, Y+4	; 0x04
    44a6:	9e 83       	std	Y+6, r25	; 0x06
    44a8:	8d 83       	std	Y+5, r24	; 0x05
    44aa:	8d 81       	ldd	r24, Y+5	; 0x05
    44ac:	9e 81       	ldd	r25, Y+6	; 0x06
    44ae:	9a 83       	std	Y+2, r25	; 0x02
    44b0:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    44b2:	89 81       	ldd	r24, Y+1	; 0x01
    44b4:	9a 81       	ldd	r25, Y+2	; 0x02
    44b6:	02 96       	adiw	r24, 0x02	; 2
    44b8:	0e 94 87 19 	call	0x330e	; 0x330e <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    44bc:	e9 81       	ldd	r30, Y+1	; 0x01
    44be:	fa 81       	ldd	r31, Y+2	; 0x02
    44c0:	84 89       	ldd	r24, Z+20	; 0x14
    44c2:	95 89       	ldd	r25, Z+21	; 0x15
    44c4:	00 97       	sbiw	r24, 0x00	; 0
    44c6:	29 f0       	breq	.+10     	; 0x44d2 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    44c8:	89 81       	ldd	r24, Y+1	; 0x01
    44ca:	9a 81       	ldd	r25, Y+2	; 0x02
    44cc:	0c 96       	adiw	r24, 0x0c	; 12
    44ce:	0e 94 87 19 	call	0x330e	; 0x330e <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    44d2:	89 81       	ldd	r24, Y+1	; 0x01
    44d4:	9a 81       	ldd	r25, Y+2	; 0x02
    44d6:	9c 01       	movw	r18, r24
    44d8:	2e 5f       	subi	r18, 0xFE	; 254
    44da:	3f 4f       	sbci	r19, 0xFF	; 255
    44dc:	83 ea       	ldi	r24, 0xA3	; 163
    44de:	97 e0       	ldi	r25, 0x07	; 7
    44e0:	b9 01       	movw	r22, r18
    44e2:	0e 94 cf 18 	call	0x319e	; 0x319e <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    44e6:	80 91 30 07 	lds	r24, 0x0730
    44ea:	8f 5f       	subi	r24, 0xFF	; 255
    44ec:	80 93 30 07 	sts	0x0730, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    44f0:	80 91 3b 07 	lds	r24, 0x073B
    44f4:	8f 5f       	subi	r24, 0xFF	; 255
    44f6:	80 93 3b 07 	sts	0x073B, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    44fa:	0f 90       	pop	r0
    44fc:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    44fe:	80 91 36 07 	lds	r24, 0x0736
    4502:	88 23       	and	r24, r24
    4504:	31 f0       	breq	.+12     	; 0x4512 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    4506:	8b 81       	ldd	r24, Y+3	; 0x03
    4508:	9c 81       	ldd	r25, Y+4	; 0x04
    450a:	00 97       	sbiw	r24, 0x00	; 0
    450c:	11 f4       	brne	.+4      	; 0x4512 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    450e:	0e 94 8f 1b 	call	0x371e	; 0x371e <vPortYield>
			}
		}
	}
    4512:	26 96       	adiw	r28, 0x06	; 6
    4514:	0f b6       	in	r0, 0x3f	; 63
    4516:	f8 94       	cli
    4518:	de bf       	out	0x3e, r29	; 62
    451a:	0f be       	out	0x3f, r0	; 63
    451c:	cd bf       	out	0x3d, r28	; 61
    451e:	cf 91       	pop	r28
    4520:	df 91       	pop	r29
    4522:	08 95       	ret

00004524 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    4524:	df 93       	push	r29
    4526:	cf 93       	push	r28
    4528:	cd b7       	in	r28, 0x3d	; 61
    452a:	de b7       	in	r29, 0x3e	; 62
    452c:	28 97       	sbiw	r28, 0x08	; 8
    452e:	0f b6       	in	r0, 0x3f	; 63
    4530:	f8 94       	cli
    4532:	de bf       	out	0x3e, r29	; 62
    4534:	0f be       	out	0x3f, r0	; 63
    4536:	cd bf       	out	0x3d, r28	; 61
    4538:	9e 83       	std	Y+6, r25	; 0x06
    453a:	8d 83       	std	Y+5, r24	; 0x05
    453c:	78 87       	std	Y+8, r23	; 0x08
    453e:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    4540:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    4542:	0e 94 7e 23 	call	0x46fc	; 0x46fc <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    4546:	ed 81       	ldd	r30, Y+5	; 0x05
    4548:	fe 81       	ldd	r31, Y+6	; 0x06
    454a:	20 81       	ld	r18, Z
    454c:	31 81       	ldd	r19, Z+1	; 0x01
    454e:	8f 81       	ldd	r24, Y+7	; 0x07
    4550:	98 85       	ldd	r25, Y+8	; 0x08
    4552:	82 0f       	add	r24, r18
    4554:	93 1f       	adc	r25, r19
    4556:	9c 83       	std	Y+4, r25	; 0x04
    4558:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    455a:	ed 81       	ldd	r30, Y+5	; 0x05
    455c:	fe 81       	ldd	r31, Y+6	; 0x06
    455e:	20 81       	ld	r18, Z
    4560:	31 81       	ldd	r19, Z+1	; 0x01
    4562:	80 91 32 07 	lds	r24, 0x0732
    4566:	90 91 33 07 	lds	r25, 0x0733
    456a:	82 17       	cp	r24, r18
    456c:	93 07       	cpc	r25, r19
    456e:	a8 f4       	brcc	.+42     	; 0x459a <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    4570:	ed 81       	ldd	r30, Y+5	; 0x05
    4572:	fe 81       	ldd	r31, Y+6	; 0x06
    4574:	20 81       	ld	r18, Z
    4576:	31 81       	ldd	r19, Z+1	; 0x01
    4578:	8b 81       	ldd	r24, Y+3	; 0x03
    457a:	9c 81       	ldd	r25, Y+4	; 0x04
    457c:	82 17       	cp	r24, r18
    457e:	93 07       	cpc	r25, r19
    4580:	00 f5       	brcc	.+64     	; 0x45c2 <vTaskDelayUntil+0x9e>
    4582:	20 91 32 07 	lds	r18, 0x0732
    4586:	30 91 33 07 	lds	r19, 0x0733
    458a:	8b 81       	ldd	r24, Y+3	; 0x03
    458c:	9c 81       	ldd	r25, Y+4	; 0x04
    458e:	28 17       	cp	r18, r24
    4590:	39 07       	cpc	r19, r25
    4592:	b8 f4       	brcc	.+46     	; 0x45c2 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4594:	81 e0       	ldi	r24, 0x01	; 1
    4596:	89 83       	std	Y+1, r24	; 0x01
    4598:	14 c0       	rjmp	.+40     	; 0x45c2 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    459a:	ed 81       	ldd	r30, Y+5	; 0x05
    459c:	fe 81       	ldd	r31, Y+6	; 0x06
    459e:	20 81       	ld	r18, Z
    45a0:	31 81       	ldd	r19, Z+1	; 0x01
    45a2:	8b 81       	ldd	r24, Y+3	; 0x03
    45a4:	9c 81       	ldd	r25, Y+4	; 0x04
    45a6:	82 17       	cp	r24, r18
    45a8:	93 07       	cpc	r25, r19
    45aa:	48 f0       	brcs	.+18     	; 0x45be <vTaskDelayUntil+0x9a>
    45ac:	20 91 32 07 	lds	r18, 0x0732
    45b0:	30 91 33 07 	lds	r19, 0x0733
    45b4:	8b 81       	ldd	r24, Y+3	; 0x03
    45b6:	9c 81       	ldd	r25, Y+4	; 0x04
    45b8:	28 17       	cp	r18, r24
    45ba:	39 07       	cpc	r19, r25
    45bc:	10 f4       	brcc	.+4      	; 0x45c2 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    45be:	81 e0       	ldi	r24, 0x01	; 1
    45c0:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    45c2:	ed 81       	ldd	r30, Y+5	; 0x05
    45c4:	fe 81       	ldd	r31, Y+6	; 0x06
    45c6:	8b 81       	ldd	r24, Y+3	; 0x03
    45c8:	9c 81       	ldd	r25, Y+4	; 0x04
    45ca:	91 83       	std	Z+1, r25	; 0x01
    45cc:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    45ce:	89 81       	ldd	r24, Y+1	; 0x01
    45d0:	88 23       	and	r24, r24
    45d2:	59 f0       	breq	.+22     	; 0x45ea <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    45d4:	80 91 2e 07 	lds	r24, 0x072E
    45d8:	90 91 2f 07 	lds	r25, 0x072F
    45dc:	02 96       	adiw	r24, 0x02	; 2
    45de:	0e 94 87 19 	call	0x330e	; 0x330e <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    45e2:	8b 81       	ldd	r24, Y+3	; 0x03
    45e4:	9c 81       	ldd	r25, Y+4	; 0x04
    45e6:	0e 94 7e 27 	call	0x4efc	; 0x4efc <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    45ea:	0e 94 8a 23 	call	0x4714	; 0x4714 <xTaskResumeAll>
    45ee:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    45f0:	8a 81       	ldd	r24, Y+2	; 0x02
    45f2:	88 23       	and	r24, r24
    45f4:	11 f4       	brne	.+4      	; 0x45fa <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    45f6:	0e 94 8f 1b 	call	0x371e	; 0x371e <vPortYield>
		}
	}
    45fa:	28 96       	adiw	r28, 0x08	; 8
    45fc:	0f b6       	in	r0, 0x3f	; 63
    45fe:	f8 94       	cli
    4600:	de bf       	out	0x3e, r29	; 62
    4602:	0f be       	out	0x3f, r0	; 63
    4604:	cd bf       	out	0x3d, r28	; 61
    4606:	cf 91       	pop	r28
    4608:	df 91       	pop	r29
    460a:	08 95       	ret

0000460c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    460c:	df 93       	push	r29
    460e:	cf 93       	push	r28
    4610:	00 d0       	rcall	.+0      	; 0x4612 <vTaskDelay+0x6>
    4612:	00 d0       	rcall	.+0      	; 0x4614 <vTaskDelay+0x8>
    4614:	0f 92       	push	r0
    4616:	cd b7       	in	r28, 0x3d	; 61
    4618:	de b7       	in	r29, 0x3e	; 62
    461a:	9d 83       	std	Y+5, r25	; 0x05
    461c:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    461e:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    4620:	8c 81       	ldd	r24, Y+4	; 0x04
    4622:	9d 81       	ldd	r25, Y+5	; 0x05
    4624:	00 97       	sbiw	r24, 0x00	; 0
    4626:	d1 f0       	breq	.+52     	; 0x465c <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    4628:	0e 94 7e 23 	call	0x46fc	; 0x46fc <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    462c:	20 91 32 07 	lds	r18, 0x0732
    4630:	30 91 33 07 	lds	r19, 0x0733
    4634:	8c 81       	ldd	r24, Y+4	; 0x04
    4636:	9d 81       	ldd	r25, Y+5	; 0x05
    4638:	82 0f       	add	r24, r18
    463a:	93 1f       	adc	r25, r19
    463c:	9b 83       	std	Y+3, r25	; 0x03
    463e:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4640:	80 91 2e 07 	lds	r24, 0x072E
    4644:	90 91 2f 07 	lds	r25, 0x072F
    4648:	02 96       	adiw	r24, 0x02	; 2
    464a:	0e 94 87 19 	call	0x330e	; 0x330e <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    464e:	8a 81       	ldd	r24, Y+2	; 0x02
    4650:	9b 81       	ldd	r25, Y+3	; 0x03
    4652:	0e 94 7e 27 	call	0x4efc	; 0x4efc <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    4656:	0e 94 8a 23 	call	0x4714	; 0x4714 <xTaskResumeAll>
    465a:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    465c:	89 81       	ldd	r24, Y+1	; 0x01
    465e:	88 23       	and	r24, r24
    4660:	11 f4       	brne	.+4      	; 0x4666 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    4662:	0e 94 8f 1b 	call	0x371e	; 0x371e <vPortYield>
		}
	}
    4666:	0f 90       	pop	r0
    4668:	0f 90       	pop	r0
    466a:	0f 90       	pop	r0
    466c:	0f 90       	pop	r0
    466e:	0f 90       	pop	r0
    4670:	cf 91       	pop	r28
    4672:	df 91       	pop	r29
    4674:	08 95       	ret

00004676 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    4676:	af 92       	push	r10
    4678:	bf 92       	push	r11
    467a:	cf 92       	push	r12
    467c:	df 92       	push	r13
    467e:	ef 92       	push	r14
    4680:	ff 92       	push	r15
    4682:	0f 93       	push	r16
    4684:	df 93       	push	r29
    4686:	cf 93       	push	r28
    4688:	0f 92       	push	r0
    468a:	cd b7       	in	r28, 0x3d	; 61
    468c:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    468e:	20 e6       	ldi	r18, 0x60	; 96
    4690:	30 e0       	ldi	r19, 0x00	; 0
    4692:	82 ea       	ldi	r24, 0xA2	; 162
    4694:	96 e2       	ldi	r25, 0x26	; 38
    4696:	b9 01       	movw	r22, r18
    4698:	44 e6       	ldi	r20, 0x64	; 100
    469a:	50 e0       	ldi	r21, 0x00	; 0
    469c:	20 e0       	ldi	r18, 0x00	; 0
    469e:	30 e0       	ldi	r19, 0x00	; 0
    46a0:	00 e0       	ldi	r16, 0x00	; 0
    46a2:	ee 24       	eor	r14, r14
    46a4:	ff 24       	eor	r15, r15
    46a6:	cc 24       	eor	r12, r12
    46a8:	dd 24       	eor	r13, r13
    46aa:	aa 24       	eor	r10, r10
    46ac:	bb 24       	eor	r11, r11
    46ae:	0e 94 42 21 	call	0x4284	; 0x4284 <xTaskGenericCreate>
    46b2:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    46b4:	89 81       	ldd	r24, Y+1	; 0x01
    46b6:	81 30       	cpi	r24, 0x01	; 1
    46b8:	51 f4       	brne	.+20     	; 0x46ce <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    46ba:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    46bc:	81 e0       	ldi	r24, 0x01	; 1
    46be:	80 93 36 07 	sts	0x0736, r24
		xTickCount = ( portTickType ) 0U;
    46c2:	10 92 33 07 	sts	0x0733, r1
    46c6:	10 92 32 07 	sts	0x0732, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    46ca:	0e 94 53 1b 	call	0x36a6	; 0x36a6 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    46ce:	0f 90       	pop	r0
    46d0:	cf 91       	pop	r28
    46d2:	df 91       	pop	r29
    46d4:	0f 91       	pop	r16
    46d6:	ff 90       	pop	r15
    46d8:	ef 90       	pop	r14
    46da:	df 90       	pop	r13
    46dc:	cf 90       	pop	r12
    46de:	bf 90       	pop	r11
    46e0:	af 90       	pop	r10
    46e2:	08 95       	ret

000046e4 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    46e4:	df 93       	push	r29
    46e6:	cf 93       	push	r28
    46e8:	cd b7       	in	r28, 0x3d	; 61
    46ea:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    46ec:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    46ee:	10 92 36 07 	sts	0x0736, r1
	vPortEndScheduler();
    46f2:	0e 94 88 1b 	call	0x3710	; 0x3710 <vPortEndScheduler>
}
    46f6:	cf 91       	pop	r28
    46f8:	df 91       	pop	r29
    46fa:	08 95       	ret

000046fc <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    46fc:	df 93       	push	r29
    46fe:	cf 93       	push	r28
    4700:	cd b7       	in	r28, 0x3d	; 61
    4702:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    4704:	80 91 37 07 	lds	r24, 0x0737
    4708:	8f 5f       	subi	r24, 0xFF	; 255
    470a:	80 93 37 07 	sts	0x0737, r24
}
    470e:	cf 91       	pop	r28
    4710:	df 91       	pop	r29
    4712:	08 95       	ret

00004714 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    4714:	df 93       	push	r29
    4716:	cf 93       	push	r28
    4718:	00 d0       	rcall	.+0      	; 0x471a <xTaskResumeAll+0x6>
    471a:	00 d0       	rcall	.+0      	; 0x471c <xTaskResumeAll+0x8>
    471c:	cd b7       	in	r28, 0x3d	; 61
    471e:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    4720:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4722:	0f b6       	in	r0, 0x3f	; 63
    4724:	f8 94       	cli
    4726:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    4728:	80 91 37 07 	lds	r24, 0x0737
    472c:	81 50       	subi	r24, 0x01	; 1
    472e:	80 93 37 07 	sts	0x0737, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4732:	80 91 37 07 	lds	r24, 0x0737
    4736:	88 23       	and	r24, r24
    4738:	09 f0       	breq	.+2      	; 0x473c <xTaskResumeAll+0x28>
    473a:	6c c0       	rjmp	.+216    	; 0x4814 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    473c:	80 91 31 07 	lds	r24, 0x0731
    4740:	88 23       	and	r24, r24
    4742:	09 f4       	brne	.+2      	; 0x4746 <xTaskResumeAll+0x32>
    4744:	67 c0       	rjmp	.+206    	; 0x4814 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    4746:	19 82       	std	Y+1, r1	; 0x01
    4748:	41 c0       	rjmp	.+130    	; 0x47cc <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    474a:	e0 91 9f 07 	lds	r30, 0x079F
    474e:	f0 91 a0 07 	lds	r31, 0x07A0
    4752:	86 81       	ldd	r24, Z+6	; 0x06
    4754:	97 81       	ldd	r25, Z+7	; 0x07
    4756:	9c 83       	std	Y+4, r25	; 0x04
    4758:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    475a:	8b 81       	ldd	r24, Y+3	; 0x03
    475c:	9c 81       	ldd	r25, Y+4	; 0x04
    475e:	0c 96       	adiw	r24, 0x0c	; 12
    4760:	0e 94 87 19 	call	0x330e	; 0x330e <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    4764:	8b 81       	ldd	r24, Y+3	; 0x03
    4766:	9c 81       	ldd	r25, Y+4	; 0x04
    4768:	02 96       	adiw	r24, 0x02	; 2
    476a:	0e 94 87 19 	call	0x330e	; 0x330e <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    476e:	eb 81       	ldd	r30, Y+3	; 0x03
    4770:	fc 81       	ldd	r31, Y+4	; 0x04
    4772:	96 89       	ldd	r25, Z+22	; 0x16
    4774:	80 91 35 07 	lds	r24, 0x0735
    4778:	89 17       	cp	r24, r25
    477a:	28 f4       	brcc	.+10     	; 0x4786 <xTaskResumeAll+0x72>
    477c:	eb 81       	ldd	r30, Y+3	; 0x03
    477e:	fc 81       	ldd	r31, Y+4	; 0x04
    4780:	86 89       	ldd	r24, Z+22	; 0x16
    4782:	80 93 35 07 	sts	0x0735, r24
    4786:	eb 81       	ldd	r30, Y+3	; 0x03
    4788:	fc 81       	ldd	r31, Y+4	; 0x04
    478a:	86 89       	ldd	r24, Z+22	; 0x16
    478c:	28 2f       	mov	r18, r24
    478e:	30 e0       	ldi	r19, 0x00	; 0
    4790:	c9 01       	movw	r24, r18
    4792:	88 0f       	add	r24, r24
    4794:	99 1f       	adc	r25, r25
    4796:	88 0f       	add	r24, r24
    4798:	99 1f       	adc	r25, r25
    479a:	88 0f       	add	r24, r24
    479c:	99 1f       	adc	r25, r25
    479e:	82 0f       	add	r24, r18
    47a0:	93 1f       	adc	r25, r19
    47a2:	84 5c       	subi	r24, 0xC4	; 196
    47a4:	98 4f       	sbci	r25, 0xF8	; 248
    47a6:	2b 81       	ldd	r18, Y+3	; 0x03
    47a8:	3c 81       	ldd	r19, Y+4	; 0x04
    47aa:	2e 5f       	subi	r18, 0xFE	; 254
    47ac:	3f 4f       	sbci	r19, 0xFF	; 255
    47ae:	b9 01       	movw	r22, r18
    47b0:	0e 94 cf 18 	call	0x319e	; 0x319e <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    47b4:	eb 81       	ldd	r30, Y+3	; 0x03
    47b6:	fc 81       	ldd	r31, Y+4	; 0x04
    47b8:	96 89       	ldd	r25, Z+22	; 0x16
    47ba:	e0 91 2e 07 	lds	r30, 0x072E
    47be:	f0 91 2f 07 	lds	r31, 0x072F
    47c2:	86 89       	ldd	r24, Z+22	; 0x16
    47c4:	98 17       	cp	r25, r24
    47c6:	10 f0       	brcs	.+4      	; 0x47cc <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    47c8:	81 e0       	ldi	r24, 0x01	; 1
    47ca:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    47cc:	80 91 9a 07 	lds	r24, 0x079A
    47d0:	88 23       	and	r24, r24
    47d2:	09 f0       	breq	.+2      	; 0x47d6 <xTaskResumeAll+0xc2>
    47d4:	ba cf       	rjmp	.-140    	; 0x474a <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    47d6:	80 91 38 07 	lds	r24, 0x0738
    47da:	88 23       	and	r24, r24
    47dc:	71 f0       	breq	.+28     	; 0x47fa <xTaskResumeAll+0xe6>
    47de:	07 c0       	rjmp	.+14     	; 0x47ee <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    47e0:	0e 94 49 24 	call	0x4892	; 0x4892 <vTaskIncrementTick>
						--uxMissedTicks;
    47e4:	80 91 38 07 	lds	r24, 0x0738
    47e8:	81 50       	subi	r24, 0x01	; 1
    47ea:	80 93 38 07 	sts	0x0738, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    47ee:	80 91 38 07 	lds	r24, 0x0738
    47f2:	88 23       	and	r24, r24
    47f4:	a9 f7       	brne	.-22     	; 0x47e0 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    47f6:	81 e0       	ldi	r24, 0x01	; 1
    47f8:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    47fa:	89 81       	ldd	r24, Y+1	; 0x01
    47fc:	81 30       	cpi	r24, 0x01	; 1
    47fe:	21 f0       	breq	.+8      	; 0x4808 <xTaskResumeAll+0xf4>
    4800:	80 91 39 07 	lds	r24, 0x0739
    4804:	81 30       	cpi	r24, 0x01	; 1
    4806:	31 f4       	brne	.+12     	; 0x4814 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    4808:	81 e0       	ldi	r24, 0x01	; 1
    480a:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    480c:	10 92 39 07 	sts	0x0739, r1
					portYIELD_WITHIN_API();
    4810:	0e 94 8f 1b 	call	0x371e	; 0x371e <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    4814:	0f 90       	pop	r0
    4816:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4818:	8a 81       	ldd	r24, Y+2	; 0x02
}
    481a:	0f 90       	pop	r0
    481c:	0f 90       	pop	r0
    481e:	0f 90       	pop	r0
    4820:	0f 90       	pop	r0
    4822:	cf 91       	pop	r28
    4824:	df 91       	pop	r29
    4826:	08 95       	ret

00004828 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    4828:	df 93       	push	r29
    482a:	cf 93       	push	r28
    482c:	00 d0       	rcall	.+0      	; 0x482e <xTaskGetTickCount+0x6>
    482e:	cd b7       	in	r28, 0x3d	; 61
    4830:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    4832:	0f b6       	in	r0, 0x3f	; 63
    4834:	f8 94       	cli
    4836:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4838:	80 91 32 07 	lds	r24, 0x0732
    483c:	90 91 33 07 	lds	r25, 0x0733
    4840:	9a 83       	std	Y+2, r25	; 0x02
    4842:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4844:	0f 90       	pop	r0
    4846:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4848:	89 81       	ldd	r24, Y+1	; 0x01
    484a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    484c:	0f 90       	pop	r0
    484e:	0f 90       	pop	r0
    4850:	cf 91       	pop	r28
    4852:	df 91       	pop	r29
    4854:	08 95       	ret

00004856 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    4856:	df 93       	push	r29
    4858:	cf 93       	push	r28
    485a:	00 d0       	rcall	.+0      	; 0x485c <xTaskGetTickCountFromISR+0x6>
    485c:	0f 92       	push	r0
    485e:	cd b7       	in	r28, 0x3d	; 61
    4860:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4862:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    4864:	80 91 32 07 	lds	r24, 0x0732
    4868:	90 91 33 07 	lds	r25, 0x0733
    486c:	9b 83       	std	Y+3, r25	; 0x03
    486e:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4870:	8a 81       	ldd	r24, Y+2	; 0x02
    4872:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4874:	0f 90       	pop	r0
    4876:	0f 90       	pop	r0
    4878:	0f 90       	pop	r0
    487a:	cf 91       	pop	r28
    487c:	df 91       	pop	r29
    487e:	08 95       	ret

00004880 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    4880:	df 93       	push	r29
    4882:	cf 93       	push	r28
    4884:	cd b7       	in	r28, 0x3d	; 61
    4886:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    4888:	80 91 31 07 	lds	r24, 0x0731
}
    488c:	cf 91       	pop	r28
    488e:	df 91       	pop	r29
    4890:	08 95       	ret

00004892 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    4892:	df 93       	push	r29
    4894:	cf 93       	push	r28
    4896:	00 d0       	rcall	.+0      	; 0x4898 <vTaskIncrementTick+0x6>
    4898:	00 d0       	rcall	.+0      	; 0x489a <vTaskIncrementTick+0x8>
    489a:	00 d0       	rcall	.+0      	; 0x489c <vTaskIncrementTick+0xa>
    489c:	cd b7       	in	r28, 0x3d	; 61
    489e:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    48a0:	80 91 37 07 	lds	r24, 0x0737
    48a4:	88 23       	and	r24, r24
    48a6:	09 f0       	breq	.+2      	; 0x48aa <vTaskIncrementTick+0x18>
    48a8:	bb c0       	rjmp	.+374    	; 0x4a20 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    48aa:	80 91 32 07 	lds	r24, 0x0732
    48ae:	90 91 33 07 	lds	r25, 0x0733
    48b2:	01 96       	adiw	r24, 0x01	; 1
    48b4:	90 93 33 07 	sts	0x0733, r25
    48b8:	80 93 32 07 	sts	0x0732, r24
		if( xTickCount == ( portTickType ) 0U )
    48bc:	80 91 32 07 	lds	r24, 0x0732
    48c0:	90 91 33 07 	lds	r25, 0x0733
    48c4:	00 97       	sbiw	r24, 0x00	; 0
    48c6:	d1 f5       	brne	.+116    	; 0x493c <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    48c8:	80 91 96 07 	lds	r24, 0x0796
    48cc:	90 91 97 07 	lds	r25, 0x0797
    48d0:	9c 83       	std	Y+4, r25	; 0x04
    48d2:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    48d4:	80 91 98 07 	lds	r24, 0x0798
    48d8:	90 91 99 07 	lds	r25, 0x0799
    48dc:	90 93 97 07 	sts	0x0797, r25
    48e0:	80 93 96 07 	sts	0x0796, r24
			pxOverflowDelayedTaskList = pxTemp;
    48e4:	8b 81       	ldd	r24, Y+3	; 0x03
    48e6:	9c 81       	ldd	r25, Y+4	; 0x04
    48e8:	90 93 99 07 	sts	0x0799, r25
    48ec:	80 93 98 07 	sts	0x0798, r24
			xNumOfOverflows++;
    48f0:	80 91 3a 07 	lds	r24, 0x073A
    48f4:	8f 5f       	subi	r24, 0xFF	; 255
    48f6:	80 93 3a 07 	sts	0x073A, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    48fa:	e0 91 96 07 	lds	r30, 0x0796
    48fe:	f0 91 97 07 	lds	r31, 0x0797
    4902:	80 81       	ld	r24, Z
    4904:	88 23       	and	r24, r24
    4906:	39 f4       	brne	.+14     	; 0x4916 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    4908:	8f ef       	ldi	r24, 0xFF	; 255
    490a:	9f ef       	ldi	r25, 0xFF	; 255
    490c:	90 93 98 00 	sts	0x0098, r25
    4910:	80 93 97 00 	sts	0x0097, r24
    4914:	13 c0       	rjmp	.+38     	; 0x493c <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    4916:	e0 91 96 07 	lds	r30, 0x0796
    491a:	f0 91 97 07 	lds	r31, 0x0797
    491e:	05 80       	ldd	r0, Z+5	; 0x05
    4920:	f6 81       	ldd	r31, Z+6	; 0x06
    4922:	e0 2d       	mov	r30, r0
    4924:	86 81       	ldd	r24, Z+6	; 0x06
    4926:	97 81       	ldd	r25, Z+7	; 0x07
    4928:	9e 83       	std	Y+6, r25	; 0x06
    492a:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    492c:	ed 81       	ldd	r30, Y+5	; 0x05
    492e:	fe 81       	ldd	r31, Y+6	; 0x06
    4930:	82 81       	ldd	r24, Z+2	; 0x02
    4932:	93 81       	ldd	r25, Z+3	; 0x03
    4934:	90 93 98 00 	sts	0x0098, r25
    4938:	80 93 97 00 	sts	0x0097, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    493c:	20 91 32 07 	lds	r18, 0x0732
    4940:	30 91 33 07 	lds	r19, 0x0733
    4944:	80 91 97 00 	lds	r24, 0x0097
    4948:	90 91 98 00 	lds	r25, 0x0098
    494c:	28 17       	cp	r18, r24
    494e:	39 07       	cpc	r19, r25
    4950:	08 f4       	brcc	.+2      	; 0x4954 <vTaskIncrementTick+0xc2>
    4952:	6b c0       	rjmp	.+214    	; 0x4a2a <vTaskIncrementTick+0x198>
    4954:	e0 91 96 07 	lds	r30, 0x0796
    4958:	f0 91 97 07 	lds	r31, 0x0797
    495c:	80 81       	ld	r24, Z
    495e:	88 23       	and	r24, r24
    4960:	39 f4       	brne	.+14     	; 0x4970 <vTaskIncrementTick+0xde>
    4962:	8f ef       	ldi	r24, 0xFF	; 255
    4964:	9f ef       	ldi	r25, 0xFF	; 255
    4966:	90 93 98 00 	sts	0x0098, r25
    496a:	80 93 97 00 	sts	0x0097, r24
    496e:	5d c0       	rjmp	.+186    	; 0x4a2a <vTaskIncrementTick+0x198>
    4970:	e0 91 96 07 	lds	r30, 0x0796
    4974:	f0 91 97 07 	lds	r31, 0x0797
    4978:	05 80       	ldd	r0, Z+5	; 0x05
    497a:	f6 81       	ldd	r31, Z+6	; 0x06
    497c:	e0 2d       	mov	r30, r0
    497e:	86 81       	ldd	r24, Z+6	; 0x06
    4980:	97 81       	ldd	r25, Z+7	; 0x07
    4982:	9e 83       	std	Y+6, r25	; 0x06
    4984:	8d 83       	std	Y+5, r24	; 0x05
    4986:	ed 81       	ldd	r30, Y+5	; 0x05
    4988:	fe 81       	ldd	r31, Y+6	; 0x06
    498a:	82 81       	ldd	r24, Z+2	; 0x02
    498c:	93 81       	ldd	r25, Z+3	; 0x03
    498e:	9a 83       	std	Y+2, r25	; 0x02
    4990:	89 83       	std	Y+1, r24	; 0x01
    4992:	20 91 32 07 	lds	r18, 0x0732
    4996:	30 91 33 07 	lds	r19, 0x0733
    499a:	89 81       	ldd	r24, Y+1	; 0x01
    499c:	9a 81       	ldd	r25, Y+2	; 0x02
    499e:	28 17       	cp	r18, r24
    49a0:	39 07       	cpc	r19, r25
    49a2:	38 f4       	brcc	.+14     	; 0x49b2 <vTaskIncrementTick+0x120>
    49a4:	89 81       	ldd	r24, Y+1	; 0x01
    49a6:	9a 81       	ldd	r25, Y+2	; 0x02
    49a8:	90 93 98 00 	sts	0x0098, r25
    49ac:	80 93 97 00 	sts	0x0097, r24
    49b0:	3c c0       	rjmp	.+120    	; 0x4a2a <vTaskIncrementTick+0x198>
    49b2:	8d 81       	ldd	r24, Y+5	; 0x05
    49b4:	9e 81       	ldd	r25, Y+6	; 0x06
    49b6:	02 96       	adiw	r24, 0x02	; 2
    49b8:	0e 94 87 19 	call	0x330e	; 0x330e <vListRemove>
    49bc:	ed 81       	ldd	r30, Y+5	; 0x05
    49be:	fe 81       	ldd	r31, Y+6	; 0x06
    49c0:	84 89       	ldd	r24, Z+20	; 0x14
    49c2:	95 89       	ldd	r25, Z+21	; 0x15
    49c4:	00 97       	sbiw	r24, 0x00	; 0
    49c6:	29 f0       	breq	.+10     	; 0x49d2 <vTaskIncrementTick+0x140>
    49c8:	8d 81       	ldd	r24, Y+5	; 0x05
    49ca:	9e 81       	ldd	r25, Y+6	; 0x06
    49cc:	0c 96       	adiw	r24, 0x0c	; 12
    49ce:	0e 94 87 19 	call	0x330e	; 0x330e <vListRemove>
    49d2:	ed 81       	ldd	r30, Y+5	; 0x05
    49d4:	fe 81       	ldd	r31, Y+6	; 0x06
    49d6:	96 89       	ldd	r25, Z+22	; 0x16
    49d8:	80 91 35 07 	lds	r24, 0x0735
    49dc:	89 17       	cp	r24, r25
    49de:	28 f4       	brcc	.+10     	; 0x49ea <vTaskIncrementTick+0x158>
    49e0:	ed 81       	ldd	r30, Y+5	; 0x05
    49e2:	fe 81       	ldd	r31, Y+6	; 0x06
    49e4:	86 89       	ldd	r24, Z+22	; 0x16
    49e6:	80 93 35 07 	sts	0x0735, r24
    49ea:	ed 81       	ldd	r30, Y+5	; 0x05
    49ec:	fe 81       	ldd	r31, Y+6	; 0x06
    49ee:	86 89       	ldd	r24, Z+22	; 0x16
    49f0:	28 2f       	mov	r18, r24
    49f2:	30 e0       	ldi	r19, 0x00	; 0
    49f4:	c9 01       	movw	r24, r18
    49f6:	88 0f       	add	r24, r24
    49f8:	99 1f       	adc	r25, r25
    49fa:	88 0f       	add	r24, r24
    49fc:	99 1f       	adc	r25, r25
    49fe:	88 0f       	add	r24, r24
    4a00:	99 1f       	adc	r25, r25
    4a02:	82 0f       	add	r24, r18
    4a04:	93 1f       	adc	r25, r19
    4a06:	ac 01       	movw	r20, r24
    4a08:	44 5c       	subi	r20, 0xC4	; 196
    4a0a:	58 4f       	sbci	r21, 0xF8	; 248
    4a0c:	8d 81       	ldd	r24, Y+5	; 0x05
    4a0e:	9e 81       	ldd	r25, Y+6	; 0x06
    4a10:	9c 01       	movw	r18, r24
    4a12:	2e 5f       	subi	r18, 0xFE	; 254
    4a14:	3f 4f       	sbci	r19, 0xFF	; 255
    4a16:	ca 01       	movw	r24, r20
    4a18:	b9 01       	movw	r22, r18
    4a1a:	0e 94 cf 18 	call	0x319e	; 0x319e <vListInsertEnd>
    4a1e:	9a cf       	rjmp	.-204    	; 0x4954 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    4a20:	80 91 38 07 	lds	r24, 0x0738
    4a24:	8f 5f       	subi	r24, 0xFF	; 255
    4a26:	80 93 38 07 	sts	0x0738, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    4a2a:	26 96       	adiw	r28, 0x06	; 6
    4a2c:	0f b6       	in	r0, 0x3f	; 63
    4a2e:	f8 94       	cli
    4a30:	de bf       	out	0x3e, r29	; 62
    4a32:	0f be       	out	0x3f, r0	; 63
    4a34:	cd bf       	out	0x3d, r28	; 61
    4a36:	cf 91       	pop	r28
    4a38:	df 91       	pop	r29
    4a3a:	08 95       	ret

00004a3c <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    4a3c:	df 93       	push	r29
    4a3e:	cf 93       	push	r28
    4a40:	00 d0       	rcall	.+0      	; 0x4a42 <vTaskSwitchContext+0x6>
    4a42:	cd b7       	in	r28, 0x3d	; 61
    4a44:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    4a46:	80 91 37 07 	lds	r24, 0x0737
    4a4a:	88 23       	and	r24, r24
    4a4c:	49 f0       	breq	.+18     	; 0x4a60 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    4a4e:	81 e0       	ldi	r24, 0x01	; 1
    4a50:	80 93 39 07 	sts	0x0739, r24
    4a54:	54 c0       	rjmp	.+168    	; 0x4afe <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    4a56:	80 91 35 07 	lds	r24, 0x0735
    4a5a:	81 50       	subi	r24, 0x01	; 1
    4a5c:	80 93 35 07 	sts	0x0735, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    4a60:	80 91 35 07 	lds	r24, 0x0735
    4a64:	28 2f       	mov	r18, r24
    4a66:	30 e0       	ldi	r19, 0x00	; 0
    4a68:	c9 01       	movw	r24, r18
    4a6a:	88 0f       	add	r24, r24
    4a6c:	99 1f       	adc	r25, r25
    4a6e:	88 0f       	add	r24, r24
    4a70:	99 1f       	adc	r25, r25
    4a72:	88 0f       	add	r24, r24
    4a74:	99 1f       	adc	r25, r25
    4a76:	82 0f       	add	r24, r18
    4a78:	93 1f       	adc	r25, r19
    4a7a:	fc 01       	movw	r30, r24
    4a7c:	e4 5c       	subi	r30, 0xC4	; 196
    4a7e:	f8 4f       	sbci	r31, 0xF8	; 248
    4a80:	80 81       	ld	r24, Z
    4a82:	88 23       	and	r24, r24
    4a84:	41 f3       	breq	.-48     	; 0x4a56 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    4a86:	80 91 35 07 	lds	r24, 0x0735
    4a8a:	28 2f       	mov	r18, r24
    4a8c:	30 e0       	ldi	r19, 0x00	; 0
    4a8e:	c9 01       	movw	r24, r18
    4a90:	88 0f       	add	r24, r24
    4a92:	99 1f       	adc	r25, r25
    4a94:	88 0f       	add	r24, r24
    4a96:	99 1f       	adc	r25, r25
    4a98:	88 0f       	add	r24, r24
    4a9a:	99 1f       	adc	r25, r25
    4a9c:	82 0f       	add	r24, r18
    4a9e:	93 1f       	adc	r25, r19
    4aa0:	84 5c       	subi	r24, 0xC4	; 196
    4aa2:	98 4f       	sbci	r25, 0xF8	; 248
    4aa4:	9a 83       	std	Y+2, r25	; 0x02
    4aa6:	89 83       	std	Y+1, r24	; 0x01
    4aa8:	e9 81       	ldd	r30, Y+1	; 0x01
    4aaa:	fa 81       	ldd	r31, Y+2	; 0x02
    4aac:	01 80       	ldd	r0, Z+1	; 0x01
    4aae:	f2 81       	ldd	r31, Z+2	; 0x02
    4ab0:	e0 2d       	mov	r30, r0
    4ab2:	82 81       	ldd	r24, Z+2	; 0x02
    4ab4:	93 81       	ldd	r25, Z+3	; 0x03
    4ab6:	e9 81       	ldd	r30, Y+1	; 0x01
    4ab8:	fa 81       	ldd	r31, Y+2	; 0x02
    4aba:	92 83       	std	Z+2, r25	; 0x02
    4abc:	81 83       	std	Z+1, r24	; 0x01
    4abe:	e9 81       	ldd	r30, Y+1	; 0x01
    4ac0:	fa 81       	ldd	r31, Y+2	; 0x02
    4ac2:	21 81       	ldd	r18, Z+1	; 0x01
    4ac4:	32 81       	ldd	r19, Z+2	; 0x02
    4ac6:	89 81       	ldd	r24, Y+1	; 0x01
    4ac8:	9a 81       	ldd	r25, Y+2	; 0x02
    4aca:	03 96       	adiw	r24, 0x03	; 3
    4acc:	28 17       	cp	r18, r24
    4ace:	39 07       	cpc	r19, r25
    4ad0:	59 f4       	brne	.+22     	; 0x4ae8 <vTaskSwitchContext+0xac>
    4ad2:	e9 81       	ldd	r30, Y+1	; 0x01
    4ad4:	fa 81       	ldd	r31, Y+2	; 0x02
    4ad6:	01 80       	ldd	r0, Z+1	; 0x01
    4ad8:	f2 81       	ldd	r31, Z+2	; 0x02
    4ada:	e0 2d       	mov	r30, r0
    4adc:	82 81       	ldd	r24, Z+2	; 0x02
    4ade:	93 81       	ldd	r25, Z+3	; 0x03
    4ae0:	e9 81       	ldd	r30, Y+1	; 0x01
    4ae2:	fa 81       	ldd	r31, Y+2	; 0x02
    4ae4:	92 83       	std	Z+2, r25	; 0x02
    4ae6:	81 83       	std	Z+1, r24	; 0x01
    4ae8:	e9 81       	ldd	r30, Y+1	; 0x01
    4aea:	fa 81       	ldd	r31, Y+2	; 0x02
    4aec:	01 80       	ldd	r0, Z+1	; 0x01
    4aee:	f2 81       	ldd	r31, Z+2	; 0x02
    4af0:	e0 2d       	mov	r30, r0
    4af2:	86 81       	ldd	r24, Z+6	; 0x06
    4af4:	97 81       	ldd	r25, Z+7	; 0x07
    4af6:	90 93 2f 07 	sts	0x072F, r25
    4afa:	80 93 2e 07 	sts	0x072E, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    4afe:	0f 90       	pop	r0
    4b00:	0f 90       	pop	r0
    4b02:	cf 91       	pop	r28
    4b04:	df 91       	pop	r29
    4b06:	08 95       	ret

00004b08 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    4b08:	df 93       	push	r29
    4b0a:	cf 93       	push	r28
    4b0c:	00 d0       	rcall	.+0      	; 0x4b0e <vTaskPlaceOnEventList+0x6>
    4b0e:	00 d0       	rcall	.+0      	; 0x4b10 <vTaskPlaceOnEventList+0x8>
    4b10:	00 d0       	rcall	.+0      	; 0x4b12 <vTaskPlaceOnEventList+0xa>
    4b12:	cd b7       	in	r28, 0x3d	; 61
    4b14:	de b7       	in	r29, 0x3e	; 62
    4b16:	9c 83       	std	Y+4, r25	; 0x04
    4b18:	8b 83       	std	Y+3, r24	; 0x03
    4b1a:	7e 83       	std	Y+6, r23	; 0x06
    4b1c:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    4b1e:	4b 81       	ldd	r20, Y+3	; 0x03
    4b20:	5c 81       	ldd	r21, Y+4	; 0x04
    4b22:	80 91 2e 07 	lds	r24, 0x072E
    4b26:	90 91 2f 07 	lds	r25, 0x072F
    4b2a:	9c 01       	movw	r18, r24
    4b2c:	24 5f       	subi	r18, 0xF4	; 244
    4b2e:	3f 4f       	sbci	r19, 0xFF	; 255
    4b30:	ca 01       	movw	r24, r20
    4b32:	b9 01       	movw	r22, r18
    4b34:	0e 94 1b 19 	call	0x3236	; 0x3236 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4b38:	80 91 2e 07 	lds	r24, 0x072E
    4b3c:	90 91 2f 07 	lds	r25, 0x072F
    4b40:	02 96       	adiw	r24, 0x02	; 2
    4b42:	0e 94 87 19 	call	0x330e	; 0x330e <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    4b46:	20 91 32 07 	lds	r18, 0x0732
    4b4a:	30 91 33 07 	lds	r19, 0x0733
    4b4e:	8d 81       	ldd	r24, Y+5	; 0x05
    4b50:	9e 81       	ldd	r25, Y+6	; 0x06
    4b52:	82 0f       	add	r24, r18
    4b54:	93 1f       	adc	r25, r19
    4b56:	9a 83       	std	Y+2, r25	; 0x02
    4b58:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    4b5a:	89 81       	ldd	r24, Y+1	; 0x01
    4b5c:	9a 81       	ldd	r25, Y+2	; 0x02
    4b5e:	0e 94 7e 27 	call	0x4efc	; 0x4efc <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    4b62:	26 96       	adiw	r28, 0x06	; 6
    4b64:	0f b6       	in	r0, 0x3f	; 63
    4b66:	f8 94       	cli
    4b68:	de bf       	out	0x3e, r29	; 62
    4b6a:	0f be       	out	0x3f, r0	; 63
    4b6c:	cd bf       	out	0x3d, r28	; 61
    4b6e:	cf 91       	pop	r28
    4b70:	df 91       	pop	r29
    4b72:	08 95       	ret

00004b74 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    4b74:	df 93       	push	r29
    4b76:	cf 93       	push	r28
    4b78:	00 d0       	rcall	.+0      	; 0x4b7a <xTaskRemoveFromEventList+0x6>
    4b7a:	00 d0       	rcall	.+0      	; 0x4b7c <xTaskRemoveFromEventList+0x8>
    4b7c:	0f 92       	push	r0
    4b7e:	cd b7       	in	r28, 0x3d	; 61
    4b80:	de b7       	in	r29, 0x3e	; 62
    4b82:	9d 83       	std	Y+5, r25	; 0x05
    4b84:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    4b86:	ec 81       	ldd	r30, Y+4	; 0x04
    4b88:	fd 81       	ldd	r31, Y+5	; 0x05
    4b8a:	05 80       	ldd	r0, Z+5	; 0x05
    4b8c:	f6 81       	ldd	r31, Z+6	; 0x06
    4b8e:	e0 2d       	mov	r30, r0
    4b90:	86 81       	ldd	r24, Z+6	; 0x06
    4b92:	97 81       	ldd	r25, Z+7	; 0x07
    4b94:	9b 83       	std	Y+3, r25	; 0x03
    4b96:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4b98:	8a 81       	ldd	r24, Y+2	; 0x02
    4b9a:	9b 81       	ldd	r25, Y+3	; 0x03
    4b9c:	0c 96       	adiw	r24, 0x0c	; 12
    4b9e:	0e 94 87 19 	call	0x330e	; 0x330e <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4ba2:	80 91 37 07 	lds	r24, 0x0737
    4ba6:	88 23       	and	r24, r24
    4ba8:	61 f5       	brne	.+88     	; 0x4c02 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    4baa:	8a 81       	ldd	r24, Y+2	; 0x02
    4bac:	9b 81       	ldd	r25, Y+3	; 0x03
    4bae:	02 96       	adiw	r24, 0x02	; 2
    4bb0:	0e 94 87 19 	call	0x330e	; 0x330e <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    4bb4:	ea 81       	ldd	r30, Y+2	; 0x02
    4bb6:	fb 81       	ldd	r31, Y+3	; 0x03
    4bb8:	96 89       	ldd	r25, Z+22	; 0x16
    4bba:	80 91 35 07 	lds	r24, 0x0735
    4bbe:	89 17       	cp	r24, r25
    4bc0:	28 f4       	brcc	.+10     	; 0x4bcc <xTaskRemoveFromEventList+0x58>
    4bc2:	ea 81       	ldd	r30, Y+2	; 0x02
    4bc4:	fb 81       	ldd	r31, Y+3	; 0x03
    4bc6:	86 89       	ldd	r24, Z+22	; 0x16
    4bc8:	80 93 35 07 	sts	0x0735, r24
    4bcc:	ea 81       	ldd	r30, Y+2	; 0x02
    4bce:	fb 81       	ldd	r31, Y+3	; 0x03
    4bd0:	86 89       	ldd	r24, Z+22	; 0x16
    4bd2:	28 2f       	mov	r18, r24
    4bd4:	30 e0       	ldi	r19, 0x00	; 0
    4bd6:	c9 01       	movw	r24, r18
    4bd8:	88 0f       	add	r24, r24
    4bda:	99 1f       	adc	r25, r25
    4bdc:	88 0f       	add	r24, r24
    4bde:	99 1f       	adc	r25, r25
    4be0:	88 0f       	add	r24, r24
    4be2:	99 1f       	adc	r25, r25
    4be4:	82 0f       	add	r24, r18
    4be6:	93 1f       	adc	r25, r19
    4be8:	ac 01       	movw	r20, r24
    4bea:	44 5c       	subi	r20, 0xC4	; 196
    4bec:	58 4f       	sbci	r21, 0xF8	; 248
    4bee:	8a 81       	ldd	r24, Y+2	; 0x02
    4bf0:	9b 81       	ldd	r25, Y+3	; 0x03
    4bf2:	9c 01       	movw	r18, r24
    4bf4:	2e 5f       	subi	r18, 0xFE	; 254
    4bf6:	3f 4f       	sbci	r19, 0xFF	; 255
    4bf8:	ca 01       	movw	r24, r20
    4bfa:	b9 01       	movw	r22, r18
    4bfc:	0e 94 cf 18 	call	0x319e	; 0x319e <vListInsertEnd>
    4c00:	0a c0       	rjmp	.+20     	; 0x4c16 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4c02:	8a 81       	ldd	r24, Y+2	; 0x02
    4c04:	9b 81       	ldd	r25, Y+3	; 0x03
    4c06:	9c 01       	movw	r18, r24
    4c08:	24 5f       	subi	r18, 0xF4	; 244
    4c0a:	3f 4f       	sbci	r19, 0xFF	; 255
    4c0c:	8a e9       	ldi	r24, 0x9A	; 154
    4c0e:	97 e0       	ldi	r25, 0x07	; 7
    4c10:	b9 01       	movw	r22, r18
    4c12:	0e 94 cf 18 	call	0x319e	; 0x319e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4c16:	ea 81       	ldd	r30, Y+2	; 0x02
    4c18:	fb 81       	ldd	r31, Y+3	; 0x03
    4c1a:	96 89       	ldd	r25, Z+22	; 0x16
    4c1c:	e0 91 2e 07 	lds	r30, 0x072E
    4c20:	f0 91 2f 07 	lds	r31, 0x072F
    4c24:	86 89       	ldd	r24, Z+22	; 0x16
    4c26:	98 17       	cp	r25, r24
    4c28:	18 f0       	brcs	.+6      	; 0x4c30 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    4c2a:	81 e0       	ldi	r24, 0x01	; 1
    4c2c:	89 83       	std	Y+1, r24	; 0x01
    4c2e:	01 c0       	rjmp	.+2      	; 0x4c32 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    4c30:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4c32:	89 81       	ldd	r24, Y+1	; 0x01
}
    4c34:	0f 90       	pop	r0
    4c36:	0f 90       	pop	r0
    4c38:	0f 90       	pop	r0
    4c3a:	0f 90       	pop	r0
    4c3c:	0f 90       	pop	r0
    4c3e:	cf 91       	pop	r28
    4c40:	df 91       	pop	r29
    4c42:	08 95       	ret

00004c44 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    4c44:	df 93       	push	r29
    4c46:	cf 93       	push	r28
    4c48:	00 d0       	rcall	.+0      	; 0x4c4a <vTaskSetTimeOutState+0x6>
    4c4a:	cd b7       	in	r28, 0x3d	; 61
    4c4c:	de b7       	in	r29, 0x3e	; 62
    4c4e:	9a 83       	std	Y+2, r25	; 0x02
    4c50:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    4c52:	80 91 3a 07 	lds	r24, 0x073A
    4c56:	e9 81       	ldd	r30, Y+1	; 0x01
    4c58:	fa 81       	ldd	r31, Y+2	; 0x02
    4c5a:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4c5c:	80 91 32 07 	lds	r24, 0x0732
    4c60:	90 91 33 07 	lds	r25, 0x0733
    4c64:	e9 81       	ldd	r30, Y+1	; 0x01
    4c66:	fa 81       	ldd	r31, Y+2	; 0x02
    4c68:	92 83       	std	Z+2, r25	; 0x02
    4c6a:	81 83       	std	Z+1, r24	; 0x01
}
    4c6c:	0f 90       	pop	r0
    4c6e:	0f 90       	pop	r0
    4c70:	cf 91       	pop	r28
    4c72:	df 91       	pop	r29
    4c74:	08 95       	ret

00004c76 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    4c76:	df 93       	push	r29
    4c78:	cf 93       	push	r28
    4c7a:	00 d0       	rcall	.+0      	; 0x4c7c <xTaskCheckForTimeOut+0x6>
    4c7c:	00 d0       	rcall	.+0      	; 0x4c7e <xTaskCheckForTimeOut+0x8>
    4c7e:	0f 92       	push	r0
    4c80:	cd b7       	in	r28, 0x3d	; 61
    4c82:	de b7       	in	r29, 0x3e	; 62
    4c84:	9b 83       	std	Y+3, r25	; 0x03
    4c86:	8a 83       	std	Y+2, r24	; 0x02
    4c88:	7d 83       	std	Y+5, r23	; 0x05
    4c8a:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4c8c:	0f b6       	in	r0, 0x3f	; 63
    4c8e:	f8 94       	cli
    4c90:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    4c92:	ea 81       	ldd	r30, Y+2	; 0x02
    4c94:	fb 81       	ldd	r31, Y+3	; 0x03
    4c96:	90 81       	ld	r25, Z
    4c98:	80 91 3a 07 	lds	r24, 0x073A
    4c9c:	98 17       	cp	r25, r24
    4c9e:	71 f0       	breq	.+28     	; 0x4cbc <xTaskCheckForTimeOut+0x46>
    4ca0:	ea 81       	ldd	r30, Y+2	; 0x02
    4ca2:	fb 81       	ldd	r31, Y+3	; 0x03
    4ca4:	21 81       	ldd	r18, Z+1	; 0x01
    4ca6:	32 81       	ldd	r19, Z+2	; 0x02
    4ca8:	80 91 32 07 	lds	r24, 0x0732
    4cac:	90 91 33 07 	lds	r25, 0x0733
    4cb0:	82 17       	cp	r24, r18
    4cb2:	93 07       	cpc	r25, r19
    4cb4:	18 f0       	brcs	.+6      	; 0x4cbc <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    4cb6:	81 e0       	ldi	r24, 0x01	; 1
    4cb8:	89 83       	std	Y+1, r24	; 0x01
    4cba:	2f c0       	rjmp	.+94     	; 0x4d1a <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    4cbc:	20 91 32 07 	lds	r18, 0x0732
    4cc0:	30 91 33 07 	lds	r19, 0x0733
    4cc4:	ea 81       	ldd	r30, Y+2	; 0x02
    4cc6:	fb 81       	ldd	r31, Y+3	; 0x03
    4cc8:	81 81       	ldd	r24, Z+1	; 0x01
    4cca:	92 81       	ldd	r25, Z+2	; 0x02
    4ccc:	28 1b       	sub	r18, r24
    4cce:	39 0b       	sbc	r19, r25
    4cd0:	ec 81       	ldd	r30, Y+4	; 0x04
    4cd2:	fd 81       	ldd	r31, Y+5	; 0x05
    4cd4:	80 81       	ld	r24, Z
    4cd6:	91 81       	ldd	r25, Z+1	; 0x01
    4cd8:	28 17       	cp	r18, r24
    4cda:	39 07       	cpc	r19, r25
    4cdc:	e0 f4       	brcc	.+56     	; 0x4d16 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    4cde:	ec 81       	ldd	r30, Y+4	; 0x04
    4ce0:	fd 81       	ldd	r31, Y+5	; 0x05
    4ce2:	40 81       	ld	r20, Z
    4ce4:	51 81       	ldd	r21, Z+1	; 0x01
    4ce6:	ea 81       	ldd	r30, Y+2	; 0x02
    4ce8:	fb 81       	ldd	r31, Y+3	; 0x03
    4cea:	21 81       	ldd	r18, Z+1	; 0x01
    4cec:	32 81       	ldd	r19, Z+2	; 0x02
    4cee:	80 91 32 07 	lds	r24, 0x0732
    4cf2:	90 91 33 07 	lds	r25, 0x0733
    4cf6:	b9 01       	movw	r22, r18
    4cf8:	68 1b       	sub	r22, r24
    4cfa:	79 0b       	sbc	r23, r25
    4cfc:	cb 01       	movw	r24, r22
    4cfe:	84 0f       	add	r24, r20
    4d00:	95 1f       	adc	r25, r21
    4d02:	ec 81       	ldd	r30, Y+4	; 0x04
    4d04:	fd 81       	ldd	r31, Y+5	; 0x05
    4d06:	91 83       	std	Z+1, r25	; 0x01
    4d08:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    4d0a:	8a 81       	ldd	r24, Y+2	; 0x02
    4d0c:	9b 81       	ldd	r25, Y+3	; 0x03
    4d0e:	0e 94 22 26 	call	0x4c44	; 0x4c44 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    4d12:	19 82       	std	Y+1, r1	; 0x01
    4d14:	02 c0       	rjmp	.+4      	; 0x4d1a <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    4d16:	81 e0       	ldi	r24, 0x01	; 1
    4d18:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4d1a:	0f 90       	pop	r0
    4d1c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4d1e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4d20:	0f 90       	pop	r0
    4d22:	0f 90       	pop	r0
    4d24:	0f 90       	pop	r0
    4d26:	0f 90       	pop	r0
    4d28:	0f 90       	pop	r0
    4d2a:	cf 91       	pop	r28
    4d2c:	df 91       	pop	r29
    4d2e:	08 95       	ret

00004d30 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4d30:	df 93       	push	r29
    4d32:	cf 93       	push	r28
    4d34:	cd b7       	in	r28, 0x3d	; 61
    4d36:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    4d38:	81 e0       	ldi	r24, 0x01	; 1
    4d3a:	80 93 39 07 	sts	0x0739, r24
}
    4d3e:	cf 91       	pop	r28
    4d40:	df 91       	pop	r29
    4d42:	08 95       	ret

00004d44 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4d44:	df 93       	push	r29
    4d46:	cf 93       	push	r28
    4d48:	00 d0       	rcall	.+0      	; 0x4d4a <prvIdleTask+0x6>
    4d4a:	cd b7       	in	r28, 0x3d	; 61
    4d4c:	de b7       	in	r29, 0x3e	; 62
    4d4e:	9a 83       	std	Y+2, r25	; 0x02
    4d50:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    4d52:	0e 94 40 27 	call	0x4e80	; 0x4e80 <prvCheckTasksWaitingTermination>
    4d56:	fd cf       	rjmp	.-6      	; 0x4d52 <prvIdleTask+0xe>

00004d58 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    4d58:	0f 93       	push	r16
    4d5a:	1f 93       	push	r17
    4d5c:	df 93       	push	r29
    4d5e:	cf 93       	push	r28
    4d60:	cd b7       	in	r28, 0x3d	; 61
    4d62:	de b7       	in	r29, 0x3e	; 62
    4d64:	29 97       	sbiw	r28, 0x09	; 9
    4d66:	0f b6       	in	r0, 0x3f	; 63
    4d68:	f8 94       	cli
    4d6a:	de bf       	out	0x3e, r29	; 62
    4d6c:	0f be       	out	0x3f, r0	; 63
    4d6e:	cd bf       	out	0x3d, r28	; 61
    4d70:	9a 83       	std	Y+2, r25	; 0x02
    4d72:	89 83       	std	Y+1, r24	; 0x01
    4d74:	7c 83       	std	Y+4, r23	; 0x04
    4d76:	6b 83       	std	Y+3, r22	; 0x03
    4d78:	4d 83       	std	Y+5, r20	; 0x05
    4d7a:	3f 83       	std	Y+7, r19	; 0x07
    4d7c:	2e 83       	std	Y+6, r18	; 0x06
    4d7e:	19 87       	std	Y+9, r17	; 0x09
    4d80:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    4d82:	89 81       	ldd	r24, Y+1	; 0x01
    4d84:	9a 81       	ldd	r25, Y+2	; 0x02
    4d86:	49 96       	adiw	r24, 0x19	; 25
    4d88:	2b 81       	ldd	r18, Y+3	; 0x03
    4d8a:	3c 81       	ldd	r19, Y+4	; 0x04
    4d8c:	b9 01       	movw	r22, r18
    4d8e:	48 e0       	ldi	r20, 0x08	; 8
    4d90:	50 e0       	ldi	r21, 0x00	; 0
    4d92:	0e 94 f3 2e 	call	0x5de6	; 0x5de6 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    4d96:	e9 81       	ldd	r30, Y+1	; 0x01
    4d98:	fa 81       	ldd	r31, Y+2	; 0x02
    4d9a:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    4d9c:	8d 81       	ldd	r24, Y+5	; 0x05
    4d9e:	88 30       	cpi	r24, 0x08	; 8
    4da0:	10 f0       	brcs	.+4      	; 0x4da6 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    4da2:	87 e0       	ldi	r24, 0x07	; 7
    4da4:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    4da6:	e9 81       	ldd	r30, Y+1	; 0x01
    4da8:	fa 81       	ldd	r31, Y+2	; 0x02
    4daa:	8d 81       	ldd	r24, Y+5	; 0x05
    4dac:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    4dae:	89 81       	ldd	r24, Y+1	; 0x01
    4db0:	9a 81       	ldd	r25, Y+2	; 0x02
    4db2:	02 96       	adiw	r24, 0x02	; 2
    4db4:	0e 94 bf 18 	call	0x317e	; 0x317e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    4db8:	89 81       	ldd	r24, Y+1	; 0x01
    4dba:	9a 81       	ldd	r25, Y+2	; 0x02
    4dbc:	0c 96       	adiw	r24, 0x0c	; 12
    4dbe:	0e 94 bf 18 	call	0x317e	; 0x317e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    4dc2:	e9 81       	ldd	r30, Y+1	; 0x01
    4dc4:	fa 81       	ldd	r31, Y+2	; 0x02
    4dc6:	89 81       	ldd	r24, Y+1	; 0x01
    4dc8:	9a 81       	ldd	r25, Y+2	; 0x02
    4dca:	91 87       	std	Z+9, r25	; 0x09
    4dcc:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    4dce:	8d 81       	ldd	r24, Y+5	; 0x05
    4dd0:	28 2f       	mov	r18, r24
    4dd2:	30 e0       	ldi	r19, 0x00	; 0
    4dd4:	88 e0       	ldi	r24, 0x08	; 8
    4dd6:	90 e0       	ldi	r25, 0x00	; 0
    4dd8:	82 1b       	sub	r24, r18
    4dda:	93 0b       	sbc	r25, r19
    4ddc:	e9 81       	ldd	r30, Y+1	; 0x01
    4dde:	fa 81       	ldd	r31, Y+2	; 0x02
    4de0:	95 87       	std	Z+13, r25	; 0x0d
    4de2:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    4de4:	e9 81       	ldd	r30, Y+1	; 0x01
    4de6:	fa 81       	ldd	r31, Y+2	; 0x02
    4de8:	89 81       	ldd	r24, Y+1	; 0x01
    4dea:	9a 81       	ldd	r25, Y+2	; 0x02
    4dec:	93 8b       	std	Z+19, r25	; 0x13
    4dee:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    4df0:	29 96       	adiw	r28, 0x09	; 9
    4df2:	0f b6       	in	r0, 0x3f	; 63
    4df4:	f8 94       	cli
    4df6:	de bf       	out	0x3e, r29	; 62
    4df8:	0f be       	out	0x3f, r0	; 63
    4dfa:	cd bf       	out	0x3d, r28	; 61
    4dfc:	cf 91       	pop	r28
    4dfe:	df 91       	pop	r29
    4e00:	1f 91       	pop	r17
    4e02:	0f 91       	pop	r16
    4e04:	08 95       	ret

00004e06 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    4e06:	df 93       	push	r29
    4e08:	cf 93       	push	r28
    4e0a:	0f 92       	push	r0
    4e0c:	cd b7       	in	r28, 0x3d	; 61
    4e0e:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4e10:	19 82       	std	Y+1, r1	; 0x01
    4e12:	13 c0       	rjmp	.+38     	; 0x4e3a <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    4e14:	89 81       	ldd	r24, Y+1	; 0x01
    4e16:	28 2f       	mov	r18, r24
    4e18:	30 e0       	ldi	r19, 0x00	; 0
    4e1a:	c9 01       	movw	r24, r18
    4e1c:	88 0f       	add	r24, r24
    4e1e:	99 1f       	adc	r25, r25
    4e20:	88 0f       	add	r24, r24
    4e22:	99 1f       	adc	r25, r25
    4e24:	88 0f       	add	r24, r24
    4e26:	99 1f       	adc	r25, r25
    4e28:	82 0f       	add	r24, r18
    4e2a:	93 1f       	adc	r25, r19
    4e2c:	84 5c       	subi	r24, 0xC4	; 196
    4e2e:	98 4f       	sbci	r25, 0xF8	; 248
    4e30:	0e 94 95 18 	call	0x312a	; 0x312a <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4e34:	89 81       	ldd	r24, Y+1	; 0x01
    4e36:	8f 5f       	subi	r24, 0xFF	; 255
    4e38:	89 83       	std	Y+1, r24	; 0x01
    4e3a:	89 81       	ldd	r24, Y+1	; 0x01
    4e3c:	88 30       	cpi	r24, 0x08	; 8
    4e3e:	50 f3       	brcs	.-44     	; 0x4e14 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    4e40:	84 e8       	ldi	r24, 0x84	; 132
    4e42:	97 e0       	ldi	r25, 0x07	; 7
    4e44:	0e 94 95 18 	call	0x312a	; 0x312a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    4e48:	8d e8       	ldi	r24, 0x8D	; 141
    4e4a:	97 e0       	ldi	r25, 0x07	; 7
    4e4c:	0e 94 95 18 	call	0x312a	; 0x312a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    4e50:	8a e9       	ldi	r24, 0x9A	; 154
    4e52:	97 e0       	ldi	r25, 0x07	; 7
    4e54:	0e 94 95 18 	call	0x312a	; 0x312a <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    4e58:	83 ea       	ldi	r24, 0xA3	; 163
    4e5a:	97 e0       	ldi	r25, 0x07	; 7
    4e5c:	0e 94 95 18 	call	0x312a	; 0x312a <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4e60:	84 e8       	ldi	r24, 0x84	; 132
    4e62:	97 e0       	ldi	r25, 0x07	; 7
    4e64:	90 93 97 07 	sts	0x0797, r25
    4e68:	80 93 96 07 	sts	0x0796, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4e6c:	8d e8       	ldi	r24, 0x8D	; 141
    4e6e:	97 e0       	ldi	r25, 0x07	; 7
    4e70:	90 93 99 07 	sts	0x0799, r25
    4e74:	80 93 98 07 	sts	0x0798, r24
}
    4e78:	0f 90       	pop	r0
    4e7a:	cf 91       	pop	r28
    4e7c:	df 91       	pop	r29
    4e7e:	08 95       	ret

00004e80 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4e80:	df 93       	push	r29
    4e82:	cf 93       	push	r28
    4e84:	00 d0       	rcall	.+0      	; 0x4e86 <prvCheckTasksWaitingTermination+0x6>
    4e86:	0f 92       	push	r0
    4e88:	cd b7       	in	r28, 0x3d	; 61
    4e8a:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    4e8c:	80 91 30 07 	lds	r24, 0x0730
    4e90:	88 23       	and	r24, r24
    4e92:	71 f1       	breq	.+92     	; 0x4ef0 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    4e94:	0e 94 7e 23 	call	0x46fc	; 0x46fc <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    4e98:	80 91 a3 07 	lds	r24, 0x07A3
    4e9c:	1b 82       	std	Y+3, r1	; 0x03
    4e9e:	88 23       	and	r24, r24
    4ea0:	11 f4       	brne	.+4      	; 0x4ea6 <prvCheckTasksWaitingTermination+0x26>
    4ea2:	81 e0       	ldi	r24, 0x01	; 1
    4ea4:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    4ea6:	0e 94 8a 23 	call	0x4714	; 0x4714 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    4eaa:	8b 81       	ldd	r24, Y+3	; 0x03
    4eac:	88 23       	and	r24, r24
    4eae:	01 f5       	brne	.+64     	; 0x4ef0 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    4eb0:	0f b6       	in	r0, 0x3f	; 63
    4eb2:	f8 94       	cli
    4eb4:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    4eb6:	e0 91 a8 07 	lds	r30, 0x07A8
    4eba:	f0 91 a9 07 	lds	r31, 0x07A9
    4ebe:	86 81       	ldd	r24, Z+6	; 0x06
    4ec0:	97 81       	ldd	r25, Z+7	; 0x07
    4ec2:	9a 83       	std	Y+2, r25	; 0x02
    4ec4:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    4ec6:	89 81       	ldd	r24, Y+1	; 0x01
    4ec8:	9a 81       	ldd	r25, Y+2	; 0x02
    4eca:	02 96       	adiw	r24, 0x02	; 2
    4ecc:	0e 94 87 19 	call	0x330e	; 0x330e <vListRemove>
					--uxCurrentNumberOfTasks;
    4ed0:	80 91 31 07 	lds	r24, 0x0731
    4ed4:	81 50       	subi	r24, 0x01	; 1
    4ed6:	80 93 31 07 	sts	0x0731, r24
					--uxTasksDeleted;
    4eda:	80 91 30 07 	lds	r24, 0x0730
    4ede:	81 50       	subi	r24, 0x01	; 1
    4ee0:	80 93 30 07 	sts	0x0730, r24
				}
				taskEXIT_CRITICAL();
    4ee4:	0f 90       	pop	r0
    4ee6:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    4ee8:	89 81       	ldd	r24, Y+1	; 0x01
    4eea:	9a 81       	ldd	r25, Y+2	; 0x02
    4eec:	0e 94 17 28 	call	0x502e	; 0x502e <prvDeleteTCB>
			}
		}
	}
	#endif
}
    4ef0:	0f 90       	pop	r0
    4ef2:	0f 90       	pop	r0
    4ef4:	0f 90       	pop	r0
    4ef6:	cf 91       	pop	r28
    4ef8:	df 91       	pop	r29
    4efa:	08 95       	ret

00004efc <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    4efc:	df 93       	push	r29
    4efe:	cf 93       	push	r28
    4f00:	00 d0       	rcall	.+0      	; 0x4f02 <prvAddCurrentTaskToDelayedList+0x6>
    4f02:	cd b7       	in	r28, 0x3d	; 61
    4f04:	de b7       	in	r29, 0x3e	; 62
    4f06:	9a 83       	std	Y+2, r25	; 0x02
    4f08:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    4f0a:	e0 91 2e 07 	lds	r30, 0x072E
    4f0e:	f0 91 2f 07 	lds	r31, 0x072F
    4f12:	89 81       	ldd	r24, Y+1	; 0x01
    4f14:	9a 81       	ldd	r25, Y+2	; 0x02
    4f16:	93 83       	std	Z+3, r25	; 0x03
    4f18:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    4f1a:	20 91 32 07 	lds	r18, 0x0732
    4f1e:	30 91 33 07 	lds	r19, 0x0733
    4f22:	89 81       	ldd	r24, Y+1	; 0x01
    4f24:	9a 81       	ldd	r25, Y+2	; 0x02
    4f26:	82 17       	cp	r24, r18
    4f28:	93 07       	cpc	r25, r19
    4f2a:	70 f4       	brcc	.+28     	; 0x4f48 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4f2c:	80 91 98 07 	lds	r24, 0x0798
    4f30:	90 91 99 07 	lds	r25, 0x0799
    4f34:	20 91 2e 07 	lds	r18, 0x072E
    4f38:	30 91 2f 07 	lds	r19, 0x072F
    4f3c:	2e 5f       	subi	r18, 0xFE	; 254
    4f3e:	3f 4f       	sbci	r19, 0xFF	; 255
    4f40:	b9 01       	movw	r22, r18
    4f42:	0e 94 1b 19 	call	0x3236	; 0x3236 <vListInsert>
    4f46:	1e c0       	rjmp	.+60     	; 0x4f84 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4f48:	40 91 96 07 	lds	r20, 0x0796
    4f4c:	50 91 97 07 	lds	r21, 0x0797
    4f50:	80 91 2e 07 	lds	r24, 0x072E
    4f54:	90 91 2f 07 	lds	r25, 0x072F
    4f58:	9c 01       	movw	r18, r24
    4f5a:	2e 5f       	subi	r18, 0xFE	; 254
    4f5c:	3f 4f       	sbci	r19, 0xFF	; 255
    4f5e:	ca 01       	movw	r24, r20
    4f60:	b9 01       	movw	r22, r18
    4f62:	0e 94 1b 19 	call	0x3236	; 0x3236 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    4f66:	20 91 97 00 	lds	r18, 0x0097
    4f6a:	30 91 98 00 	lds	r19, 0x0098
    4f6e:	89 81       	ldd	r24, Y+1	; 0x01
    4f70:	9a 81       	ldd	r25, Y+2	; 0x02
    4f72:	82 17       	cp	r24, r18
    4f74:	93 07       	cpc	r25, r19
    4f76:	30 f4       	brcc	.+12     	; 0x4f84 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    4f78:	89 81       	ldd	r24, Y+1	; 0x01
    4f7a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f7c:	90 93 98 00 	sts	0x0098, r25
    4f80:	80 93 97 00 	sts	0x0097, r24
		}
	}
}
    4f84:	0f 90       	pop	r0
    4f86:	0f 90       	pop	r0
    4f88:	cf 91       	pop	r28
    4f8a:	df 91       	pop	r29
    4f8c:	08 95       	ret

00004f8e <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    4f8e:	df 93       	push	r29
    4f90:	cf 93       	push	r28
    4f92:	cd b7       	in	r28, 0x3d	; 61
    4f94:	de b7       	in	r29, 0x3e	; 62
    4f96:	28 97       	sbiw	r28, 0x08	; 8
    4f98:	0f b6       	in	r0, 0x3f	; 63
    4f9a:	f8 94       	cli
    4f9c:	de bf       	out	0x3e, r29	; 62
    4f9e:	0f be       	out	0x3f, r0	; 63
    4fa0:	cd bf       	out	0x3d, r28	; 61
    4fa2:	9c 83       	std	Y+4, r25	; 0x04
    4fa4:	8b 83       	std	Y+3, r24	; 0x03
    4fa6:	7e 83       	std	Y+6, r23	; 0x06
    4fa8:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    4faa:	81 e2       	ldi	r24, 0x21	; 33
    4fac:	90 e0       	ldi	r25, 0x00	; 0
    4fae:	0e 94 29 18 	call	0x3052	; 0x3052 <pvPortMalloc>
    4fb2:	9a 83       	std	Y+2, r25	; 0x02
    4fb4:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    4fb6:	89 81       	ldd	r24, Y+1	; 0x01
    4fb8:	9a 81       	ldd	r25, Y+2	; 0x02
    4fba:	00 97       	sbiw	r24, 0x00	; 0
    4fbc:	69 f1       	breq	.+90     	; 0x5018 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    4fbe:	8d 81       	ldd	r24, Y+5	; 0x05
    4fc0:	9e 81       	ldd	r25, Y+6	; 0x06
    4fc2:	00 97       	sbiw	r24, 0x00	; 0
    4fc4:	39 f4       	brne	.+14     	; 0x4fd4 <prvAllocateTCBAndStack+0x46>
    4fc6:	8b 81       	ldd	r24, Y+3	; 0x03
    4fc8:	9c 81       	ldd	r25, Y+4	; 0x04
    4fca:	0e 94 29 18 	call	0x3052	; 0x3052 <pvPortMalloc>
    4fce:	98 87       	std	Y+8, r25	; 0x08
    4fd0:	8f 83       	std	Y+7, r24	; 0x07
    4fd2:	04 c0       	rjmp	.+8      	; 0x4fdc <prvAllocateTCBAndStack+0x4e>
    4fd4:	8d 81       	ldd	r24, Y+5	; 0x05
    4fd6:	9e 81       	ldd	r25, Y+6	; 0x06
    4fd8:	98 87       	std	Y+8, r25	; 0x08
    4fda:	8f 83       	std	Y+7, r24	; 0x07
    4fdc:	e9 81       	ldd	r30, Y+1	; 0x01
    4fde:	fa 81       	ldd	r31, Y+2	; 0x02
    4fe0:	8f 81       	ldd	r24, Y+7	; 0x07
    4fe2:	98 85       	ldd	r25, Y+8	; 0x08
    4fe4:	90 8f       	std	Z+24, r25	; 0x18
    4fe6:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    4fe8:	e9 81       	ldd	r30, Y+1	; 0x01
    4fea:	fa 81       	ldd	r31, Y+2	; 0x02
    4fec:	87 89       	ldd	r24, Z+23	; 0x17
    4fee:	90 8d       	ldd	r25, Z+24	; 0x18
    4ff0:	00 97       	sbiw	r24, 0x00	; 0
    4ff2:	39 f4       	brne	.+14     	; 0x5002 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    4ff4:	89 81       	ldd	r24, Y+1	; 0x01
    4ff6:	9a 81       	ldd	r25, Y+2	; 0x02
    4ff8:	0e 94 6f 18 	call	0x30de	; 0x30de <vPortFree>
			pxNewTCB = NULL;
    4ffc:	1a 82       	std	Y+2, r1	; 0x02
    4ffe:	19 82       	std	Y+1, r1	; 0x01
    5000:	0b c0       	rjmp	.+22     	; 0x5018 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    5002:	e9 81       	ldd	r30, Y+1	; 0x01
    5004:	fa 81       	ldd	r31, Y+2	; 0x02
    5006:	87 89       	ldd	r24, Z+23	; 0x17
    5008:	90 8d       	ldd	r25, Z+24	; 0x18
    500a:	2b 81       	ldd	r18, Y+3	; 0x03
    500c:	3c 81       	ldd	r19, Y+4	; 0x04
    500e:	65 ea       	ldi	r22, 0xA5	; 165
    5010:	70 e0       	ldi	r23, 0x00	; 0
    5012:	a9 01       	movw	r20, r18
    5014:	0e 94 ec 2e 	call	0x5dd8	; 0x5dd8 <memset>
		}
	}

	return pxNewTCB;
    5018:	89 81       	ldd	r24, Y+1	; 0x01
    501a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    501c:	28 96       	adiw	r28, 0x08	; 8
    501e:	0f b6       	in	r0, 0x3f	; 63
    5020:	f8 94       	cli
    5022:	de bf       	out	0x3e, r29	; 62
    5024:	0f be       	out	0x3f, r0	; 63
    5026:	cd bf       	out	0x3d, r28	; 61
    5028:	cf 91       	pop	r28
    502a:	df 91       	pop	r29
    502c:	08 95       	ret

0000502e <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    502e:	df 93       	push	r29
    5030:	cf 93       	push	r28
    5032:	00 d0       	rcall	.+0      	; 0x5034 <prvDeleteTCB+0x6>
    5034:	cd b7       	in	r28, 0x3d	; 61
    5036:	de b7       	in	r29, 0x3e	; 62
    5038:	9a 83       	std	Y+2, r25	; 0x02
    503a:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    503c:	e9 81       	ldd	r30, Y+1	; 0x01
    503e:	fa 81       	ldd	r31, Y+2	; 0x02
    5040:	87 89       	ldd	r24, Z+23	; 0x17
    5042:	90 8d       	ldd	r25, Z+24	; 0x18
    5044:	0e 94 6f 18 	call	0x30de	; 0x30de <vPortFree>
		vPortFree( pxTCB );
    5048:	89 81       	ldd	r24, Y+1	; 0x01
    504a:	9a 81       	ldd	r25, Y+2	; 0x02
    504c:	0e 94 6f 18 	call	0x30de	; 0x30de <vPortFree>
	}
    5050:	0f 90       	pop	r0
    5052:	0f 90       	pop	r0
    5054:	cf 91       	pop	r28
    5056:	df 91       	pop	r29
    5058:	08 95       	ret

0000505a <main>:
static u8 Update_DispFlag=0;
u8 u8Temperatur;
u8 u8HeartRate;

int main(void)
{
    505a:	af 92       	push	r10
    505c:	bf 92       	push	r11
    505e:	cf 92       	push	r12
    5060:	df 92       	push	r13
    5062:	ef 92       	push	r14
    5064:	ff 92       	push	r15
    5066:	0f 93       	push	r16
    5068:	df 93       	push	r29
    506a:	cf 93       	push	r28
    506c:	cd b7       	in	r28, 0x3d	; 61
    506e:	de b7       	in	r29, 0x3e	; 62
    5070:	2e 97       	sbiw	r28, 0x0e	; 14
    5072:	0f b6       	in	r0, 0x3f	; 63
    5074:	f8 94       	cli
    5076:	de bf       	out	0x3e, r29	; 62
    5078:	0f be       	out	0x3f, r0	; 63
    507a:	cd bf       	out	0x3d, r28	; 61
	/* Initialization*/
	HCLCD_Vid4Bits_Init();
    507c:	0e 94 b2 11 	call	0x2364	; 0x2364 <HCLCD_Vid4Bits_Init>
	MDIO_Error_State_SetPinDirection(TIME_SET_BUTTON_PIN,TIME_SET_BUTTON_PORT,PIN_INPUT);
    5080:	82 e0       	ldi	r24, 0x02	; 2
    5082:	63 e0       	ldi	r22, 0x03	; 3
    5084:	40 e0       	ldi	r20, 0x00	; 0
    5086:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(INCREAMENT_BUTTON_PIN,INCREAMENT_BUTTON_PORT,PIN_INPUT);
    508a:	83 e0       	ldi	r24, 0x03	; 3
    508c:	63 e0       	ldi	r22, 0x03	; 3
    508e:	40 e0       	ldi	r20, 0x00	; 0
    5090:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(CONFIRM_BUTTON_PIN,CONFIRM_BUTTON_PORT,PIN_INPUT);
    5094:	84 e0       	ldi	r24, 0x04	; 4
    5096:	63 e0       	ldi	r22, 0x03	; 3
    5098:	40 e0       	ldi	r20, 0x00	; 0
    509a:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(FEAUTERS_BUTTON_PIN,FEAUTERS_BUTTON_PORT,PIN_INPUT);
    509e:	85 e0       	ldi	r24, 0x05	; 5
    50a0:	63 e0       	ldi	r22, 0x03	; 3
    50a2:	40 e0       	ldi	r20, 0x00	; 0
    50a4:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>

	MDIO_Error_State_SetPinValue(TIME_SET_BUTTON_PIN,TIME_SET_BUTTON_PORT,PIN_HIGH);
    50a8:	82 e0       	ldi	r24, 0x02	; 2
    50aa:	63 e0       	ldi	r22, 0x03	; 3
    50ac:	41 e0       	ldi	r20, 0x01	; 1
    50ae:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(INCREAMENT_BUTTON_PIN,INCREAMENT_BUTTON_PORT,PIN_HIGH);
    50b2:	83 e0       	ldi	r24, 0x03	; 3
    50b4:	63 e0       	ldi	r22, 0x03	; 3
    50b6:	41 e0       	ldi	r20, 0x01	; 1
    50b8:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(CONFIRM_BUTTON_PIN,CONFIRM_BUTTON_PORT,PIN_HIGH);
    50bc:	84 e0       	ldi	r24, 0x04	; 4
    50be:	63 e0       	ldi	r22, 0x03	; 3
    50c0:	41 e0       	ldi	r20, 0x01	; 1
    50c2:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinValue(FEAUTERS_BUTTON_PIN,FEAUTERS_BUTTON_PORT,PIN_HIGH);
    50c6:	85 e0       	ldi	r24, 0x05	; 5
    50c8:	63 e0       	ldi	r22, 0x03	; 3
    50ca:	41 e0       	ldi	r20, 0x01	; 1
    50cc:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
	MDIO_Error_State_SetPinDirection(PIN1,MDIO_PORTB,PIN_OUTPUT);
    50d0:	81 e0       	ldi	r24, 0x01	; 1
    50d2:	61 e0       	ldi	r22, 0x01	; 1
    50d4:	41 e0       	ldi	r20, 0x01	; 1
    50d6:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>
	MDIO_Error_State_SetPinDirection(PIN0,MDIO_PORTB,PIN_OUTPUT);
    50da:	80 e0       	ldi	r24, 0x00	; 0
    50dc:	61 e0       	ldi	r22, 0x01	; 1
    50de:	41 e0       	ldi	r20, 0x01	; 1
    50e0:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>

	MDIO_Error_State_SetPinDirection(PIN0,MDIO_PORTC,PIN_OUTPUT);
    50e4:	80 e0       	ldi	r24, 0x00	; 0
    50e6:	62 e0       	ldi	r22, 0x02	; 2
    50e8:	41 e0       	ldi	r20, 0x01	; 1
    50ea:	0e 94 c3 06 	call	0xd86	; 0xd86 <MDIO_Error_State_SetPinDirection>

	/*Write WELCOME On LCD*/
	HCLCD_VidWriteString_4Bits("WELCOME...");
    50ee:	85 e6       	ldi	r24, 0x65	; 101
    50f0:	90 e0       	ldi	r25, 0x00	; 0
    50f2:	0e 94 72 14 	call	0x28e4	; 0x28e4 <HCLCD_VidWriteString_4Bits>
    50f6:	80 e0       	ldi	r24, 0x00	; 0
    50f8:	90 e0       	ldi	r25, 0x00	; 0
    50fa:	aa e7       	ldi	r26, 0x7A	; 122
    50fc:	b4 e4       	ldi	r27, 0x44	; 68
    50fe:	8b 87       	std	Y+11, r24	; 0x0b
    5100:	9c 87       	std	Y+12, r25	; 0x0c
    5102:	ad 87       	std	Y+13, r26	; 0x0d
    5104:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5106:	6b 85       	ldd	r22, Y+11	; 0x0b
    5108:	7c 85       	ldd	r23, Y+12	; 0x0c
    510a:	8d 85       	ldd	r24, Y+13	; 0x0d
    510c:	9e 85       	ldd	r25, Y+14	; 0x0e
    510e:	20 e0       	ldi	r18, 0x00	; 0
    5110:	30 e0       	ldi	r19, 0x00	; 0
    5112:	4a ef       	ldi	r20, 0xFA	; 250
    5114:	54 e4       	ldi	r21, 0x44	; 68
    5116:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    511a:	dc 01       	movw	r26, r24
    511c:	cb 01       	movw	r24, r22
    511e:	8f 83       	std	Y+7, r24	; 0x07
    5120:	98 87       	std	Y+8, r25	; 0x08
    5122:	a9 87       	std	Y+9, r26	; 0x09
    5124:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5126:	6f 81       	ldd	r22, Y+7	; 0x07
    5128:	78 85       	ldd	r23, Y+8	; 0x08
    512a:	89 85       	ldd	r24, Y+9	; 0x09
    512c:	9a 85       	ldd	r25, Y+10	; 0x0a
    512e:	20 e0       	ldi	r18, 0x00	; 0
    5130:	30 e0       	ldi	r19, 0x00	; 0
    5132:	40 e8       	ldi	r20, 0x80	; 128
    5134:	5f e3       	ldi	r21, 0x3F	; 63
    5136:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    513a:	88 23       	and	r24, r24
    513c:	2c f4       	brge	.+10     	; 0x5148 <main+0xee>
		__ticks = 1;
    513e:	81 e0       	ldi	r24, 0x01	; 1
    5140:	90 e0       	ldi	r25, 0x00	; 0
    5142:	9e 83       	std	Y+6, r25	; 0x06
    5144:	8d 83       	std	Y+5, r24	; 0x05
    5146:	3f c0       	rjmp	.+126    	; 0x51c6 <main+0x16c>
	else if (__tmp > 65535)
    5148:	6f 81       	ldd	r22, Y+7	; 0x07
    514a:	78 85       	ldd	r23, Y+8	; 0x08
    514c:	89 85       	ldd	r24, Y+9	; 0x09
    514e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5150:	20 e0       	ldi	r18, 0x00	; 0
    5152:	3f ef       	ldi	r19, 0xFF	; 255
    5154:	4f e7       	ldi	r20, 0x7F	; 127
    5156:	57 e4       	ldi	r21, 0x47	; 71
    5158:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    515c:	18 16       	cp	r1, r24
    515e:	4c f5       	brge	.+82     	; 0x51b2 <main+0x158>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5160:	6b 85       	ldd	r22, Y+11	; 0x0b
    5162:	7c 85       	ldd	r23, Y+12	; 0x0c
    5164:	8d 85       	ldd	r24, Y+13	; 0x0d
    5166:	9e 85       	ldd	r25, Y+14	; 0x0e
    5168:	20 e0       	ldi	r18, 0x00	; 0
    516a:	30 e0       	ldi	r19, 0x00	; 0
    516c:	40 e2       	ldi	r20, 0x20	; 32
    516e:	51 e4       	ldi	r21, 0x41	; 65
    5170:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5174:	dc 01       	movw	r26, r24
    5176:	cb 01       	movw	r24, r22
    5178:	bc 01       	movw	r22, r24
    517a:	cd 01       	movw	r24, r26
    517c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5180:	dc 01       	movw	r26, r24
    5182:	cb 01       	movw	r24, r22
    5184:	9e 83       	std	Y+6, r25	; 0x06
    5186:	8d 83       	std	Y+5, r24	; 0x05
    5188:	0f c0       	rjmp	.+30     	; 0x51a8 <main+0x14e>
    518a:	88 ec       	ldi	r24, 0xC8	; 200
    518c:	90 e0       	ldi	r25, 0x00	; 0
    518e:	9c 83       	std	Y+4, r25	; 0x04
    5190:	8b 83       	std	Y+3, r24	; 0x03
    5192:	8b 81       	ldd	r24, Y+3	; 0x03
    5194:	9c 81       	ldd	r25, Y+4	; 0x04
    5196:	01 97       	sbiw	r24, 0x01	; 1
    5198:	f1 f7       	brne	.-4      	; 0x5196 <main+0x13c>
    519a:	9c 83       	std	Y+4, r25	; 0x04
    519c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    519e:	8d 81       	ldd	r24, Y+5	; 0x05
    51a0:	9e 81       	ldd	r25, Y+6	; 0x06
    51a2:	01 97       	sbiw	r24, 0x01	; 1
    51a4:	9e 83       	std	Y+6, r25	; 0x06
    51a6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    51a8:	8d 81       	ldd	r24, Y+5	; 0x05
    51aa:	9e 81       	ldd	r25, Y+6	; 0x06
    51ac:	00 97       	sbiw	r24, 0x00	; 0
    51ae:	69 f7       	brne	.-38     	; 0x518a <main+0x130>
    51b0:	14 c0       	rjmp	.+40     	; 0x51da <main+0x180>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    51b2:	6f 81       	ldd	r22, Y+7	; 0x07
    51b4:	78 85       	ldd	r23, Y+8	; 0x08
    51b6:	89 85       	ldd	r24, Y+9	; 0x09
    51b8:	9a 85       	ldd	r25, Y+10	; 0x0a
    51ba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    51be:	dc 01       	movw	r26, r24
    51c0:	cb 01       	movw	r24, r22
    51c2:	9e 83       	std	Y+6, r25	; 0x06
    51c4:	8d 83       	std	Y+5, r24	; 0x05
    51c6:	8d 81       	ldd	r24, Y+5	; 0x05
    51c8:	9e 81       	ldd	r25, Y+6	; 0x06
    51ca:	9a 83       	std	Y+2, r25	; 0x02
    51cc:	89 83       	std	Y+1, r24	; 0x01
    51ce:	89 81       	ldd	r24, Y+1	; 0x01
    51d0:	9a 81       	ldd	r25, Y+2	; 0x02
    51d2:	01 97       	sbiw	r24, 0x01	; 1
    51d4:	f1 f7       	brne	.-4      	; 0x51d2 <main+0x178>
    51d6:	9a 83       	std	Y+2, r25	; 0x02
    51d8:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1000);
	/*Clear LCD*/
	HCLCD_VidWriteCommand_4Bits(0x01>>4);
    51da:	80 e0       	ldi	r24, 0x00	; 0
    51dc:	0e 94 12 11 	call	0x2224	; 0x2224 <HCLCD_VidWriteCommand_4Bits>
	HCLCD_VidWriteCommand_4Bits(0x01);
    51e0:	81 e0       	ldi	r24, 0x01	; 1
    51e2:	0e 94 12 11 	call	0x2224	; 0x2224 <HCLCD_VidWriteCommand_4Bits>
	/*ADC Initialization*/
	MADC_VidSetCallBack(ADC_SetNotification);
    51e6:	81 ea       	ldi	r24, 0xA1	; 161
    51e8:	9c e2       	ldi	r25, 0x2C	; 44
    51ea:	0e 94 4a 0b 	call	0x1694	; 0x1694 <MADC_VidSetCallBack>
	MADC_VidADCInterruptEnable();
    51ee:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <MADC_VidADCInterruptEnable>
	MADC_VidInit();
    51f2:	0e 94 ab 0a 	call	0x1556	; 0x1556 <MADC_VidInit>
	MADC_u16ADC_StartConversion_With_Interrupt(0);
    51f6:	80 e0       	ldi	r24, 0x00	; 0
    51f8:	0e 94 1c 0b 	call	0x1638	; 0x1638 <MADC_u16ADC_StartConversion_With_Interrupt>

	/*enable GIE */
	MGIE_VidEnable();
    51fc:	0e 94 a7 06 	call	0xd4e	; 0xd4e <MGIE_VidEnable>
	/*Semaphore Counting Creation */
	ADCSem = xSemaphoreCreateCounting(1,0);
    5200:	81 e0       	ldi	r24, 0x01	; 1
    5202:	60 e0       	ldi	r22, 0x00	; 0
    5204:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <xQueueCreateCountingSemaphore>
    5208:	90 93 d2 07 	sts	0x07D2, r25
    520c:	80 93 d1 07 	sts	0x07D1, r24
	vSemaphoreCreateBinary(LCDSem);
    5210:	81 e0       	ldi	r24, 0x01	; 1
    5212:	60 e0       	ldi	r22, 0x00	; 0
    5214:	0e 94 a2 1c 	call	0x3944	; 0x3944 <xQueueCreate>
    5218:	90 93 cb 07 	sts	0x07CB, r25
    521c:	80 93 ca 07 	sts	0x07CA, r24
    5220:	80 91 ca 07 	lds	r24, 0x07CA
    5224:	90 91 cb 07 	lds	r25, 0x07CB
    5228:	00 97       	sbiw	r24, 0x00	; 0
    522a:	59 f0       	breq	.+22     	; 0x5242 <main+0x1e8>
    522c:	80 91 ca 07 	lds	r24, 0x07CA
    5230:	90 91 cb 07 	lds	r25, 0x07CB
    5234:	60 e0       	ldi	r22, 0x00	; 0
    5236:	70 e0       	ldi	r23, 0x00	; 0
    5238:	40 e0       	ldi	r20, 0x00	; 0
    523a:	50 e0       	ldi	r21, 0x00	; 0
    523c:	20 e0       	ldi	r18, 0x00	; 0
    523e:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>

	/* Tasks Create*/
	xTaskCreate(Control          ,NULL,100,NULL,0,NULL);
    5242:	83 eb       	ldi	r24, 0xB3	; 179
    5244:	99 e2       	ldi	r25, 0x29	; 41
    5246:	60 e0       	ldi	r22, 0x00	; 0
    5248:	70 e0       	ldi	r23, 0x00	; 0
    524a:	44 e6       	ldi	r20, 0x64	; 100
    524c:	50 e0       	ldi	r21, 0x00	; 0
    524e:	20 e0       	ldi	r18, 0x00	; 0
    5250:	30 e0       	ldi	r19, 0x00	; 0
    5252:	00 e0       	ldi	r16, 0x00	; 0
    5254:	ee 24       	eor	r14, r14
    5256:	ff 24       	eor	r15, r15
    5258:	cc 24       	eor	r12, r12
    525a:	dd 24       	eor	r13, r13
    525c:	aa 24       	eor	r10, r10
    525e:	bb 24       	eor	r11, r11
    5260:	0e 94 42 21 	call	0x4284	; 0x4284 <xTaskGenericCreate>
	xTaskCreate(TimeSecIncreament,NULL,100,NULL,0,NULL);
    5264:	82 e4       	ldi	r24, 0x42	; 66
    5266:	9c e2       	ldi	r25, 0x2C	; 44
    5268:	60 e0       	ldi	r22, 0x00	; 0
    526a:	70 e0       	ldi	r23, 0x00	; 0
    526c:	44 e6       	ldi	r20, 0x64	; 100
    526e:	50 e0       	ldi	r21, 0x00	; 0
    5270:	20 e0       	ldi	r18, 0x00	; 0
    5272:	30 e0       	ldi	r19, 0x00	; 0
    5274:	00 e0       	ldi	r16, 0x00	; 0
    5276:	ee 24       	eor	r14, r14
    5278:	ff 24       	eor	r15, r15
    527a:	cc 24       	eor	r12, r12
    527c:	dd 24       	eor	r13, r13
    527e:	aa 24       	eor	r10, r10
    5280:	bb 24       	eor	r11, r11
    5282:	0e 94 42 21 	call	0x4284	; 0x4284 <xTaskGenericCreate>
	xTaskCreate(LCD_Display      ,NULL,300,NULL,1,NULL);
    5286:	83 eb       	ldi	r24, 0xB3	; 179
    5288:	9c e2       	ldi	r25, 0x2C	; 44
    528a:	60 e0       	ldi	r22, 0x00	; 0
    528c:	70 e0       	ldi	r23, 0x00	; 0
    528e:	4c e2       	ldi	r20, 0x2C	; 44
    5290:	51 e0       	ldi	r21, 0x01	; 1
    5292:	20 e0       	ldi	r18, 0x00	; 0
    5294:	30 e0       	ldi	r19, 0x00	; 0
    5296:	01 e0       	ldi	r16, 0x01	; 1
    5298:	ee 24       	eor	r14, r14
    529a:	ff 24       	eor	r15, r15
    529c:	cc 24       	eor	r12, r12
    529e:	dd 24       	eor	r13, r13
    52a0:	aa 24       	eor	r10, r10
    52a2:	bb 24       	eor	r11, r11
    52a4:	0e 94 42 21 	call	0x4284	; 0x4284 <xTaskGenericCreate>
	xTaskCreate(TimeSet_Buttons  ,NULL,100,NULL,2,NULL);
    52a8:	88 e5       	ldi	r24, 0x58	; 88
    52aa:	9b e2       	ldi	r25, 0x2B	; 43
    52ac:	60 e0       	ldi	r22, 0x00	; 0
    52ae:	70 e0       	ldi	r23, 0x00	; 0
    52b0:	44 e6       	ldi	r20, 0x64	; 100
    52b2:	50 e0       	ldi	r21, 0x00	; 0
    52b4:	20 e0       	ldi	r18, 0x00	; 0
    52b6:	30 e0       	ldi	r19, 0x00	; 0
    52b8:	02 e0       	ldi	r16, 0x02	; 2
    52ba:	ee 24       	eor	r14, r14
    52bc:	ff 24       	eor	r15, r15
    52be:	cc 24       	eor	r12, r12
    52c0:	dd 24       	eor	r13, r13
    52c2:	aa 24       	eor	r10, r10
    52c4:	bb 24       	eor	r11, r11
    52c6:	0e 94 42 21 	call	0x4284	; 0x4284 <xTaskGenericCreate>
	xTaskCreate(Date_TimeSet     ,NULL,120,NULL,3,NULL);
    52ca:	81 eb       	ldi	r24, 0xB1	; 177
    52cc:	9a e2       	ldi	r25, 0x2A	; 42
    52ce:	60 e0       	ldi	r22, 0x00	; 0
    52d0:	70 e0       	ldi	r23, 0x00	; 0
    52d2:	48 e7       	ldi	r20, 0x78	; 120
    52d4:	50 e0       	ldi	r21, 0x00	; 0
    52d6:	20 e0       	ldi	r18, 0x00	; 0
    52d8:	30 e0       	ldi	r19, 0x00	; 0
    52da:	03 e0       	ldi	r16, 0x03	; 3
    52dc:	ee 24       	eor	r14, r14
    52de:	ff 24       	eor	r15, r15
    52e0:	cc 24       	eor	r12, r12
    52e2:	dd 24       	eor	r13, r13
    52e4:	aa 24       	eor	r10, r10
    52e6:	bb 24       	eor	r11, r11
    52e8:	0e 94 42 21 	call	0x4284	; 0x4284 <xTaskGenericCreate>
	xTaskCreate(LM35Read         ,NULL,50 ,NULL,5,NULL);
    52ec:	8c eb       	ldi	r24, 0xBC	; 188
    52ee:	9b e2       	ldi	r25, 0x2B	; 43
    52f0:	60 e0       	ldi	r22, 0x00	; 0
    52f2:	70 e0       	ldi	r23, 0x00	; 0
    52f4:	42 e3       	ldi	r20, 0x32	; 50
    52f6:	50 e0       	ldi	r21, 0x00	; 0
    52f8:	20 e0       	ldi	r18, 0x00	; 0
    52fa:	30 e0       	ldi	r19, 0x00	; 0
    52fc:	05 e0       	ldi	r16, 0x05	; 5
    52fe:	ee 24       	eor	r14, r14
    5300:	ff 24       	eor	r15, r15
    5302:	cc 24       	eor	r12, r12
    5304:	dd 24       	eor	r13, r13
    5306:	aa 24       	eor	r10, r10
    5308:	bb 24       	eor	r11, r11
    530a:	0e 94 42 21 	call	0x4284	; 0x4284 <xTaskGenericCreate>
	xTaskCreate(HeartRateRead    ,NULL,50 ,NULL,6,NULL);
    530e:	8f ef       	ldi	r24, 0xFF	; 255
    5310:	9b e2       	ldi	r25, 0x2B	; 43
    5312:	60 e0       	ldi	r22, 0x00	; 0
    5314:	70 e0       	ldi	r23, 0x00	; 0
    5316:	42 e3       	ldi	r20, 0x32	; 50
    5318:	50 e0       	ldi	r21, 0x00	; 0
    531a:	20 e0       	ldi	r18, 0x00	; 0
    531c:	30 e0       	ldi	r19, 0x00	; 0
    531e:	06 e0       	ldi	r16, 0x06	; 6
    5320:	ee 24       	eor	r14, r14
    5322:	ff 24       	eor	r15, r15
    5324:	cc 24       	eor	r12, r12
    5326:	dd 24       	eor	r13, r13
    5328:	aa 24       	eor	r10, r10
    532a:	bb 24       	eor	r11, r11
    532c:	0e 94 42 21 	call	0x4284	; 0x4284 <xTaskGenericCreate>

	/*Queues Create*/
	LCDDateQueue=xQueueCreate(3,sizeof(u16));
    5330:	83 e0       	ldi	r24, 0x03	; 3
    5332:	62 e0       	ldi	r22, 0x02	; 2
    5334:	0e 94 a2 1c 	call	0x3944	; 0x3944 <xQueueCreate>
    5338:	90 93 c8 07 	sts	0x07C8, r25
    533c:	80 93 c7 07 	sts	0x07C7, r24
	LCDTimeQueue=xQueueCreate(3,sizeof(u8));
    5340:	83 e0       	ldi	r24, 0x03	; 3
    5342:	61 e0       	ldi	r22, 0x01	; 1
    5344:	0e 94 a2 1c 	call	0x3944	; 0x3944 <xQueueCreate>
    5348:	90 93 c6 07 	sts	0x07C6, r25
    534c:	80 93 c5 07 	sts	0x07C5, r24
	LCDFeaturesQueue=xQueueCreate(3,sizeof(u8));
    5350:	83 e0       	ldi	r24, 0x03	; 3
    5352:	61 e0       	ldi	r22, 0x01	; 1
    5354:	0e 94 a2 1c 	call	0x3944	; 0x3944 <xQueueCreate>
    5358:	90 93 d0 07 	sts	0x07D0, r25
    535c:	80 93 cf 07 	sts	0x07CF, r24

	vTaskStartScheduler();
    5360:	0e 94 3b 23 	call	0x4676	; 0x4676 <vTaskStartScheduler>
    5364:	ff cf       	rjmp	.-2      	; 0x5364 <main+0x30a>

00005366 <Control>:
 * Send the current Time and Date to LCD
 * Display Featuers
 * Switch back the current time
 * */
void Control(void*pv)
{
    5366:	df 93       	push	r29
    5368:	cf 93       	push	r28
    536a:	00 d0       	rcall	.+0      	; 0x536c <Control+0x6>
    536c:	0f 92       	push	r0
    536e:	cd b7       	in	r28, 0x3d	; 61
    5370:	de b7       	in	r29, 0x3e	; 62
    5372:	9b 83       	std	Y+3, r25	; 0x03
    5374:	8a 83       	std	Y+2, r24	; 0x02

	static u8 Init_flag=0;
	u8 Loc_u8SemState=0;
    5376:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		Loc_u8SemState=xSemaphoreTake(LCDSem,10);
    5378:	80 91 ca 07 	lds	r24, 0x07CA
    537c:	90 91 cb 07 	lds	r25, 0x07CB
    5380:	60 e0       	ldi	r22, 0x00	; 0
    5382:	70 e0       	ldi	r23, 0x00	; 0
    5384:	4a e0       	ldi	r20, 0x0A	; 10
    5386:	50 e0       	ldi	r21, 0x00	; 0
    5388:	20 e0       	ldi	r18, 0x00	; 0
    538a:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xQueueGenericReceive>
    538e:	89 83       	std	Y+1, r24	; 0x01
		/*Enter In First Time */
		if(Init_flag==0)
    5390:	80 91 ae 07 	lds	r24, 0x07AE
    5394:	88 23       	and	r24, r24
    5396:	09 f0       	breq	.+2      	; 0x539a <Control+0x34>
    5398:	56 c0       	rjmp	.+172    	; 0x5446 <Control+0xe0>
		{
			xQueueSend(LCDDateQueue,&u16Year,0);
    539a:	80 91 c7 07 	lds	r24, 0x07C7
    539e:	90 91 c8 07 	lds	r25, 0x07C8
    53a2:	29 e9       	ldi	r18, 0x99	; 153
    53a4:	30 e0       	ldi	r19, 0x00	; 0
    53a6:	b9 01       	movw	r22, r18
    53a8:	40 e0       	ldi	r20, 0x00	; 0
    53aa:	50 e0       	ldi	r21, 0x00	; 0
    53ac:	20 e0       	ldi	r18, 0x00	; 0
    53ae:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>
			xQueueSend(LCDDateQueue,&u16Month,0);
    53b2:	80 91 c7 07 	lds	r24, 0x07C7
    53b6:	90 91 c8 07 	lds	r25, 0x07C8
    53ba:	2b e9       	ldi	r18, 0x9B	; 155
    53bc:	30 e0       	ldi	r19, 0x00	; 0
    53be:	b9 01       	movw	r22, r18
    53c0:	40 e0       	ldi	r20, 0x00	; 0
    53c2:	50 e0       	ldi	r21, 0x00	; 0
    53c4:	20 e0       	ldi	r18, 0x00	; 0
    53c6:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>
			xQueueSend(LCDDateQueue,&u16Day,0);
    53ca:	80 91 c7 07 	lds	r24, 0x07C7
    53ce:	90 91 c8 07 	lds	r25, 0x07C8
    53d2:	2d e9       	ldi	r18, 0x9D	; 157
    53d4:	30 e0       	ldi	r19, 0x00	; 0
    53d6:	b9 01       	movw	r22, r18
    53d8:	40 e0       	ldi	r20, 0x00	; 0
    53da:	50 e0       	ldi	r21, 0x00	; 0
    53dc:	20 e0       	ldi	r18, 0x00	; 0
    53de:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>
			xQueueSend(LCDTimeQueue,&u8Hour,0);
    53e2:	80 91 c5 07 	lds	r24, 0x07C5
    53e6:	90 91 c6 07 	lds	r25, 0x07C6
    53ea:	2f e9       	ldi	r18, 0x9F	; 159
    53ec:	30 e0       	ldi	r19, 0x00	; 0
    53ee:	b9 01       	movw	r22, r18
    53f0:	40 e0       	ldi	r20, 0x00	; 0
    53f2:	50 e0       	ldi	r21, 0x00	; 0
    53f4:	20 e0       	ldi	r18, 0x00	; 0
    53f6:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>
			xQueueSend(LCDTimeQueue,&u8Minutes,0);
    53fa:	80 91 c5 07 	lds	r24, 0x07C5
    53fe:	90 91 c6 07 	lds	r25, 0x07C6
    5402:	20 ea       	ldi	r18, 0xA0	; 160
    5404:	30 e0       	ldi	r19, 0x00	; 0
    5406:	b9 01       	movw	r22, r18
    5408:	40 e0       	ldi	r20, 0x00	; 0
    540a:	50 e0       	ldi	r21, 0x00	; 0
    540c:	20 e0       	ldi	r18, 0x00	; 0
    540e:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>
			xQueueSend(LCDTimeQueue,&u8Second,0);
    5412:	80 91 c5 07 	lds	r24, 0x07C5
    5416:	90 91 c6 07 	lds	r25, 0x07C6
    541a:	21 ea       	ldi	r18, 0xA1	; 161
    541c:	30 e0       	ldi	r19, 0x00	; 0
    541e:	b9 01       	movw	r22, r18
    5420:	40 e0       	ldi	r20, 0x00	; 0
    5422:	50 e0       	ldi	r21, 0x00	; 0
    5424:	20 e0       	ldi	r18, 0x00	; 0
    5426:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>
			xSemaphoreGive(LCDSem);
    542a:	80 91 ca 07 	lds	r24, 0x07CA
    542e:	90 91 cb 07 	lds	r25, 0x07CB
    5432:	60 e0       	ldi	r22, 0x00	; 0
    5434:	70 e0       	ldi	r23, 0x00	; 0
    5436:	40 e0       	ldi	r20, 0x00	; 0
    5438:	50 e0       	ldi	r21, 0x00	; 0
    543a:	20 e0       	ldi	r18, 0x00	; 0
    543c:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>
			Init_flag=1;
    5440:	81 e0       	ldi	r24, 0x01	; 1
    5442:	80 93 ae 07 	sts	0x07AE, r24
		{
			/*Do Nothing*/
		}


		if(Loc_u8SemState == pdPASS)
    5446:	89 81       	ldd	r24, Y+1	; 0x01
    5448:	81 30       	cpi	r24, 0x01	; 1
    544a:	09 f0       	breq	.+2      	; 0x544e <Control+0xe8>
    544c:	85 c0       	rjmp	.+266    	; 0x5558 <Control+0x1f2>
		{
			if((Features_DispFlag == 0)&& (Update_DispFlag==1))
    544e:	80 91 ac 07 	lds	r24, 0x07AC
    5452:	88 23       	and	r24, r24
    5454:	09 f0       	breq	.+2      	; 0x5458 <Control+0xf2>
    5456:	59 c0       	rjmp	.+178    	; 0x550a <Control+0x1a4>
    5458:	80 91 ad 07 	lds	r24, 0x07AD
    545c:	81 30       	cpi	r24, 0x01	; 1
    545e:	09 f0       	breq	.+2      	; 0x5462 <Control+0xfc>
    5460:	54 c0       	rjmp	.+168    	; 0x550a <Control+0x1a4>
			{
				/*Send Current Date to LCDDateQueue*/

				xQueueSend(LCDDateQueue,&u16Year,3);
    5462:	80 91 c7 07 	lds	r24, 0x07C7
    5466:	90 91 c8 07 	lds	r25, 0x07C8
    546a:	29 e9       	ldi	r18, 0x99	; 153
    546c:	30 e0       	ldi	r19, 0x00	; 0
    546e:	b9 01       	movw	r22, r18
    5470:	43 e0       	ldi	r20, 0x03	; 3
    5472:	50 e0       	ldi	r21, 0x00	; 0
    5474:	20 e0       	ldi	r18, 0x00	; 0
    5476:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>
				xQueueSend(LCDDateQueue,&u16Month,3);
    547a:	80 91 c7 07 	lds	r24, 0x07C7
    547e:	90 91 c8 07 	lds	r25, 0x07C8
    5482:	2b e9       	ldi	r18, 0x9B	; 155
    5484:	30 e0       	ldi	r19, 0x00	; 0
    5486:	b9 01       	movw	r22, r18
    5488:	43 e0       	ldi	r20, 0x03	; 3
    548a:	50 e0       	ldi	r21, 0x00	; 0
    548c:	20 e0       	ldi	r18, 0x00	; 0
    548e:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>
				xQueueSend(LCDDateQueue,&u16Day,3);
    5492:	80 91 c7 07 	lds	r24, 0x07C7
    5496:	90 91 c8 07 	lds	r25, 0x07C8
    549a:	2d e9       	ldi	r18, 0x9D	; 157
    549c:	30 e0       	ldi	r19, 0x00	; 0
    549e:	b9 01       	movw	r22, r18
    54a0:	43 e0       	ldi	r20, 0x03	; 3
    54a2:	50 e0       	ldi	r21, 0x00	; 0
    54a4:	20 e0       	ldi	r18, 0x00	; 0
    54a6:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>

				/*Send Current Time to LCDTimeQueue*/
				xQueueSend(LCDTimeQueue,&u8Hour,3);
    54aa:	80 91 c5 07 	lds	r24, 0x07C5
    54ae:	90 91 c6 07 	lds	r25, 0x07C6
    54b2:	2f e9       	ldi	r18, 0x9F	; 159
    54b4:	30 e0       	ldi	r19, 0x00	; 0
    54b6:	b9 01       	movw	r22, r18
    54b8:	43 e0       	ldi	r20, 0x03	; 3
    54ba:	50 e0       	ldi	r21, 0x00	; 0
    54bc:	20 e0       	ldi	r18, 0x00	; 0
    54be:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>
				xQueueSend(LCDTimeQueue,&u8Minutes,3);
    54c2:	80 91 c5 07 	lds	r24, 0x07C5
    54c6:	90 91 c6 07 	lds	r25, 0x07C6
    54ca:	20 ea       	ldi	r18, 0xA0	; 160
    54cc:	30 e0       	ldi	r19, 0x00	; 0
    54ce:	b9 01       	movw	r22, r18
    54d0:	43 e0       	ldi	r20, 0x03	; 3
    54d2:	50 e0       	ldi	r21, 0x00	; 0
    54d4:	20 e0       	ldi	r18, 0x00	; 0
    54d6:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>
				xQueueSend(LCDTimeQueue,&u8Second,3);
    54da:	80 91 c5 07 	lds	r24, 0x07C5
    54de:	90 91 c6 07 	lds	r25, 0x07C6
    54e2:	21 ea       	ldi	r18, 0xA1	; 161
    54e4:	30 e0       	ldi	r19, 0x00	; 0
    54e6:	b9 01       	movw	r22, r18
    54e8:	43 e0       	ldi	r20, 0x03	; 3
    54ea:	50 e0       	ldi	r21, 0x00	; 0
    54ec:	20 e0       	ldi	r18, 0x00	; 0
    54ee:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>
				/* Give Semaphore*/
				xSemaphoreGive(LCDSem);
    54f2:	80 91 ca 07 	lds	r24, 0x07CA
    54f6:	90 91 cb 07 	lds	r25, 0x07CB
    54fa:	60 e0       	ldi	r22, 0x00	; 0
    54fc:	70 e0       	ldi	r23, 0x00	; 0
    54fe:	40 e0       	ldi	r20, 0x00	; 0
    5500:	50 e0       	ldi	r21, 0x00	; 0
    5502:	20 e0       	ldi	r18, 0x00	; 0
    5504:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>
    5508:	27 c0       	rjmp	.+78     	; 0x5558 <Control+0x1f2>

			}
			/*When Feature Display Button is Pressed*/
			else if(Features_DispFlag==1)
    550a:	80 91 ac 07 	lds	r24, 0x07AC
    550e:	81 30       	cpi	r24, 0x01	; 1
    5510:	19 f5       	brne	.+70     	; 0x5558 <Control+0x1f2>
			{
				/*Send Temperature and HeartRate to LCDFeauteresQueue*/
				xQueueSend(LCDFeaturesQueue,&u8Temperatur,3);
    5512:	80 91 cf 07 	lds	r24, 0x07CF
    5516:	90 91 d0 07 	lds	r25, 0x07D0
    551a:	2c ec       	ldi	r18, 0xCC	; 204
    551c:	37 e0       	ldi	r19, 0x07	; 7
    551e:	b9 01       	movw	r22, r18
    5520:	43 e0       	ldi	r20, 0x03	; 3
    5522:	50 e0       	ldi	r21, 0x00	; 0
    5524:	20 e0       	ldi	r18, 0x00	; 0
    5526:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>
				xQueueSend(LCDFeaturesQueue,&u8HeartRate,3);
    552a:	80 91 cf 07 	lds	r24, 0x07CF
    552e:	90 91 d0 07 	lds	r25, 0x07D0
    5532:	29 ec       	ldi	r18, 0xC9	; 201
    5534:	37 e0       	ldi	r19, 0x07	; 7
    5536:	b9 01       	movw	r22, r18
    5538:	43 e0       	ldi	r20, 0x03	; 3
    553a:	50 e0       	ldi	r21, 0x00	; 0
    553c:	20 e0       	ldi	r18, 0x00	; 0
    553e:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>
				/*Give Semaphore*/
				xSemaphoreGive(LCDSem);
    5542:	80 91 ca 07 	lds	r24, 0x07CA
    5546:	90 91 cb 07 	lds	r25, 0x07CB
    554a:	60 e0       	ldi	r22, 0x00	; 0
    554c:	70 e0       	ldi	r23, 0x00	; 0
    554e:	40 e0       	ldi	r20, 0x00	; 0
    5550:	50 e0       	ldi	r21, 0x00	; 0
    5552:	20 e0       	ldi	r18, 0x00	; 0
    5554:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>
			else
			{
				/*Do Nothing*/
			}
		}
		vTaskDelay(80);
    5558:	80 e5       	ldi	r24, 0x50	; 80
    555a:	90 e0       	ldi	r25, 0x00	; 0
    555c:	0e 94 06 23 	call	0x460c	; 0x460c <vTaskDelay>
    5560:	0b cf       	rjmp	.-490    	; 0x5378 <Control+0x12>

00005562 <Date_TimeSet>:
	}
}

void Date_TimeSet(void*pv)
{
    5562:	df 93       	push	r29
    5564:	cf 93       	push	r28
    5566:	00 d0       	rcall	.+0      	; 0x5568 <Date_TimeSet+0x6>
    5568:	00 d0       	rcall	.+0      	; 0x556a <Date_TimeSet+0x8>
    556a:	cd b7       	in	r28, 0x3d	; 61
    556c:	de b7       	in	r29, 0x3e	; 62
    556e:	9a 83       	std	Y+2, r25	; 0x02
    5570:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		/*When SetTimeButton is Pressed*/
		if(Set_TimeFlag == 1)
    5572:	80 91 be 07 	lds	r24, 0x07BE
    5576:	81 30       	cpi	r24, 0x01	; 1
    5578:	09 f0       	breq	.+2      	; 0x557c <Date_TimeSet+0x1a>
    557a:	95 c0       	rjmp	.+298    	; 0x56a6 <Date_TimeSet+0x144>
		{
			/*When IncreamentButton is Pressed*/
			if(IncreamentFlag == 1)
    557c:	80 91 bf 07 	lds	r24, 0x07BF
    5580:	81 30       	cpi	r24, 0x01	; 1
    5582:	09 f0       	breq	.+2      	; 0x5586 <Date_TimeSet+0x24>
    5584:	90 c0       	rjmp	.+288    	; 0x56a6 <Date_TimeSet+0x144>
			{
				/*Check Confirm Button*/
				switch(counter)
    5586:	80 91 c0 07 	lds	r24, 0x07C0
    558a:	28 2f       	mov	r18, r24
    558c:	30 e0       	ldi	r19, 0x00	; 0
    558e:	3c 83       	std	Y+4, r19	; 0x04
    5590:	2b 83       	std	Y+3, r18	; 0x03
    5592:	8b 81       	ldd	r24, Y+3	; 0x03
    5594:	9c 81       	ldd	r25, Y+4	; 0x04
    5596:	82 30       	cpi	r24, 0x02	; 2
    5598:	91 05       	cpc	r25, r1
    559a:	09 f4       	brne	.+2      	; 0x559e <Date_TimeSet+0x3c>
    559c:	44 c0       	rjmp	.+136    	; 0x5626 <Date_TimeSet+0xc4>
    559e:	2b 81       	ldd	r18, Y+3	; 0x03
    55a0:	3c 81       	ldd	r19, Y+4	; 0x04
    55a2:	23 30       	cpi	r18, 0x03	; 3
    55a4:	31 05       	cpc	r19, r1
    55a6:	54 f4       	brge	.+20     	; 0x55bc <Date_TimeSet+0x5a>
    55a8:	8b 81       	ldd	r24, Y+3	; 0x03
    55aa:	9c 81       	ldd	r25, Y+4	; 0x04
    55ac:	00 97       	sbiw	r24, 0x00	; 0
    55ae:	c9 f0       	breq	.+50     	; 0x55e2 <Date_TimeSet+0x80>
    55b0:	2b 81       	ldd	r18, Y+3	; 0x03
    55b2:	3c 81       	ldd	r19, Y+4	; 0x04
    55b4:	21 30       	cpi	r18, 0x01	; 1
    55b6:	31 05       	cpc	r19, r1
    55b8:	f1 f0       	breq	.+60     	; 0x55f6 <Date_TimeSet+0x94>
    55ba:	73 c0       	rjmp	.+230    	; 0x56a2 <Date_TimeSet+0x140>
    55bc:	8b 81       	ldd	r24, Y+3	; 0x03
    55be:	9c 81       	ldd	r25, Y+4	; 0x04
    55c0:	84 30       	cpi	r24, 0x04	; 4
    55c2:	91 05       	cpc	r25, r1
    55c4:	09 f4       	brne	.+2      	; 0x55c8 <Date_TimeSet+0x66>
    55c6:	52 c0       	rjmp	.+164    	; 0x566c <Date_TimeSet+0x10a>
    55c8:	2b 81       	ldd	r18, Y+3	; 0x03
    55ca:	3c 81       	ldd	r19, Y+4	; 0x04
    55cc:	24 30       	cpi	r18, 0x04	; 4
    55ce:	31 05       	cpc	r19, r1
    55d0:	0c f4       	brge	.+2      	; 0x55d4 <Date_TimeSet+0x72>
    55d2:	40 c0       	rjmp	.+128    	; 0x5654 <Date_TimeSet+0xf2>
    55d4:	8b 81       	ldd	r24, Y+3	; 0x03
    55d6:	9c 81       	ldd	r25, Y+4	; 0x04
    55d8:	85 30       	cpi	r24, 0x05	; 5
    55da:	91 05       	cpc	r25, r1
    55dc:	09 f4       	brne	.+2      	; 0x55e0 <Date_TimeSet+0x7e>
    55de:	52 c0       	rjmp	.+164    	; 0x5684 <Date_TimeSet+0x122>
    55e0:	60 c0       	rjmp	.+192    	; 0x56a2 <Date_TimeSet+0x140>
				{
				case 0:
					u16Year++;
    55e2:	80 91 99 00 	lds	r24, 0x0099
    55e6:	90 91 9a 00 	lds	r25, 0x009A
    55ea:	01 96       	adiw	r24, 0x01	; 1
    55ec:	90 93 9a 00 	sts	0x009A, r25
    55f0:	80 93 99 00 	sts	0x0099, r24
    55f4:	56 c0       	rjmp	.+172    	; 0x56a2 <Date_TimeSet+0x140>
					break;
				case 1:
					u16Month++;
    55f6:	80 91 9b 00 	lds	r24, 0x009B
    55fa:	90 91 9c 00 	lds	r25, 0x009C
    55fe:	01 96       	adiw	r24, 0x01	; 1
    5600:	90 93 9c 00 	sts	0x009C, r25
    5604:	80 93 9b 00 	sts	0x009B, r24
					if(u16Month > 12)
    5608:	80 91 9b 00 	lds	r24, 0x009B
    560c:	90 91 9c 00 	lds	r25, 0x009C
    5610:	8d 30       	cpi	r24, 0x0D	; 13
    5612:	91 05       	cpc	r25, r1
    5614:	08 f4       	brcc	.+2      	; 0x5618 <Date_TimeSet+0xb6>
    5616:	45 c0       	rjmp	.+138    	; 0x56a2 <Date_TimeSet+0x140>
					{
						u16Month = 1;
    5618:	81 e0       	ldi	r24, 0x01	; 1
    561a:	90 e0       	ldi	r25, 0x00	; 0
    561c:	90 93 9c 00 	sts	0x009C, r25
    5620:	80 93 9b 00 	sts	0x009B, r24
    5624:	3e c0       	rjmp	.+124    	; 0x56a2 <Date_TimeSet+0x140>
					}
					break;


				case 2:
					u16Day++;
    5626:	80 91 9d 00 	lds	r24, 0x009D
    562a:	90 91 9e 00 	lds	r25, 0x009E
    562e:	01 96       	adiw	r24, 0x01	; 1
    5630:	90 93 9e 00 	sts	0x009E, r25
    5634:	80 93 9d 00 	sts	0x009D, r24

					if(u16Day > 30)
    5638:	80 91 9d 00 	lds	r24, 0x009D
    563c:	90 91 9e 00 	lds	r25, 0x009E
    5640:	8f 31       	cpi	r24, 0x1F	; 31
    5642:	91 05       	cpc	r25, r1
    5644:	70 f1       	brcs	.+92     	; 0x56a2 <Date_TimeSet+0x140>
					{
						u16Day = 1;
    5646:	81 e0       	ldi	r24, 0x01	; 1
    5648:	90 e0       	ldi	r25, 0x00	; 0
    564a:	90 93 9e 00 	sts	0x009E, r25
    564e:	80 93 9d 00 	sts	0x009D, r24
    5652:	27 c0       	rjmp	.+78     	; 0x56a2 <Date_TimeSet+0x140>
					}

					break;
				case 3:
					u8Hour++;
    5654:	80 91 9f 00 	lds	r24, 0x009F
    5658:	8f 5f       	subi	r24, 0xFF	; 255
    565a:	80 93 9f 00 	sts	0x009F, r24
					if(u8Hour >23)
    565e:	80 91 9f 00 	lds	r24, 0x009F
    5662:	88 31       	cpi	r24, 0x18	; 24
    5664:	f0 f0       	brcs	.+60     	; 0x56a2 <Date_TimeSet+0x140>
					{
						u8Hour = 0;
    5666:	10 92 9f 00 	sts	0x009F, r1
    566a:	1b c0       	rjmp	.+54     	; 0x56a2 <Date_TimeSet+0x140>
					}

					break;
				case 4:
					u8Minutes++;
    566c:	80 91 a0 00 	lds	r24, 0x00A0
    5670:	8f 5f       	subi	r24, 0xFF	; 255
    5672:	80 93 a0 00 	sts	0x00A0, r24

					if(u8Minutes == 61)
    5676:	80 91 a0 00 	lds	r24, 0x00A0
    567a:	8d 33       	cpi	r24, 0x3D	; 61
    567c:	91 f4       	brne	.+36     	; 0x56a2 <Date_TimeSet+0x140>
					{
						u8Minutes = 0;
    567e:	10 92 a0 00 	sts	0x00A0, r1
    5682:	0f c0       	rjmp	.+30     	; 0x56a2 <Date_TimeSet+0x140>
					}
					break;


				case 5:
					u8Second++;
    5684:	80 91 a1 00 	lds	r24, 0x00A1
    5688:	8f 5f       	subi	r24, 0xFF	; 255
    568a:	80 93 a1 00 	sts	0x00A1, r24

					if(u8Second == 61)
    568e:	80 91 a1 00 	lds	r24, 0x00A1
    5692:	8d 33       	cpi	r24, 0x3D	; 61
    5694:	11 f4       	brne	.+4      	; 0x569a <Date_TimeSet+0x138>
					{
						u8Second = 0;
    5696:	10 92 a1 00 	sts	0x00A1, r1
					}
					/*Clear SetTimeFlag*/
					Set_TimeFlag = 0;
    569a:	10 92 be 07 	sts	0x07BE, r1
					/*Clear Counter*/
					counter = 0;
    569e:	10 92 c0 07 	sts	0x07C0, r1

				default: break;

				}
				/*Clear IncreamentFlag*/
				IncreamentFlag = 0;
    56a2:	10 92 bf 07 	sts	0x07BF, r1
			}
		}

		vTaskDelay(100);
    56a6:	84 e6       	ldi	r24, 0x64	; 100
    56a8:	90 e0       	ldi	r25, 0x00	; 0
    56aa:	0e 94 06 23 	call	0x460c	; 0x460c <vTaskDelay>
    56ae:	61 cf       	rjmp	.-318    	; 0x5572 <Date_TimeSet+0x10>

000056b0 <TimeSet_Buttons>:
	}
}
void TimeSet_Buttons(void*pv)
{
    56b0:	df 93       	push	r29
    56b2:	cf 93       	push	r28
    56b4:	00 d0       	rcall	.+0      	; 0x56b6 <TimeSet_Buttons+0x6>
    56b6:	00 d0       	rcall	.+0      	; 0x56b8 <TimeSet_Buttons+0x8>
    56b8:	00 d0       	rcall	.+0      	; 0x56ba <TimeSet_Buttons+0xa>
    56ba:	cd b7       	in	r28, 0x3d	; 61
    56bc:	de b7       	in	r29, 0x3e	; 62
    56be:	9e 83       	std	Y+6, r25	; 0x06
    56c0:	8d 83       	std	Y+5, r24	; 0x05
	u8 Loc_u8TimeSetButtonVal = BUTTON_NOT_PRESSED;
    56c2:	81 e0       	ldi	r24, 0x01	; 1
    56c4:	89 83       	std	Y+1, r24	; 0x01
	u8  Loc_u8IncreamentButtonVal = BUTTON_NOT_PRESSED;
    56c6:	81 e0       	ldi	r24, 0x01	; 1
    56c8:	8a 83       	std	Y+2, r24	; 0x02
	u8 Loc_u8ConfirmButtonVal = BUTTON_NOT_PRESSED;
    56ca:	81 e0       	ldi	r24, 0x01	; 1
    56cc:	8b 83       	std	Y+3, r24	; 0x03
	u8 Loc_u8FeaturesButtonVal = BUTTON_NOT_PRESSED;
    56ce:	81 e0       	ldi	r24, 0x01	; 1
    56d0:	8c 83       	std	Y+4, r24	; 0x04

	while(1)
	{
		MDIO_Error_State_GetPinValue(TIME_SET_BUTTON_PIN,TIME_SET_BUTTON_PORT,&Loc_u8TimeSetButtonVal);
    56d2:	82 e0       	ldi	r24, 0x02	; 2
    56d4:	63 e0       	ldi	r22, 0x03	; 3
    56d6:	9e 01       	movw	r18, r28
    56d8:	2f 5f       	subi	r18, 0xFF	; 255
    56da:	3f 4f       	sbci	r19, 0xFF	; 255
    56dc:	a9 01       	movw	r20, r18
    56de:	0e 94 61 09 	call	0x12c2	; 0x12c2 <MDIO_Error_State_GetPinValue>
		/*Check TimeSetButton*/
		if(Loc_u8TimeSetButtonVal == BUTTON_PRESSED)
    56e2:	89 81       	ldd	r24, Y+1	; 0x01
    56e4:	88 23       	and	r24, r24
    56e6:	41 f4       	brne	.+16     	; 0x56f8 <TimeSet_Buttons+0x48>
		{
			Set_TimeFlag = 1;
    56e8:	81 e0       	ldi	r24, 0x01	; 1
    56ea:	80 93 be 07 	sts	0x07BE, r24
			MDIO_Error_State_SetPinValue(PIN0,MDIO_PORTB,PIN_HIGH);
    56ee:	80 e0       	ldi	r24, 0x00	; 0
    56f0:	61 e0       	ldi	r22, 0x01	; 1
    56f2:	41 e0       	ldi	r20, 0x01	; 1
    56f4:	0e 94 16 08 	call	0x102c	; 0x102c <MDIO_Error_State_SetPinValue>
		}
		else
		{
			/*Do Nothing*/
		}
		MDIO_Error_State_GetPinValue(INCREAMENT_BUTTON_PIN,INCREAMENT_BUTTON_PORT,&Loc_u8IncreamentButtonVal);
    56f8:	9e 01       	movw	r18, r28
    56fa:	2e 5f       	subi	r18, 0xFE	; 254
    56fc:	3f 4f       	sbci	r19, 0xFF	; 255
    56fe:	83 e0       	ldi	r24, 0x03	; 3
    5700:	63 e0       	ldi	r22, 0x03	; 3
    5702:	a9 01       	movw	r20, r18
    5704:	0e 94 61 09 	call	0x12c2	; 0x12c2 <MDIO_Error_State_GetPinValue>
		if(Loc_u8IncreamentButtonVal == BUTTON_PRESSED)
    5708:	8a 81       	ldd	r24, Y+2	; 0x02
    570a:	88 23       	and	r24, r24
    570c:	19 f4       	brne	.+6      	; 0x5714 <TimeSet_Buttons+0x64>
		{
			IncreamentFlag = 1;
    570e:	81 e0       	ldi	r24, 0x01	; 1
    5710:	80 93 bf 07 	sts	0x07BF, r24
		}
		else
		{
			/*Do Nothing*/
		}
		MDIO_Error_State_GetPinValue(CONFIRM_BUTTON_PIN,CONFIRM_BUTTON_PORT,&Loc_u8ConfirmButtonVal);
    5714:	9e 01       	movw	r18, r28
    5716:	2d 5f       	subi	r18, 0xFD	; 253
    5718:	3f 4f       	sbci	r19, 0xFF	; 255
    571a:	84 e0       	ldi	r24, 0x04	; 4
    571c:	63 e0       	ldi	r22, 0x03	; 3
    571e:	a9 01       	movw	r20, r18
    5720:	0e 94 61 09 	call	0x12c2	; 0x12c2 <MDIO_Error_State_GetPinValue>
		if(Loc_u8ConfirmButtonVal == BUTTON_PRESSED)
    5724:	8b 81       	ldd	r24, Y+3	; 0x03
    5726:	88 23       	and	r24, r24
    5728:	49 f4       	brne	.+18     	; 0x573c <TimeSet_Buttons+0x8c>
		{
			Inreament_count = 0;
    572a:	10 92 ce 07 	sts	0x07CE, r1
    572e:	10 92 cd 07 	sts	0x07CD, r1
			counter++;
    5732:	80 91 c0 07 	lds	r24, 0x07C0
    5736:	8f 5f       	subi	r24, 0xFF	; 255
    5738:	80 93 c0 07 	sts	0x07C0, r24
		else
		{
			/*Do Nothing*/
		}

		MDIO_Error_State_GetPinValue(FEAUTERS_BUTTON_PIN,FEAUTERS_BUTTON_PORT,&Loc_u8FeaturesButtonVal);
    573c:	9e 01       	movw	r18, r28
    573e:	2c 5f       	subi	r18, 0xFC	; 252
    5740:	3f 4f       	sbci	r19, 0xFF	; 255
    5742:	85 e0       	ldi	r24, 0x05	; 5
    5744:	63 e0       	ldi	r22, 0x03	; 3
    5746:	a9 01       	movw	r20, r18
    5748:	0e 94 61 09 	call	0x12c2	; 0x12c2 <MDIO_Error_State_GetPinValue>
		if(Loc_u8FeaturesButtonVal == BUTTON_PRESSED)
    574c:	8c 81       	ldd	r24, Y+4	; 0x04
    574e:	88 23       	and	r24, r24
    5750:	71 f4       	brne	.+28     	; 0x576e <TimeSet_Buttons+0xbe>
		{
			if(Features_DispFlag==0)
    5752:	80 91 ac 07 	lds	r24, 0x07AC
    5756:	88 23       	and	r24, r24
    5758:	21 f4       	brne	.+8      	; 0x5762 <TimeSet_Buttons+0xb2>
			{
				Features_DispFlag=1;
    575a:	81 e0       	ldi	r24, 0x01	; 1
    575c:	80 93 ac 07 	sts	0x07AC, r24
    5760:	06 c0       	rjmp	.+12     	; 0x576e <TimeSet_Buttons+0xbe>
			}
			else if(Features_DispFlag==1)
    5762:	80 91 ac 07 	lds	r24, 0x07AC
    5766:	81 30       	cpi	r24, 0x01	; 1
    5768:	11 f4       	brne	.+4      	; 0x576e <TimeSet_Buttons+0xbe>
			{
				Features_DispFlag=0;
    576a:	10 92 ac 07 	sts	0x07AC, r1
			}
		}
		vTaskDelay(100);
    576e:	84 e6       	ldi	r24, 0x64	; 100
    5770:	90 e0       	ldi	r25, 0x00	; 0
    5772:	0e 94 06 23 	call	0x460c	; 0x460c <vTaskDelay>
    5776:	ad cf       	rjmp	.-166    	; 0x56d2 <TimeSet_Buttons+0x22>

00005778 <LM35Read>:
	}
}

void LM35Read(void*pv)
{
    5778:	df 93       	push	r29
    577a:	cf 93       	push	r28
    577c:	00 d0       	rcall	.+0      	; 0x577e <LM35Read+0x6>
    577e:	0f 92       	push	r0
    5780:	cd b7       	in	r28, 0x3d	; 61
    5782:	de b7       	in	r29, 0x3e	; 62
    5784:	9b 83       	std	Y+3, r25	; 0x03
    5786:	8a 83       	std	Y+2, r24	; 0x02
	u8 LOC_u8SemState=0;
    5788:	19 82       	std	Y+1, r1	; 0x01
	static u16 Loc_u16ADC_DigitalVal;

	while(1)
	{
		LOC_u8SemState = xSemaphoreTake(ADCSem,5);
    578a:	80 91 d1 07 	lds	r24, 0x07D1
    578e:	90 91 d2 07 	lds	r25, 0x07D2
    5792:	60 e0       	ldi	r22, 0x00	; 0
    5794:	70 e0       	ldi	r23, 0x00	; 0
    5796:	45 e0       	ldi	r20, 0x05	; 5
    5798:	50 e0       	ldi	r21, 0x00	; 0
    579a:	20 e0       	ldi	r18, 0x00	; 0
    579c:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xQueueGenericReceive>
    57a0:	89 83       	std	Y+1, r24	; 0x01
		if(LOC_u8SemState == pdPASS)
    57a2:	89 81       	ldd	r24, Y+1	; 0x01
    57a4:	81 30       	cpi	r24, 0x01	; 1
    57a6:	31 f5       	brne	.+76     	; 0x57f4 <LM35Read+0x7c>
		{
			Loc_u16ADC_DigitalVal = MADC_u16ADCRead();
    57a8:	0e 94 3f 0b 	call	0x167e	; 0x167e <MADC_u16ADCRead>
    57ac:	90 93 b0 07 	sts	0x07B0, r25
    57b0:	80 93 af 07 	sts	0x07AF, r24
			u8Temperatur=(u8)(((Loc_u16ADC_DigitalVal*5000UL)/1024)/10);
    57b4:	80 91 af 07 	lds	r24, 0x07AF
    57b8:	90 91 b0 07 	lds	r25, 0x07B0
    57bc:	cc 01       	movw	r24, r24
    57be:	a0 e0       	ldi	r26, 0x00	; 0
    57c0:	b0 e0       	ldi	r27, 0x00	; 0
    57c2:	28 e8       	ldi	r18, 0x88	; 136
    57c4:	33 e1       	ldi	r19, 0x13	; 19
    57c6:	40 e0       	ldi	r20, 0x00	; 0
    57c8:	50 e0       	ldi	r21, 0x00	; 0
    57ca:	bc 01       	movw	r22, r24
    57cc:	cd 01       	movw	r24, r26
    57ce:	0e 94 4b 2e 	call	0x5c96	; 0x5c96 <__mulsi3>
    57d2:	dc 01       	movw	r26, r24
    57d4:	cb 01       	movw	r24, r22
    57d6:	20 e0       	ldi	r18, 0x00	; 0
    57d8:	38 e2       	ldi	r19, 0x28	; 40
    57da:	40 e0       	ldi	r20, 0x00	; 0
    57dc:	50 e0       	ldi	r21, 0x00	; 0
    57de:	bc 01       	movw	r22, r24
    57e0:	cd 01       	movw	r24, r26
    57e2:	0e 94 8a 2e 	call	0x5d14	; 0x5d14 <__udivmodsi4>
    57e6:	da 01       	movw	r26, r20
    57e8:	c9 01       	movw	r24, r18
    57ea:	80 93 cc 07 	sts	0x07CC, r24
			MADC_u16ADC_StartConversion_With_Interrupt(CHANNEL_1);
    57ee:	81 e0       	ldi	r24, 0x01	; 1
    57f0:	0e 94 1c 0b 	call	0x1638	; 0x1638 <MADC_u16ADC_StartConversion_With_Interrupt>
		}
		else
		{
			//Do Nothing
		}
		vTaskDelay(10);
    57f4:	8a e0       	ldi	r24, 0x0A	; 10
    57f6:	90 e0       	ldi	r25, 0x00	; 0
    57f8:	0e 94 06 23 	call	0x460c	; 0x460c <vTaskDelay>
    57fc:	c6 cf       	rjmp	.-116    	; 0x578a <LM35Read+0x12>

000057fe <HeartRateRead>:
	}
}
void HeartRateRead(void*pv)
{
    57fe:	df 93       	push	r29
    5800:	cf 93       	push	r28
    5802:	00 d0       	rcall	.+0      	; 0x5804 <HeartRateRead+0x6>
    5804:	0f 92       	push	r0
    5806:	cd b7       	in	r28, 0x3d	; 61
    5808:	de b7       	in	r29, 0x3e	; 62
    580a:	9b 83       	std	Y+3, r25	; 0x03
    580c:	8a 83       	std	Y+2, r24	; 0x02

	u8 LOC_u8SemState=0;
    580e:	19 82       	std	Y+1, r1	; 0x01
	static u16 Loc_u16ADC_DigitalVal;
	while(1)
	{
		LOC_u8SemState = xSemaphoreTake(ADCSem,5);
    5810:	80 91 d1 07 	lds	r24, 0x07D1
    5814:	90 91 d2 07 	lds	r25, 0x07D2
    5818:	60 e0       	ldi	r22, 0x00	; 0
    581a:	70 e0       	ldi	r23, 0x00	; 0
    581c:	45 e0       	ldi	r20, 0x05	; 5
    581e:	50 e0       	ldi	r21, 0x00	; 0
    5820:	20 e0       	ldi	r18, 0x00	; 0
    5822:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xQueueGenericReceive>
    5826:	89 83       	std	Y+1, r24	; 0x01
		if(LOC_u8SemState == pdPASS)
    5828:	89 81       	ldd	r24, Y+1	; 0x01
    582a:	81 30       	cpi	r24, 0x01	; 1
    582c:	31 f5       	brne	.+76     	; 0x587a <HeartRateRead+0x7c>
		{
			Loc_u16ADC_DigitalVal = MADC_u16ADCRead();
    582e:	0e 94 3f 0b 	call	0x167e	; 0x167e <MADC_u16ADCRead>
    5832:	90 93 b2 07 	sts	0x07B2, r25
    5836:	80 93 b1 07 	sts	0x07B1, r24
			u8HeartRate=(u8)(((Loc_u16ADC_DigitalVal*5000UL)/1024)/3);
    583a:	80 91 b1 07 	lds	r24, 0x07B1
    583e:	90 91 b2 07 	lds	r25, 0x07B2
    5842:	cc 01       	movw	r24, r24
    5844:	a0 e0       	ldi	r26, 0x00	; 0
    5846:	b0 e0       	ldi	r27, 0x00	; 0
    5848:	28 e8       	ldi	r18, 0x88	; 136
    584a:	33 e1       	ldi	r19, 0x13	; 19
    584c:	40 e0       	ldi	r20, 0x00	; 0
    584e:	50 e0       	ldi	r21, 0x00	; 0
    5850:	bc 01       	movw	r22, r24
    5852:	cd 01       	movw	r24, r26
    5854:	0e 94 4b 2e 	call	0x5c96	; 0x5c96 <__mulsi3>
    5858:	dc 01       	movw	r26, r24
    585a:	cb 01       	movw	r24, r22
    585c:	20 e0       	ldi	r18, 0x00	; 0
    585e:	3c e0       	ldi	r19, 0x0C	; 12
    5860:	40 e0       	ldi	r20, 0x00	; 0
    5862:	50 e0       	ldi	r21, 0x00	; 0
    5864:	bc 01       	movw	r22, r24
    5866:	cd 01       	movw	r24, r26
    5868:	0e 94 8a 2e 	call	0x5d14	; 0x5d14 <__udivmodsi4>
    586c:	da 01       	movw	r26, r20
    586e:	c9 01       	movw	r24, r18
    5870:	80 93 c9 07 	sts	0x07C9, r24
			MADC_u16ADC_StartConversion_With_Interrupt(CHANNEL_0);
    5874:	80 e0       	ldi	r24, 0x00	; 0
    5876:	0e 94 1c 0b 	call	0x1638	; 0x1638 <MADC_u16ADC_StartConversion_With_Interrupt>
		}
		else
		{
			//Do Nothing
		}
		vTaskDelay(10);
    587a:	8a e0       	ldi	r24, 0x0A	; 10
    587c:	90 e0       	ldi	r25, 0x00	; 0
    587e:	0e 94 06 23 	call	0x460c	; 0x460c <vTaskDelay>
    5882:	c6 cf       	rjmp	.-116    	; 0x5810 <HeartRateRead+0x12>

00005884 <TimeSecIncreament>:
	}
}
void TimeSecIncreament(void*pv)
{
    5884:	df 93       	push	r29
    5886:	cf 93       	push	r28
    5888:	00 d0       	rcall	.+0      	; 0x588a <TimeSecIncreament+0x6>
    588a:	cd b7       	in	r28, 0x3d	; 61
    588c:	de b7       	in	r29, 0x3e	; 62
    588e:	9a 83       	std	Y+2, r25	; 0x02
    5890:	89 83       	std	Y+1, r24	; 0x01
	Update_DispFlag=1;
    5892:	81 e0       	ldi	r24, 0x01	; 1
    5894:	80 93 ad 07 	sts	0x07AD, r24
	while(1)
	{
		if(Set_TimeFlag==0)
    5898:	80 91 be 07 	lds	r24, 0x07BE
    589c:	88 23       	and	r24, r24
    589e:	09 f0       	breq	.+2      	; 0x58a2 <TimeSecIncreament+0x1e>
    58a0:	4b c0       	rjmp	.+150    	; 0x5938 <TimeSecIncreament+0xb4>
		{
			u8Second++;
    58a2:	80 91 a1 00 	lds	r24, 0x00A1
    58a6:	8f 5f       	subi	r24, 0xFF	; 255
    58a8:	80 93 a1 00 	sts	0x00A1, r24
			if(u8Second > 59)
    58ac:	80 91 a1 00 	lds	r24, 0x00A1
    58b0:	8c 33       	cpi	r24, 0x3C	; 60
    58b2:	08 f4       	brcc	.+2      	; 0x58b6 <TimeSecIncreament+0x32>
    58b4:	41 c0       	rjmp	.+130    	; 0x5938 <TimeSecIncreament+0xb4>
			{
				u8Second = 0;
    58b6:	10 92 a1 00 	sts	0x00A1, r1
				u8Minutes++;
    58ba:	80 91 a0 00 	lds	r24, 0x00A0
    58be:	8f 5f       	subi	r24, 0xFF	; 255
    58c0:	80 93 a0 00 	sts	0x00A0, r24
				if(u8Minutes > 59)
    58c4:	80 91 a0 00 	lds	r24, 0x00A0
    58c8:	8c 33       	cpi	r24, 0x3C	; 60
    58ca:	b0 f1       	brcs	.+108    	; 0x5938 <TimeSecIncreament+0xb4>
				{
					u8Minutes = 0;
    58cc:	10 92 a0 00 	sts	0x00A0, r1
					u8Hour++;
    58d0:	80 91 9f 00 	lds	r24, 0x009F
    58d4:	8f 5f       	subi	r24, 0xFF	; 255
    58d6:	80 93 9f 00 	sts	0x009F, r24
					if(u8Hour>23)
    58da:	80 91 9f 00 	lds	r24, 0x009F
    58de:	88 31       	cpi	r24, 0x18	; 24
    58e0:	58 f1       	brcs	.+86     	; 0x5938 <TimeSecIncreament+0xb4>
					{
						u8Hour = 0;
    58e2:	10 92 9f 00 	sts	0x009F, r1
						u16Day++;
    58e6:	80 91 9d 00 	lds	r24, 0x009D
    58ea:	90 91 9e 00 	lds	r25, 0x009E
    58ee:	01 96       	adiw	r24, 0x01	; 1
    58f0:	90 93 9e 00 	sts	0x009E, r25
    58f4:	80 93 9d 00 	sts	0x009D, r24
						if(u16Day>30)
    58f8:	80 91 9d 00 	lds	r24, 0x009D
    58fc:	90 91 9e 00 	lds	r25, 0x009E
    5900:	8f 31       	cpi	r24, 0x1F	; 31
    5902:	91 05       	cpc	r25, r1
    5904:	c8 f0       	brcs	.+50     	; 0x5938 <TimeSecIncreament+0xb4>
						{
							u16Month++;
    5906:	80 91 9b 00 	lds	r24, 0x009B
    590a:	90 91 9c 00 	lds	r25, 0x009C
    590e:	01 96       	adiw	r24, 0x01	; 1
    5910:	90 93 9c 00 	sts	0x009C, r25
    5914:	80 93 9b 00 	sts	0x009B, r24
							if(u16Month>12)
    5918:	80 91 9b 00 	lds	r24, 0x009B
    591c:	90 91 9c 00 	lds	r25, 0x009C
    5920:	8d 30       	cpi	r24, 0x0D	; 13
    5922:	91 05       	cpc	r25, r1
    5924:	48 f0       	brcs	.+18     	; 0x5938 <TimeSecIncreament+0xb4>
							{
								u16Year++;
    5926:	80 91 99 00 	lds	r24, 0x0099
    592a:	90 91 9a 00 	lds	r25, 0x009A
    592e:	01 96       	adiw	r24, 0x01	; 1
    5930:	90 93 9a 00 	sts	0x009A, r25
    5934:	80 93 99 00 	sts	0x0099, r24
				}

			}
		}

		vTaskDelay(1000);
    5938:	88 ee       	ldi	r24, 0xE8	; 232
    593a:	93 e0       	ldi	r25, 0x03	; 3
    593c:	0e 94 06 23 	call	0x460c	; 0x460c <vTaskDelay>
    5940:	ab cf       	rjmp	.-170    	; 0x5898 <TimeSecIncreament+0x14>

00005942 <ADC_SetNotification>:
	}
}
void ADC_SetNotification(void)
{
    5942:	df 93       	push	r29
    5944:	cf 93       	push	r28
    5946:	cd b7       	in	r28, 0x3d	; 61
    5948:	de b7       	in	r29, 0x3e	; 62
	xSemaphoreGive(ADCSem);
    594a:	80 91 d1 07 	lds	r24, 0x07D1
    594e:	90 91 d2 07 	lds	r25, 0x07D2
    5952:	60 e0       	ldi	r22, 0x00	; 0
    5954:	70 e0       	ldi	r23, 0x00	; 0
    5956:	40 e0       	ldi	r20, 0x00	; 0
    5958:	50 e0       	ldi	r21, 0x00	; 0
    595a:	20 e0       	ldi	r18, 0x00	; 0
    595c:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>
}
    5960:	cf 91       	pop	r28
    5962:	df 91       	pop	r29
    5964:	08 95       	ret

00005966 <LCD_Display>:

void LCD_Display(void*pv)
{
    5966:	df 93       	push	r29
    5968:	cf 93       	push	r28
    596a:	00 d0       	rcall	.+0      	; 0x596c <LCD_Display+0x6>
    596c:	0f 92       	push	r0
    596e:	cd b7       	in	r28, 0x3d	; 61
    5970:	de b7       	in	r29, 0x3e	; 62
    5972:	9b 83       	std	Y+3, r25	; 0x03
    5974:	8a 83       	std	Y+2, r24	; 0x02
	static u8 LOC_u8Hour;
	static u8 LOC_u8Minutes;
	static u8 LOC_u8Second;
	static u8 LOC_u8Temperature;
	static u8 LOC_u8HeartRate;
	u8 Loc_u8SemState=0;
    5976:	19 82       	std	Y+1, r1	; 0x01


	while(1)
	{
		Loc_u8SemState=xSemaphoreTake(LCDSem,10);
    5978:	80 91 ca 07 	lds	r24, 0x07CA
    597c:	90 91 cb 07 	lds	r25, 0x07CB
    5980:	60 e0       	ldi	r22, 0x00	; 0
    5982:	70 e0       	ldi	r23, 0x00	; 0
    5984:	4a e0       	ldi	r20, 0x0A	; 10
    5986:	50 e0       	ldi	r21, 0x00	; 0
    5988:	20 e0       	ldi	r18, 0x00	; 0
    598a:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xQueueGenericReceive>
    598e:	89 83       	std	Y+1, r24	; 0x01
		if(Loc_u8SemState==pdPASS)
    5990:	89 81       	ldd	r24, Y+1	; 0x01
    5992:	81 30       	cpi	r24, 0x01	; 1
    5994:	09 f0       	breq	.+2      	; 0x5998 <LCD_Display+0x32>
    5996:	6b c0       	rjmp	.+214    	; 0x5a6e <LCD_Display+0x108>
		{
			xQueueReceive(LCDDateQueue,&LOC_u16Year,0);
    5998:	80 91 c7 07 	lds	r24, 0x07C7
    599c:	90 91 c8 07 	lds	r25, 0x07C8
    59a0:	2c eb       	ldi	r18, 0xBC	; 188
    59a2:	37 e0       	ldi	r19, 0x07	; 7
    59a4:	b9 01       	movw	r22, r18
    59a6:	40 e0       	ldi	r20, 0x00	; 0
    59a8:	50 e0       	ldi	r21, 0x00	; 0
    59aa:	20 e0       	ldi	r18, 0x00	; 0
    59ac:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xQueueGenericReceive>
			xQueueReceive(LCDDateQueue,&LOC_u16Month,0);
    59b0:	80 91 c7 07 	lds	r24, 0x07C7
    59b4:	90 91 c8 07 	lds	r25, 0x07C8
    59b8:	2a eb       	ldi	r18, 0xBA	; 186
    59ba:	37 e0       	ldi	r19, 0x07	; 7
    59bc:	b9 01       	movw	r22, r18
    59be:	40 e0       	ldi	r20, 0x00	; 0
    59c0:	50 e0       	ldi	r21, 0x00	; 0
    59c2:	20 e0       	ldi	r18, 0x00	; 0
    59c4:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xQueueGenericReceive>
			xQueueReceive(LCDDateQueue,&LOC_u16Day,0);
    59c8:	80 91 c7 07 	lds	r24, 0x07C7
    59cc:	90 91 c8 07 	lds	r25, 0x07C8
    59d0:	28 eb       	ldi	r18, 0xB8	; 184
    59d2:	37 e0       	ldi	r19, 0x07	; 7
    59d4:	b9 01       	movw	r22, r18
    59d6:	40 e0       	ldi	r20, 0x00	; 0
    59d8:	50 e0       	ldi	r21, 0x00	; 0
    59da:	20 e0       	ldi	r18, 0x00	; 0
    59dc:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xQueueGenericReceive>

			xQueueReceive(LCDTimeQueue,&LOC_u8Hour,0);
    59e0:	80 91 c5 07 	lds	r24, 0x07C5
    59e4:	90 91 c6 07 	lds	r25, 0x07C6
    59e8:	27 eb       	ldi	r18, 0xB7	; 183
    59ea:	37 e0       	ldi	r19, 0x07	; 7
    59ec:	b9 01       	movw	r22, r18
    59ee:	40 e0       	ldi	r20, 0x00	; 0
    59f0:	50 e0       	ldi	r21, 0x00	; 0
    59f2:	20 e0       	ldi	r18, 0x00	; 0
    59f4:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xQueueGenericReceive>
			xQueueReceive(LCDTimeQueue,&LOC_u8Minutes,0);
    59f8:	80 91 c5 07 	lds	r24, 0x07C5
    59fc:	90 91 c6 07 	lds	r25, 0x07C6
    5a00:	26 eb       	ldi	r18, 0xB6	; 182
    5a02:	37 e0       	ldi	r19, 0x07	; 7
    5a04:	b9 01       	movw	r22, r18
    5a06:	40 e0       	ldi	r20, 0x00	; 0
    5a08:	50 e0       	ldi	r21, 0x00	; 0
    5a0a:	20 e0       	ldi	r18, 0x00	; 0
    5a0c:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xQueueGenericReceive>
			xQueueReceive(LCDTimeQueue,&LOC_u8Second,0);
    5a10:	80 91 c5 07 	lds	r24, 0x07C5
    5a14:	90 91 c6 07 	lds	r25, 0x07C6
    5a18:	25 eb       	ldi	r18, 0xB5	; 181
    5a1a:	37 e0       	ldi	r19, 0x07	; 7
    5a1c:	b9 01       	movw	r22, r18
    5a1e:	40 e0       	ldi	r20, 0x00	; 0
    5a20:	50 e0       	ldi	r21, 0x00	; 0
    5a22:	20 e0       	ldi	r18, 0x00	; 0
    5a24:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xQueueGenericReceive>

			/*Features*/
			xQueueReceive(LCDFeaturesQueue,&LOC_u8Temperature,5);
    5a28:	80 91 cf 07 	lds	r24, 0x07CF
    5a2c:	90 91 d0 07 	lds	r25, 0x07D0
    5a30:	24 eb       	ldi	r18, 0xB4	; 180
    5a32:	37 e0       	ldi	r19, 0x07	; 7
    5a34:	b9 01       	movw	r22, r18
    5a36:	45 e0       	ldi	r20, 0x05	; 5
    5a38:	50 e0       	ldi	r21, 0x00	; 0
    5a3a:	20 e0       	ldi	r18, 0x00	; 0
    5a3c:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xQueueGenericReceive>
			xQueueReceive(LCDFeaturesQueue,&LOC_u8HeartRate,5);
    5a40:	80 91 cf 07 	lds	r24, 0x07CF
    5a44:	90 91 d0 07 	lds	r25, 0x07D0
    5a48:	23 eb       	ldi	r18, 0xB3	; 179
    5a4a:	37 e0       	ldi	r19, 0x07	; 7
    5a4c:	b9 01       	movw	r22, r18
    5a4e:	45 e0       	ldi	r20, 0x05	; 5
    5a50:	50 e0       	ldi	r21, 0x00	; 0
    5a52:	20 e0       	ldi	r18, 0x00	; 0
    5a54:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xQueueGenericReceive>

			xSemaphoreGive(LCDSem);
    5a58:	80 91 ca 07 	lds	r24, 0x07CA
    5a5c:	90 91 cb 07 	lds	r25, 0x07CB
    5a60:	60 e0       	ldi	r22, 0x00	; 0
    5a62:	70 e0       	ldi	r23, 0x00	; 0
    5a64:	40 e0       	ldi	r20, 0x00	; 0
    5a66:	50 e0       	ldi	r21, 0x00	; 0
    5a68:	20 e0       	ldi	r18, 0x00	; 0
    5a6a:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <xQueueGenericSend>
		}
		else
		{

		}
		if(Features_DispFlag==0)
    5a6e:	80 91 ac 07 	lds	r24, 0x07AC
    5a72:	88 23       	and	r24, r24
    5a74:	09 f0       	breq	.+2      	; 0x5a78 <LCD_Display+0x112>
    5a76:	bf c0       	rjmp	.+382    	; 0x5bf6 <LCD_Display+0x290>
		{

			HCLCD_VidSetPosition_4BitsMode(HCLCD_LINE1,2);
    5a78:	81 e0       	ldi	r24, 0x01	; 1
    5a7a:	62 e0       	ldi	r22, 0x02	; 2
    5a7c:	0e 94 12 15 	call	0x2a24	; 0x2a24 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidSendChar_4Bits('/');
    5a80:	8f e2       	ldi	r24, 0x2F	; 47
    5a82:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>
			HCLCD_VidSetPosition_4BitsMode(HCLCD_LINE1,5);
    5a86:	81 e0       	ldi	r24, 0x01	; 1
    5a88:	65 e0       	ldi	r22, 0x05	; 5
    5a8a:	0e 94 12 15 	call	0x2a24	; 0x2a24 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidSendChar_4Bits('/');
    5a8e:	8f e2       	ldi	r24, 0x2F	; 47
    5a90:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>
			HCLCD_VidSetPosition_4BitsMode(HCLCD_LINE2,2);
    5a94:	82 e0       	ldi	r24, 0x02	; 2
    5a96:	62 e0       	ldi	r22, 0x02	; 2
    5a98:	0e 94 12 15 	call	0x2a24	; 0x2a24 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidSendChar_4Bits(':');
    5a9c:	8a e3       	ldi	r24, 0x3A	; 58
    5a9e:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>
			HCLCD_VidSetPosition_4BitsMode(HCLCD_LINE2,5);
    5aa2:	82 e0       	ldi	r24, 0x02	; 2
    5aa4:	65 e0       	ldi	r22, 0x05	; 5
    5aa6:	0e 94 12 15 	call	0x2a24	; 0x2a24 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidSendChar_4Bits(':');
    5aaa:	8a e3       	ldi	r24, 0x3A	; 58
    5aac:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>
			HCLCD_VidSetPosition_4BitsMode(HCLCD_LINE1,0);
    5ab0:	81 e0       	ldi	r24, 0x01	; 1
    5ab2:	60 e0       	ldi	r22, 0x00	; 0
    5ab4:	0e 94 12 15 	call	0x2a24	; 0x2a24 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidSendChar_4Bits((LOC_u16Day/10)+48);
    5ab8:	80 91 b8 07 	lds	r24, 0x07B8
    5abc:	90 91 b9 07 	lds	r25, 0x07B9
    5ac0:	2a e0       	ldi	r18, 0x0A	; 10
    5ac2:	30 e0       	ldi	r19, 0x00	; 0
    5ac4:	b9 01       	movw	r22, r18
    5ac6:	0e 94 76 2e 	call	0x5cec	; 0x5cec <__udivmodhi4>
    5aca:	cb 01       	movw	r24, r22
    5acc:	80 5d       	subi	r24, 0xD0	; 208
    5ace:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>
			HCLCD_VidSendChar_4Bits((LOC_u16Day%10)+48);
    5ad2:	80 91 b8 07 	lds	r24, 0x07B8
    5ad6:	90 91 b9 07 	lds	r25, 0x07B9
    5ada:	2a e0       	ldi	r18, 0x0A	; 10
    5adc:	30 e0       	ldi	r19, 0x00	; 0
    5ade:	b9 01       	movw	r22, r18
    5ae0:	0e 94 76 2e 	call	0x5cec	; 0x5cec <__udivmodhi4>
    5ae4:	80 5d       	subi	r24, 0xD0	; 208
    5ae6:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>



			HCLCD_VidSetPosition_4BitsMode(HCLCD_LINE1,3);
    5aea:	81 e0       	ldi	r24, 0x01	; 1
    5aec:	63 e0       	ldi	r22, 0x03	; 3
    5aee:	0e 94 12 15 	call	0x2a24	; 0x2a24 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidSendChar_4Bits((LOC_u16Month/10)+48);
    5af2:	80 91 ba 07 	lds	r24, 0x07BA
    5af6:	90 91 bb 07 	lds	r25, 0x07BB
    5afa:	2a e0       	ldi	r18, 0x0A	; 10
    5afc:	30 e0       	ldi	r19, 0x00	; 0
    5afe:	b9 01       	movw	r22, r18
    5b00:	0e 94 76 2e 	call	0x5cec	; 0x5cec <__udivmodhi4>
    5b04:	cb 01       	movw	r24, r22
    5b06:	80 5d       	subi	r24, 0xD0	; 208
    5b08:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>
			HCLCD_VidSendChar_4Bits((LOC_u16Month%10)+48);
    5b0c:	80 91 ba 07 	lds	r24, 0x07BA
    5b10:	90 91 bb 07 	lds	r25, 0x07BB
    5b14:	2a e0       	ldi	r18, 0x0A	; 10
    5b16:	30 e0       	ldi	r19, 0x00	; 0
    5b18:	b9 01       	movw	r22, r18
    5b1a:	0e 94 76 2e 	call	0x5cec	; 0x5cec <__udivmodhi4>
    5b1e:	80 5d       	subi	r24, 0xD0	; 208
    5b20:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>



			HCLCD_VidSetPosition_4BitsMode(HCLCD_LINE1,6);
    5b24:	81 e0       	ldi	r24, 0x01	; 1
    5b26:	66 e0       	ldi	r22, 0x06	; 6
    5b28:	0e 94 12 15 	call	0x2a24	; 0x2a24 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteNumber_4Bits(LOC_u16Year);
    5b2c:	80 91 bc 07 	lds	r24, 0x07BC
    5b30:	90 91 bd 07 	lds	r25, 0x07BD
    5b34:	cc 01       	movw	r24, r24
    5b36:	a0 e0       	ldi	r26, 0x00	; 0
    5b38:	b0 e0       	ldi	r27, 0x00	; 0
    5b3a:	bc 01       	movw	r22, r24
    5b3c:	cd 01       	movw	r24, r26
    5b3e:	0e 94 9b 14 	call	0x2936	; 0x2936 <HCLCD_VidWriteNumber_4Bits>
			HCLCD_VidSetPosition_4BitsMode(HCLCD_LINE1,10);
    5b42:	81 e0       	ldi	r24, 0x01	; 1
    5b44:	6a e0       	ldi	r22, 0x0A	; 10
    5b46:	0e 94 12 15 	call	0x2a24	; 0x2a24 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits("       ");
    5b4a:	80 e7       	ldi	r24, 0x70	; 112
    5b4c:	90 e0       	ldi	r25, 0x00	; 0
    5b4e:	0e 94 72 14 	call	0x28e4	; 0x28e4 <HCLCD_VidWriteString_4Bits>
			HCLCD_VidSetPosition_4BitsMode(HCLCD_LINE2,0);
    5b52:	82 e0       	ldi	r24, 0x02	; 2
    5b54:	60 e0       	ldi	r22, 0x00	; 0
    5b56:	0e 94 12 15 	call	0x2a24	; 0x2a24 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidSendChar_4Bits((LOC_u8Hour/10)+48);
    5b5a:	80 91 b7 07 	lds	r24, 0x07B7
    5b5e:	9a e0       	ldi	r25, 0x0A	; 10
    5b60:	69 2f       	mov	r22, r25
    5b62:	0e 94 6a 2e 	call	0x5cd4	; 0x5cd4 <__udivmodqi4>
    5b66:	80 5d       	subi	r24, 0xD0	; 208
    5b68:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>
			HCLCD_VidSendChar_4Bits((LOC_u8Hour%10)+48);
    5b6c:	80 91 b7 07 	lds	r24, 0x07B7
    5b70:	9a e0       	ldi	r25, 0x0A	; 10
    5b72:	69 2f       	mov	r22, r25
    5b74:	0e 94 6a 2e 	call	0x5cd4	; 0x5cd4 <__udivmodqi4>
    5b78:	89 2f       	mov	r24, r25
    5b7a:	80 5d       	subi	r24, 0xD0	; 208
    5b7c:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>



			HCLCD_VidSetPosition_4BitsMode(HCLCD_LINE2,3);
    5b80:	82 e0       	ldi	r24, 0x02	; 2
    5b82:	63 e0       	ldi	r22, 0x03	; 3
    5b84:	0e 94 12 15 	call	0x2a24	; 0x2a24 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidSendChar_4Bits((LOC_u8Minutes/10)+48);
    5b88:	80 91 b6 07 	lds	r24, 0x07B6
    5b8c:	9a e0       	ldi	r25, 0x0A	; 10
    5b8e:	69 2f       	mov	r22, r25
    5b90:	0e 94 6a 2e 	call	0x5cd4	; 0x5cd4 <__udivmodqi4>
    5b94:	80 5d       	subi	r24, 0xD0	; 208
    5b96:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>
			HCLCD_VidSendChar_4Bits((LOC_u8Minutes%10)+48);
    5b9a:	80 91 b6 07 	lds	r24, 0x07B6
    5b9e:	9a e0       	ldi	r25, 0x0A	; 10
    5ba0:	69 2f       	mov	r22, r25
    5ba2:	0e 94 6a 2e 	call	0x5cd4	; 0x5cd4 <__udivmodqi4>
    5ba6:	89 2f       	mov	r24, r25
    5ba8:	80 5d       	subi	r24, 0xD0	; 208
    5baa:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>



			HCLCD_VidSetPosition_4BitsMode(HCLCD_LINE2,6);
    5bae:	82 e0       	ldi	r24, 0x02	; 2
    5bb0:	66 e0       	ldi	r22, 0x06	; 6
    5bb2:	0e 94 12 15 	call	0x2a24	; 0x2a24 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidSendChar_4Bits((LOC_u8Second/10)+48);
    5bb6:	80 91 b5 07 	lds	r24, 0x07B5
    5bba:	9a e0       	ldi	r25, 0x0A	; 10
    5bbc:	69 2f       	mov	r22, r25
    5bbe:	0e 94 6a 2e 	call	0x5cd4	; 0x5cd4 <__udivmodqi4>
    5bc2:	80 5d       	subi	r24, 0xD0	; 208
    5bc4:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>
			HCLCD_VidSendChar_4Bits((LOC_u8Second%10)+48);
    5bc8:	80 91 b5 07 	lds	r24, 0x07B5
    5bcc:	9a e0       	ldi	r25, 0x0A	; 10
    5bce:	69 2f       	mov	r22, r25
    5bd0:	0e 94 6a 2e 	call	0x5cd4	; 0x5cd4 <__udivmodqi4>
    5bd4:	89 2f       	mov	r24, r25
    5bd6:	80 5d       	subi	r24, 0xD0	; 208
    5bd8:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>
			HCLCD_VidSetPosition_4BitsMode(HCLCD_LINE1,0);
    5bdc:	81 e0       	ldi	r24, 0x01	; 1
    5bde:	60 e0       	ldi	r22, 0x00	; 0
    5be0:	0e 94 12 15 	call	0x2a24	; 0x2a24 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidSetPosition_4BitsMode(HCLCD_LINE2,8);
    5be4:	82 e0       	ldi	r24, 0x02	; 2
    5be6:	68 e0       	ldi	r22, 0x08	; 8
    5be8:	0e 94 12 15 	call	0x2a24	; 0x2a24 <HCLCD_VidSetPosition_4BitsMode>

			HCLCD_VidWriteString_4Bits("       ");
    5bec:	80 e7       	ldi	r24, 0x70	; 112
    5bee:	90 e0       	ldi	r25, 0x00	; 0
    5bf0:	0e 94 72 14 	call	0x28e4	; 0x28e4 <HCLCD_VidWriteString_4Bits>
    5bf4:	4b c0       	rjmp	.+150    	; 0x5c8c <LCD_Display+0x326>
		}
		else if(Features_DispFlag==1)
    5bf6:	80 91 ac 07 	lds	r24, 0x07AC
    5bfa:	81 30       	cpi	r24, 0x01	; 1
    5bfc:	09 f0       	breq	.+2      	; 0x5c00 <LCD_Display+0x29a>
    5bfe:	46 c0       	rjmp	.+140    	; 0x5c8c <LCD_Display+0x326>
		{

			HCLCD_VidSetPosition_4BitsMode(HCLCD_LINE1,0);
    5c00:	81 e0       	ldi	r24, 0x01	; 1
    5c02:	60 e0       	ldi	r22, 0x00	; 0
    5c04:	0e 94 12 15 	call	0x2a24	; 0x2a24 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits("Temp=");
    5c08:	88 e7       	ldi	r24, 0x78	; 120
    5c0a:	90 e0       	ldi	r25, 0x00	; 0
    5c0c:	0e 94 72 14 	call	0x28e4	; 0x28e4 <HCLCD_VidWriteString_4Bits>
			HCLCD_VidSetPosition_4BitsMode(HCLCD_LINE1,7);
    5c10:	81 e0       	ldi	r24, 0x01	; 1
    5c12:	67 e0       	ldi	r22, 0x07	; 7
    5c14:	0e 94 12 15 	call	0x2a24	; 0x2a24 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidSendChar_4Bits((LOC_u8Temperature/10)+48);
    5c18:	80 91 b4 07 	lds	r24, 0x07B4
    5c1c:	9a e0       	ldi	r25, 0x0A	; 10
    5c1e:	69 2f       	mov	r22, r25
    5c20:	0e 94 6a 2e 	call	0x5cd4	; 0x5cd4 <__udivmodqi4>
    5c24:	80 5d       	subi	r24, 0xD0	; 208
    5c26:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>
			HCLCD_VidSendChar_4Bits((LOC_u8Temperature%10)+48);
    5c2a:	80 91 b4 07 	lds	r24, 0x07B4
    5c2e:	9a e0       	ldi	r25, 0x0A	; 10
    5c30:	69 2f       	mov	r22, r25
    5c32:	0e 94 6a 2e 	call	0x5cd4	; 0x5cd4 <__udivmodqi4>
    5c36:	89 2f       	mov	r24, r25
    5c38:	80 5d       	subi	r24, 0xD0	; 208
    5c3a:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>
			HCLCD_VidWriteString_4Bits("C   ");
    5c3e:	8e e7       	ldi	r24, 0x7E	; 126
    5c40:	90 e0       	ldi	r25, 0x00	; 0
    5c42:	0e 94 72 14 	call	0x28e4	; 0x28e4 <HCLCD_VidWriteString_4Bits>

			HCLCD_VidSetPosition_4BitsMode(HCLCD_LINE2,0);
    5c46:	82 e0       	ldi	r24, 0x02	; 2
    5c48:	60 e0       	ldi	r22, 0x00	; 0
    5c4a:	0e 94 12 15 	call	0x2a24	; 0x2a24 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidWriteString_4Bits("Hrate=");
    5c4e:	83 e8       	ldi	r24, 0x83	; 131
    5c50:	90 e0       	ldi	r25, 0x00	; 0
    5c52:	0e 94 72 14 	call	0x28e4	; 0x28e4 <HCLCD_VidWriteString_4Bits>
			HCLCD_VidSetPosition_4BitsMode(HCLCD_LINE2,7);
    5c56:	82 e0       	ldi	r24, 0x02	; 2
    5c58:	67 e0       	ldi	r22, 0x07	; 7
    5c5a:	0e 94 12 15 	call	0x2a24	; 0x2a24 <HCLCD_VidSetPosition_4BitsMode>
			HCLCD_VidSendChar_4Bits((LOC_u8HeartRate/10)+48);
    5c5e:	80 91 b3 07 	lds	r24, 0x07B3
    5c62:	9a e0       	ldi	r25, 0x0A	; 10
    5c64:	69 2f       	mov	r22, r25
    5c66:	0e 94 6a 2e 	call	0x5cd4	; 0x5cd4 <__udivmodqi4>
    5c6a:	80 5d       	subi	r24, 0xD0	; 208
    5c6c:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>
			HCLCD_VidSendChar_4Bits((LOC_u8HeartRate%10)+48);
    5c70:	80 91 b3 07 	lds	r24, 0x07B3
    5c74:	9a e0       	ldi	r25, 0x0A	; 10
    5c76:	69 2f       	mov	r22, r25
    5c78:	0e 94 6a 2e 	call	0x5cd4	; 0x5cd4 <__udivmodqi4>
    5c7c:	89 2f       	mov	r24, r25
    5c7e:	80 5d       	subi	r24, 0xD0	; 208
    5c80:	0e 94 60 14 	call	0x28c0	; 0x28c0 <HCLCD_VidSendChar_4Bits>
			HCLCD_VidWriteString_4Bits("Bpm ");
    5c84:	8a e8       	ldi	r24, 0x8A	; 138
    5c86:	90 e0       	ldi	r25, 0x00	; 0
    5c88:	0e 94 72 14 	call	0x28e4	; 0x28e4 <HCLCD_VidWriteString_4Bits>
		}
		else
		{
         /*Do Nothing*/
		}
		vTaskDelay(100);
    5c8c:	84 e6       	ldi	r24, 0x64	; 100
    5c8e:	90 e0       	ldi	r25, 0x00	; 0
    5c90:	0e 94 06 23 	call	0x460c	; 0x460c <vTaskDelay>
    5c94:	71 ce       	rjmp	.-798    	; 0x5978 <LCD_Display+0x12>

00005c96 <__mulsi3>:
    5c96:	62 9f       	mul	r22, r18
    5c98:	d0 01       	movw	r26, r0
    5c9a:	73 9f       	mul	r23, r19
    5c9c:	f0 01       	movw	r30, r0
    5c9e:	82 9f       	mul	r24, r18
    5ca0:	e0 0d       	add	r30, r0
    5ca2:	f1 1d       	adc	r31, r1
    5ca4:	64 9f       	mul	r22, r20
    5ca6:	e0 0d       	add	r30, r0
    5ca8:	f1 1d       	adc	r31, r1
    5caa:	92 9f       	mul	r25, r18
    5cac:	f0 0d       	add	r31, r0
    5cae:	83 9f       	mul	r24, r19
    5cb0:	f0 0d       	add	r31, r0
    5cb2:	74 9f       	mul	r23, r20
    5cb4:	f0 0d       	add	r31, r0
    5cb6:	65 9f       	mul	r22, r21
    5cb8:	f0 0d       	add	r31, r0
    5cba:	99 27       	eor	r25, r25
    5cbc:	72 9f       	mul	r23, r18
    5cbe:	b0 0d       	add	r27, r0
    5cc0:	e1 1d       	adc	r30, r1
    5cc2:	f9 1f       	adc	r31, r25
    5cc4:	63 9f       	mul	r22, r19
    5cc6:	b0 0d       	add	r27, r0
    5cc8:	e1 1d       	adc	r30, r1
    5cca:	f9 1f       	adc	r31, r25
    5ccc:	bd 01       	movw	r22, r26
    5cce:	cf 01       	movw	r24, r30
    5cd0:	11 24       	eor	r1, r1
    5cd2:	08 95       	ret

00005cd4 <__udivmodqi4>:
    5cd4:	99 1b       	sub	r25, r25
    5cd6:	79 e0       	ldi	r23, 0x09	; 9
    5cd8:	04 c0       	rjmp	.+8      	; 0x5ce2 <__udivmodqi4_ep>

00005cda <__udivmodqi4_loop>:
    5cda:	99 1f       	adc	r25, r25
    5cdc:	96 17       	cp	r25, r22
    5cde:	08 f0       	brcs	.+2      	; 0x5ce2 <__udivmodqi4_ep>
    5ce0:	96 1b       	sub	r25, r22

00005ce2 <__udivmodqi4_ep>:
    5ce2:	88 1f       	adc	r24, r24
    5ce4:	7a 95       	dec	r23
    5ce6:	c9 f7       	brne	.-14     	; 0x5cda <__udivmodqi4_loop>
    5ce8:	80 95       	com	r24
    5cea:	08 95       	ret

00005cec <__udivmodhi4>:
    5cec:	aa 1b       	sub	r26, r26
    5cee:	bb 1b       	sub	r27, r27
    5cf0:	51 e1       	ldi	r21, 0x11	; 17
    5cf2:	07 c0       	rjmp	.+14     	; 0x5d02 <__udivmodhi4_ep>

00005cf4 <__udivmodhi4_loop>:
    5cf4:	aa 1f       	adc	r26, r26
    5cf6:	bb 1f       	adc	r27, r27
    5cf8:	a6 17       	cp	r26, r22
    5cfa:	b7 07       	cpc	r27, r23
    5cfc:	10 f0       	brcs	.+4      	; 0x5d02 <__udivmodhi4_ep>
    5cfe:	a6 1b       	sub	r26, r22
    5d00:	b7 0b       	sbc	r27, r23

00005d02 <__udivmodhi4_ep>:
    5d02:	88 1f       	adc	r24, r24
    5d04:	99 1f       	adc	r25, r25
    5d06:	5a 95       	dec	r21
    5d08:	a9 f7       	brne	.-22     	; 0x5cf4 <__udivmodhi4_loop>
    5d0a:	80 95       	com	r24
    5d0c:	90 95       	com	r25
    5d0e:	bc 01       	movw	r22, r24
    5d10:	cd 01       	movw	r24, r26
    5d12:	08 95       	ret

00005d14 <__udivmodsi4>:
    5d14:	a1 e2       	ldi	r26, 0x21	; 33
    5d16:	1a 2e       	mov	r1, r26
    5d18:	aa 1b       	sub	r26, r26
    5d1a:	bb 1b       	sub	r27, r27
    5d1c:	fd 01       	movw	r30, r26
    5d1e:	0d c0       	rjmp	.+26     	; 0x5d3a <__udivmodsi4_ep>

00005d20 <__udivmodsi4_loop>:
    5d20:	aa 1f       	adc	r26, r26
    5d22:	bb 1f       	adc	r27, r27
    5d24:	ee 1f       	adc	r30, r30
    5d26:	ff 1f       	adc	r31, r31
    5d28:	a2 17       	cp	r26, r18
    5d2a:	b3 07       	cpc	r27, r19
    5d2c:	e4 07       	cpc	r30, r20
    5d2e:	f5 07       	cpc	r31, r21
    5d30:	20 f0       	brcs	.+8      	; 0x5d3a <__udivmodsi4_ep>
    5d32:	a2 1b       	sub	r26, r18
    5d34:	b3 0b       	sbc	r27, r19
    5d36:	e4 0b       	sbc	r30, r20
    5d38:	f5 0b       	sbc	r31, r21

00005d3a <__udivmodsi4_ep>:
    5d3a:	66 1f       	adc	r22, r22
    5d3c:	77 1f       	adc	r23, r23
    5d3e:	88 1f       	adc	r24, r24
    5d40:	99 1f       	adc	r25, r25
    5d42:	1a 94       	dec	r1
    5d44:	69 f7       	brne	.-38     	; 0x5d20 <__udivmodsi4_loop>
    5d46:	60 95       	com	r22
    5d48:	70 95       	com	r23
    5d4a:	80 95       	com	r24
    5d4c:	90 95       	com	r25
    5d4e:	9b 01       	movw	r18, r22
    5d50:	ac 01       	movw	r20, r24
    5d52:	bd 01       	movw	r22, r26
    5d54:	cf 01       	movw	r24, r30
    5d56:	08 95       	ret

00005d58 <__prologue_saves__>:
    5d58:	2f 92       	push	r2
    5d5a:	3f 92       	push	r3
    5d5c:	4f 92       	push	r4
    5d5e:	5f 92       	push	r5
    5d60:	6f 92       	push	r6
    5d62:	7f 92       	push	r7
    5d64:	8f 92       	push	r8
    5d66:	9f 92       	push	r9
    5d68:	af 92       	push	r10
    5d6a:	bf 92       	push	r11
    5d6c:	cf 92       	push	r12
    5d6e:	df 92       	push	r13
    5d70:	ef 92       	push	r14
    5d72:	ff 92       	push	r15
    5d74:	0f 93       	push	r16
    5d76:	1f 93       	push	r17
    5d78:	cf 93       	push	r28
    5d7a:	df 93       	push	r29
    5d7c:	cd b7       	in	r28, 0x3d	; 61
    5d7e:	de b7       	in	r29, 0x3e	; 62
    5d80:	ca 1b       	sub	r28, r26
    5d82:	db 0b       	sbc	r29, r27
    5d84:	0f b6       	in	r0, 0x3f	; 63
    5d86:	f8 94       	cli
    5d88:	de bf       	out	0x3e, r29	; 62
    5d8a:	0f be       	out	0x3f, r0	; 63
    5d8c:	cd bf       	out	0x3d, r28	; 61
    5d8e:	09 94       	ijmp

00005d90 <__epilogue_restores__>:
    5d90:	2a 88       	ldd	r2, Y+18	; 0x12
    5d92:	39 88       	ldd	r3, Y+17	; 0x11
    5d94:	48 88       	ldd	r4, Y+16	; 0x10
    5d96:	5f 84       	ldd	r5, Y+15	; 0x0f
    5d98:	6e 84       	ldd	r6, Y+14	; 0x0e
    5d9a:	7d 84       	ldd	r7, Y+13	; 0x0d
    5d9c:	8c 84       	ldd	r8, Y+12	; 0x0c
    5d9e:	9b 84       	ldd	r9, Y+11	; 0x0b
    5da0:	aa 84       	ldd	r10, Y+10	; 0x0a
    5da2:	b9 84       	ldd	r11, Y+9	; 0x09
    5da4:	c8 84       	ldd	r12, Y+8	; 0x08
    5da6:	df 80       	ldd	r13, Y+7	; 0x07
    5da8:	ee 80       	ldd	r14, Y+6	; 0x06
    5daa:	fd 80       	ldd	r15, Y+5	; 0x05
    5dac:	0c 81       	ldd	r16, Y+4	; 0x04
    5dae:	1b 81       	ldd	r17, Y+3	; 0x03
    5db0:	aa 81       	ldd	r26, Y+2	; 0x02
    5db2:	b9 81       	ldd	r27, Y+1	; 0x01
    5db4:	ce 0f       	add	r28, r30
    5db6:	d1 1d       	adc	r29, r1
    5db8:	0f b6       	in	r0, 0x3f	; 63
    5dba:	f8 94       	cli
    5dbc:	de bf       	out	0x3e, r29	; 62
    5dbe:	0f be       	out	0x3f, r0	; 63
    5dc0:	cd bf       	out	0x3d, r28	; 61
    5dc2:	ed 01       	movw	r28, r26
    5dc4:	08 95       	ret

00005dc6 <memcpy>:
    5dc6:	fb 01       	movw	r30, r22
    5dc8:	dc 01       	movw	r26, r24
    5dca:	02 c0       	rjmp	.+4      	; 0x5dd0 <memcpy+0xa>
    5dcc:	01 90       	ld	r0, Z+
    5dce:	0d 92       	st	X+, r0
    5dd0:	41 50       	subi	r20, 0x01	; 1
    5dd2:	50 40       	sbci	r21, 0x00	; 0
    5dd4:	d8 f7       	brcc	.-10     	; 0x5dcc <memcpy+0x6>
    5dd6:	08 95       	ret

00005dd8 <memset>:
    5dd8:	dc 01       	movw	r26, r24
    5dda:	01 c0       	rjmp	.+2      	; 0x5dde <memset+0x6>
    5ddc:	6d 93       	st	X+, r22
    5dde:	41 50       	subi	r20, 0x01	; 1
    5de0:	50 40       	sbci	r21, 0x00	; 0
    5de2:	e0 f7       	brcc	.-8      	; 0x5ddc <memset+0x4>
    5de4:	08 95       	ret

00005de6 <strncpy>:
    5de6:	fb 01       	movw	r30, r22
    5de8:	dc 01       	movw	r26, r24
    5dea:	41 50       	subi	r20, 0x01	; 1
    5dec:	50 40       	sbci	r21, 0x00	; 0
    5dee:	48 f0       	brcs	.+18     	; 0x5e02 <strncpy+0x1c>
    5df0:	01 90       	ld	r0, Z+
    5df2:	0d 92       	st	X+, r0
    5df4:	00 20       	and	r0, r0
    5df6:	c9 f7       	brne	.-14     	; 0x5dea <strncpy+0x4>
    5df8:	01 c0       	rjmp	.+2      	; 0x5dfc <strncpy+0x16>
    5dfa:	1d 92       	st	X+, r1
    5dfc:	41 50       	subi	r20, 0x01	; 1
    5dfe:	50 40       	sbci	r21, 0x00	; 0
    5e00:	e0 f7       	brcc	.-8      	; 0x5dfa <strncpy+0x14>
    5e02:	08 95       	ret

00005e04 <_exit>:
    5e04:	f8 94       	cli

00005e06 <__stop_program>:
    5e06:	ff cf       	rjmp	.-2      	; 0x5e06 <__stop_program>
